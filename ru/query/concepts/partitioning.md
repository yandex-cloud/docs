# Партиционирование данных

В {{ objstorage-full-name }} можно хранить очень большие объемы данных. При этом запросы к этим данным могут затрагивать не все данные, а только их часть. Если описать правила разметки структуры хранения ваших данных в {{yq-full-name}}, тогда данные, которые не нужны для запроса можно даже не считывать из {{ objstorage-full-name }}. Это значительно ускоряет выполнение запросов без потери точности результатов. 

Например, данные хранятся в следующей структуре каталогов, где:

```
year=2021
    month=01
    month=02
    month=03
year=2022
    month=01
```

Запрос ниже явно подразумевает, что обработать нужно только данные за февраль 2021-го года и другие данные не нужны. 

```sql
SELECT 
    * 
FROM 
    objectstorage.'/' 
    WITH
    (
        Schema =
        (
            data String, 
            year Int, 
            month Int
        )
    ) 
WHERE 
    year=2021 
    AND month=02
```

Если схема партиционирования данных не указана, то из {{ objstorage-full-name }} будут считаны _все_ хранимые данные, но в результате обработки данные за все другие даты будут отброшены. 

Если описать структуру хранения явно, указав, что данные в {{ objstorage-full-name }} размещены в каталогах по годам и месяцам
```sql
SELECT 
    * 
FROM 
    objectstorage.'/' 
    WITH
    (
        Schema =
        (
            data String, 
            year Int, 
            month Int
        ),
        partitioned_by = 
        (
            year,
            month
        )
    ) 
WHERE 
    year=2021 
    AND month=02
```

то в процессе исполнения запроса из {{ objstorage-full-name }} будут считаны не все данные, а только данные за февраль 2021-го года, что существенно сократит объем данных и ускорит обработку, при этом результаты обоих запросов будут идентичны.

{% note info %}

В примере выше показана работа с данными на уровне [подключений](glossary.md#connection). Такой пример выбран только для иллюстративных целей. Мы настоятельно рекомендуем для работы с данными использовать "привязки к данным" и не использовать прямую работу с подключениями.

{% endnote %}

## Синтаксис { #syntax }

При работе на уровне подключений партиционирование задается с помощью параметра `partitioned_by`. 

```sql
SELECT 
    * 
FROM 
    <connection>.<path> 
WITH 
(
    schema=(<field1>, <field2>, <field3>), 
    partitioned_by=(field2, field3)
)
```


В параметре `partitioned_by` перечисляются колонки схемы данных, по которым партиционированы хранимые в {{ objstorage-full-name }} данные. Порядок указания полей в параметре partitioned_by определяет вложенность каталогов {{objstorage-full-name}} друг в друга. 

Например, `partitioned_by=(year, month)` определяет структуру каталогов

```
year=2021
    month=01
    month=02
    month=03
year=2022
    month=01
```

А `partitioned_by=(month, year)` определяет другую структуру каталогов

```
month=01
    year=2021
    year=2022    
month=02
    year=2021
month=03
    year=2021
```

## Поддерживаемые типы данных

Партиционирование возможно только по следующему набору типов данных YQL:
- Uint16, Uint32, Uint64
- Int16, Int32, Int64
- String
- Bool

При использовании других типов для указания партиционирования возвращается ошибка.

## Поддерживаемые форматы путей хранения

Формат путей хранения, когда в имени каждого каталога явно указано название колонки, называется "[Hive-Metastore форматом](https://en.wikipedia.org/wiki/Apache_Hive)" или просто "Hive-форматом".

Такой формат выглядит следующим образом:
```
month=01
    year=2021
    year=2022    
month=02
    year=2021
month=03
    year=2021
```

{% note warning %}

Базовый режим партиционирования в {{yq-full-name}} поддерживает только Hive-формат. 

{% endnote %}

Для указания произвольных путей хранения необходимо воспользоваться режимом [Расширенного партиционирования данных](partition-projection.md).