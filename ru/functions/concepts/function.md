# Функция

_Функция_ позволяет вам размещать код в {{ yandex-cloud }}, который можно запускать по запросу или триггеру.

Возможные статусы функции:

* `Creating` — функция создана, идут фоновые процессы по ее инициализации.
* `Active` — функция успешно создана и готова к использованию.
* `Deleting` — функция и все связанные с ней ресурсы удаляются. Функция еще существует, но уже недоступна для использования.
* `Error` — произошла ошибка при создании функции. Функция существует, но не может быть использована.

Сразу после создания функция содержит только метаинформацию о себе: имя, описание, уникальный идентификатор и т. д. Для начала работы с функцией необходимо [создать версию функции](../operations/function/version-manage.md). Выполнить функцию можно с помощью HTTPS API или CLI.

Перед написанием функции, ознакомьтесь с [моделью программирования](#programming-model).

## Версия функции {#version}

_Версия_ содержит код функции, параметры запуска и все необходимые зависимости. Вы можете работать с разными версиями одной функции на разных стадиях процесса разработки, например версия в разработке, альфа-версия, бета-версия. При внесении каких-либо изменений всегда создается новая версия с [тегом](#tag) по умолчанию — `$latest`, при этом не имеет значения, загрузили вы совершенно новый код или внесли только незначительные правки. Версию с тегом `$latest` нельзя удалить.

Возможные статусы версии функции:

* `Creating` — версия функции создана, идут фоновые процессы по ее инициализации.
* `Active` — версия функции успешно создана и готова к использованию.
* `Obsolete` — версия функции устарела и скоро будет удалена из-за длительного отсутствия тегов. Чтобы вернуть ее в статус `Active`, нужно [добавить тег](../operations/function/tag-add.md).
* `Deleting` — версия функции удаляется. Она еще существует, но уже недоступна для использования.

### Формат загрузки кода {#upload}

Для [создания версии](../operations/function/version-manage.md) вы можете воспользоваться редактором кода или загрузить код и необходимые зависимости, используя один из форматов, описанных в таблице ниже. После создания функции объект с кодом больше не нужен. Его можно удалить из хранилища.

| Формат | Консоль управления | {{ yandex-cloud }} CLI |
|----|----|----|
|ZIP-архив с вашего ПК| ![image](../../_assets/common/yes.svg) | ![image](../../_assets/common/yes.svg) |
|ZIP-архив из [S3](../../glossary/s3.md) с указанием бакета и объекта| ![image](../../_assets/common/yes.svg) | ![image](../../_assets/common/yes.svg) |
|Директория| ![image](../../_assets/common/no.svg) | ![image](../../_assets/common/yes.svg) |
|Файл| ![image](../../_assets/common/no.svg) | ![image](../../_assets/common/yes.svg) |

{% include [upload-limits](../../_includes/functions/upload-limits.md) %}

Подробнее о том, как создать версию, читайте в разделе [{#T}](../operations/function/version-manage.md).

### Тег версии {#tag}

Теги используются для вызова определенной версии функции. Каждый тег должен быть уникален в рамках функции. У одной версии может быть несколько тегов.

{% note info %}

При создании новой версии ей присваивается тег по умолчанию — `$latest`. Тег `$latest` нельзя удалить.

{% endnote %}

## Экземпляр функции {#function-instance}

Экземпляр функции — это виртуальная машина, на которой:

* загружена операционная система;
* запущен bootstrap-процесс;
* проинициализированы компоненты среды выполнения {{ sf-name }};
* загружен и проинициализирован код функции {{ sf-name }}.

{{ sf-name }} динамически управляет жизненным циклом виртуальных машин на основе внутренних правил. Эти правила могут меняться в связи с развитием сервиса.

### Создание экземпляра {#instance-creating}

При вызове функции происходит одно из двух событий:

* для обработки вызова запускается новый экземпляр функции;
* вызов перенаправляется в уже запущенный экземпляр функции — экземпляр, не завершившийся после обработки предыдущих вызовов или созданный сервисом в фоновом режиме до получения пользовательского запроса.

Принимая решение о запуске нового экземпляра, {{ sf-name }} учитывает:

* нагрузку на уже запущенные экземпляры;
* количество вызовов, которые ожидают обработки;
* [настройки масштабирования](#scaling) функции;
* использование [квот](limits.md#functions-quotas).

#### Процесс запуска экземпляра {#starting-process}

1. {{ sf-name }} выбирает узел сервисного кластера, учитывая наличие ресурсов (CPU, RAM, сеть), загруженных образов пользовательского кода и другие характеристики, влияющие на длительность запуска экземпляра. Приоритет отдается узлу, который обеспечит минимальную длительность запуска. При этом время запуска может варьироваться: например, оно будет меньше, если узел закешировал пользовательский код с предыдущего вызова.
1. На выбранном узле кластера запускается виртуальная машина, для которой настраиваются сетевые интерфейсы, выделяются ресурсы CPU и RAM, подключаются образы дисков, содержащие операционную систему, среду выполнения и пользовательский код.
1. Виртуальная машина запускает ядро Linux и стартовый процесс bootstrap.
1. После инициализации bootstrap-процесс запускает [среду выполнения](runtime/index.md), которая указана в настройках вызываемой функции.

### Работа экземпляра {#instance-work}

После того как экземпляр создан, он может обрабатывать вызовы. Вызовы, переданные экземпляру, попадают в очередь, откуда поступают на выполнение. Результат обработки вызова передается вызывающей стороне. Когда вызовы заканчиваются, экземпляр остается в оперативной памяти в течение переменного времени, которое зависит, например, от таймаута выполнения функции.

### Приостановка экземпляра {#instance-suspending}

Если в течение некоторого времени в созданный экземпляр не поступают новые вызовы, он приостанавливается. Операционная система и запущенные процессы остаются в оперативной памяти, но не обрабатываются процессором. Экземпляр возобновляет работу в следующих случаях:

* при поступлении нового вызова;
* при запуске служебного цикла возобновления работы экземпляров, например для обновления таймеров или выполнения служебных задач гостевой операционной системы;
* перед [завершением экземпляра](#instance-termination).

{% note info %}

Когда экземпляр приостановлен, он не потребляет ресурсы CPU, поэтому сетевые соединения могут быть разорваны. Пользовательский код должен корректно обрабатывать такие случаи.

{% endnote %}

### Завершение экземпляра {#instance-termination}

{{ sf-name }} принимает решение о завершении запущенного экземпляра на основе набора факторов, например:

* длительное время отсутствуют новые вызовы;
* произошел таймаут выполнения функции;
* произошла ошибка выполнения, которую нельзя исправить.

В некоторых случаях сервис может [принудительно остановить](long-lived-functions.md#possible-termination) экземпляр функции. Тогда в пользовательский код функции поступит [уведомление](termination-notifications.md) о предстоящем принудительном завершении работы.

## Модель программирования {#programming-model}

{{ sf-name }} поддерживает разные языки программирования. Вне зависимости от выбранного вами языка, при написании кода необходимо опираться на принятую в сервисе модель программирования. В ней есть как элементы, которые необходимо реализовать пользователю, так и механизмы, которые уже реализованы на стороне сервиса и могут быть использованы по необходимости.

### Описание модели {#model-desc}

Чтобы функция запустилась, опишите в ней _обработчик_. Он определяется при написании кода и обрабатывает поступающие данные, вызывая необходимые функции и методы в коде. Обработчик должен принимать данные, которые приходят с запросами функции, и контекст, который передает {{ sf-name }}. Для некоторых [сред выполнения](runtime/index.md) есть требования к абсолютному пути к файлу, в котором находится обработчик:

* Python, Go, Java — не должен содержать символ `.` в названии файла до расширения, например `.handler.py`.
* .NET Core — не должен содержать символ `.` в названии файла до расширения и начале названия директории, в которой находится файл с обработчиком, например `.handler.cs` или `.test/handler.cs`.

_Контекст_ обеспечивает взаимодействие кода вашей функции с {{ sf-name }}. Например, с его помощью функция может узнать, сколько времени осталось до момента, когда {{ sf-name }} завершит ее выполнение.

Поступающие запросы обрабатываются функцией по одному. Чтобы функция обрабатывала несколько запросов сразу, используйте возможности _асинхронного выполнения кода_, которые предоставляет [среда выполнения](runtime/index.md).

Чтобы сообщить сервису об ошибке при выполнении функции, обрабатывайте ошибки с помощью _исключений_.

Выполнение функции _журналируется_ сервисом, но при необходимости вы можете реализовать в коде вашей функции дополнительное ведение журналов.

### Масштабирование функции {#scaling}

Экземпляр функции обрабатывает один ее вызов в один момент времени. Если функция вызывается быстрее, чем экземпляр успевает обработать запрос, сервис масштабирует функцию — запускает ее дополнительные экземпляры. Таким образом обеспечивается _параллельная обработка запросов_.

Чтобы уменьшить количество холодных стартов, {{ sf-name }} создает экземпляры функции в фоновом режиме, не для обработки пользовательских запросов. При этом количество экземпляров, созданных таким образом, не превышает [квоты](limits.md#functions-quotas).

Кроме этого, в {{ sf-name }} можно задать:

{% include [scaling](../../_includes/functions/scaling.md) %}

{% note info %}

Вызовы распределяются по зонам доступности случайным образом. {{ sf-name }} не гарантирует равномерное распределение вызовов по зонам. Например, все вызовы вне зависимости от их количества могут попасть в одну зону.

{% endnote %}

{% include [provisioned-instances-time](../../_includes/functions/provisioned-instances-time.md) %}

#### Одновременные вызовы экземпляра функции {#concurrency}

Чтобы один экземпляр функции в один момент времени мог обрабатывать несколько ее вызовов, можно задать параметр `concurrency` при создании версии функции. Идентификаторы таких вызовов (`RequestID`) должны быть уникальными, иначе при попытке обработать вызов с повторяющимся идентификатором будет возвращаться ошибка.

Если хотя бы один вызов достигнет таймаута, он и все остальные вызовы, которые обрабатываются тем же экземпляром функции, завершатся. Подробнее о таймауте см. [{#T}](limits.md#functions-limits).

Параметр `concurrency` доступен для функций со следующими [средами выполнения](runtime/index.md):

* [Node.js](../lang/nodejs/index.md)
* [Go](../lang/golang/index.md)
* [Java](../lang/java/index.md)
* [Bash](../lang/bash/index.md)
* [Kotlin](../lang/kotlin/index.md)

#### Лимиты {#limits}

Когда количество экземпляров функции достигает значения `zone_instances_limit`, {{ sf-name }} перестает ее масштабировать. Если вызовов функции больше, чем могут обработать экземпляры, вызов становится в очередь, но при этом считается выполняемым. Когда количество выполняемых вызовов достигает значения `zone_requests_limit`, сервис перестает ставить вызовы в очередь и возвращает ошибку `429 TooManyRequests`.

#### Подготовленные экземпляры {#provisioned-instances}

_Подготовленный экземпляр_ — это экземпляр функции, при запуске которого гарантированно нет холодного старта. В подготовленном экземпляре до вызова функции:
* запускается интерпретатор;
* инициализируются компоненты среды выполнения {{ sf-name }};
* загружается и инициализируется пользовательский код.

Процессы инициализации и работы простого и подготовленного экземпляров функции не отличаются. Подготовленный экземпляр приостановлен и не потребляет CPU до тех пор, пока не начнет обрабатывать вызов.

{% include [provisioned-instances-price](../../_includes/functions/provisioned-instances-price.md) %}

Если количество вызовов функции превышает количество, которое могут обработать подготовленные экземпляры, {{ sf-name }} масштабирует функцию в пределах [квот](limits.md#functions-quotas). Новые вызовы могут быть обработаны как подготовленным экземпляром, так и обычным — в зависимости от того, какой освободится или создастся раньше.

Подготовленные экземпляры расходуют следующие [квоты](limits.md), даже если не запущены:
* Количество экземпляров функций в каждой зоне доступности.
* Суммарный объем RAM для всех запущенных функций в каждой зоне доступности.
* Количество подготовленных экземпляров функций в одном облаке.

## Примеры использования {#examples}

* [{#T}](../tutorials/api-gw-integration.md)
* [{#T}](../tutorials/batch-code-execution.md)
* [{#T}](../tutorials/canary-release.md)
* [{#T}](../tutorials/events-from-postbox-to-yds.md)
* [{#T}](../tutorials/functions-framework-to-container.md)
* [{#T}](../tutorials/monitoring.md)
* [{#T}](../tutorials/nodejs-cron-restart-vm.md)

#### См. также

* [Создать версию функции](../operations/function/version-manage.md)
* [Добавить настройки масштабирования](../operations/function/scaling-settings-add.md)
