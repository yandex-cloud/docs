---
title: Шардирование в {{ mch-full-name }}
description: Из статьи вы узнаете, что такое шардирование, его преимущества, примеры использования и особенности управления шардированием в {{ mch-name }}.
---

# Шардирование в {{ mch-name }}

[_Шардирование_](../../glossary/sharding.md) — это стратегия горизонтального масштабирования кластера, при которой части одной базы данных {{ CH }} размещаются на разных шардах. _Шард_ состоит из одного или нескольких [хостов-реплик](replication.md). Запрос на запись или чтение в шард может быть отправлен на любую его реплику, выделенного мастера нет. При вставке данных они будут скопированы с реплики, на которой был выполнен `INSERT`-запрос, на другие реплики шарда в асинхронном режиме.

## Преимущества шардирования {#advantages}

Шардирование обычно используется в следующих случаях:
- Ожидаются высокая частота запросов к базе данных и быстрый рост количества данных.
- Приложение требует все больше и больше ресурсов, но решение, использующее кластер с [репликацией](replication.md), больше не может быть отмасштабировано с использованием вертикальной стратегии (путем наращивания вычислительной мощности хостов кластера: дисков, памяти и процессоров).

Шардирование может помочь:
- Преодолеть технические ограничения. {#restrictions}

  Потребность работать с большими наборами данными может привести к тому, что инфраструктура хранения данных будет функционировать на пределе возможностей оборудования, доступного на рынке (например, дисковая подсистема будет показывать неудовлетворительные метрики по IOPS). Если приложению приходится работать близко к потолку возможностей оборудования, имеет смысл распределить данные по шардам. В этом случае операции чтения будут выполняться параллельно.

- Повысить отказоустойчивость. {#high-availability}

  Шардирование позволяет изолировать отказы отдельных хостов или наборов реплик. Без шардирования отказ отдельного хоста или набора реплик могут привести к потере доступа ко всем данным, которые они содержат. А отказ, например, одного шарда из пяти оставляет доступными 80% данных таблицы.

- Повысить скорость выполнения запросов. {#processing-speed}

  Запросы конкурируют с друг другом за вычислительные ресурсы хостов кластера, что может приводить к снижению скорости обработки запросов. Такое снижение скорости обычно проявляется при росте количества операций чтения или затрат процессорного времени на обработку таких операций. В шардированном кластере, где запросы к одной и той же таблице могут выполняться параллельно, устраняется конкуренция за общие ресурсы, что позволяет сократить время обработки запроса.

## Использование шардирования {#uses}

Чтобы распределить данные по шардам, нужно создать _распределенную таблицу_ на [движке Distributed]({{ ch.docs }}/engines/table-engines/special/distributed/), использующую эти шарды. Часть данных в такой таблице будет храниться на одном шарде, часть — на других шардах. Фактически, части данных хранятся в нижележащих таблицах, которые находятся на хостах каждого шарда, распределенная таблица лишь обеспечивает маршрутизацию запросов к этим таблицам.

Чтобы определить, на какой шард поместить данные при выполнении запроса `INSERT`, {{ CH }} использует _ключ шардирования_ — в зависимости от его значения запрос будет направлен к тому или иному шарду. Ключ шардирования схож с [ключом партиционирования]({{ ch.docs }}/engines/table-engines/mergetree-family/custom-partitioning-key/). Удобство в работе и фактическое улучшение производительности при использовании шардирования сильно зависят от выбора ключа шардирования: ключ должен быть выбран так, чтобы данные были логично распределены по шардам и при этом данные разных шардов не были связаны между собой. В отличие от запросов `INSERT`, запросы `SELECT` отправляют подзапросы на все шарды кластера, вне зависимости от того, каким образом данные распределены по шардам.

{{ CH }} предлагает два разных подхода для работы с распределенными таблицами, обеспечивая возможность гибкого распределения данных в кластере:
- Можно создать распределенную таблицу, которая использует [_все шарды_](../operations/shards.md) кластера ([пример](../tutorials/sharding.md#shard-example)).
- Можно создать распределенную таблицу, которая использует [_группу шардов_](../operations/shard-groups.md) кластера ([пример](../tutorials/sharding.md#shard-groups-example), [продвинутый пример](../tutorials/sharding.md#shard-groups-advanced-example)). Такая группа включает в себя только часть шардов кластера.

  При этом допустимо:
  - Разместить таблицы с данными на тех же шардах кластера, которые используются распределенной таблицей.
  - Разместить таблицы с данными на одной группе шардов, а распределенную таблицу, которая маршрутизирует запросы к этим таблицам с данными, — на другой группе шардов.

Например, можно настроить следующую конфигурацию шардов в рамках одного кластера {{ CH }}, используя эти подходы:
- Группа `A` из двух шардов с хостами [класса](instance-types.md) `s2.small`: используется в качестве основы для распределенной таблицы, нагрузка на которую невелика. Данные распределенной таблицы хранятся в этой же группе шардов.
- Группа `B` из двух шардов с хостами класса `s2.medium`: используется в качестве основы для распределенной таблицы, нагрузка на которую постоянна и велика. Данные распределенной таблицы хранятся в другой группе `C` из пяти шардов с высокопроизводительными хостами класса `m2.large`.

Подробнее о работе с распределенными таблицами см. в [документации {{ CH }}]({{ ch.docs }}/engines/table-engines/special/distributed/).

## Особенности управления шардированием в {{ mch-name }} {#shard-management}

{{ mch-name }} управляет шардами следующим образом:
- При [создании кластера](../operations/cluster-create.md) в него автоматически добавляется один шард `shard1`. Этот шард включает все хосты кластера. При создании кластера из нескольких хостов автоматически включается поддержка [репликации](./replication.md).

- В существующий кластер можно [добавить](../operations/shards.md#add-shard) нужное количество шардов.

  Для того, чтобы полноценно [воспользоваться](#uses) всеми [преимуществами шардирования](#advantages), в кластере должно быть два и более шарда. Использование распределенной таблицы и одного шарда эквивалентно использованию репликации без шардирования и позволяет защититься только от потери данных при выходе из строя одного или нескольких хостов-реплик шарда, не обеспечивая распределенного хранения данных.

- В шард можно [добавить хосты](../operations/hosts.md#add-host).

    Шарды из нескольких хостов требуют работающей репликации. Поэтому:

    * В кластерах, где есть шард из нескольких хостов, механизмы репликации {{ CK }} или {{ ZK }} уже работают, и можно сразу добавлять хосты в шард.
    * В кластерах с шардами из одного хоста нужно [добавить не менее трех хостов {{ ZK }}](../operations/zk-hosts.md#add-zk), и только потом добавлять хосты в шард.

    Подробнее о репликации, {{ CK }} и {{ ZK }} см. в разделе [Репликация](replication.md).

- Идентификаторы шардов в {{ yandex-cloud }} отличаются от их идентификаторов в {{ CH }}:

    * В кластере {{ mch-name }} используются имена шардов.
    * В {{ CH }} используются числовые идентификаторы, которые соответствуют лексикографическому порядку имен шардов в {{ mch-name }} (например, `A-shard`, `B-shard`, `shard10`, `shard100`).

    Учитывайте это, если ваше приложение обращается к шардам по их идентификаторам при записи и чтении данных распределенной таблицы.

    Чтобы узнать, как идентификаторы {{ yandex-cloud }} и {{ CH }} соответствуют друг другу, используйте запрос:

    ```sql
    SELECT
     substitution AS shard_name,
     shardNum() AS shard_number
    FROM cluster('{cluster}', system.macros)
    WHERE macro = 'shard'
    ORDER BY shard_name
    ```

    Например, в кластере с шардами `shard1`, `shard2`, `shard3`, `shard4`, `shard100` соответствие будет выглядеть так:

    ```text
    ┌─shard_name─┬─shard_number─┐
    │ shard1     │            1 │
    └────────────┴──────────────┘
    ┌─shard_name─┬─shard_number─┐
    │ shard100   │            2 │
    └────────────┴──────────────┘
    ┌─shard_name─┬─shard_number─┐
    │ shard2     │            3 │
    └────────────┴──────────────┘
    ┌─shard_name─┬─shard_number─┐
    │ shard3     │            4 │
    └────────────┴──────────────┘
    ┌─shard_name─┬─shard_number─┐
    │ shard4     │            5 │
    └────────────┴──────────────┘
    ```

{% include [clickhouse-disclaimer](../../_includes/clickhouse-disclaimer.md) %}
