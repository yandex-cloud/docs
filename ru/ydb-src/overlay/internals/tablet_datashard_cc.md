### Решаемая задача

Модель транзакций MiniKQL (реализуемая в DataShard-е) сама по себе не позволяет выполнять ряд операций над данными транзакционно. Существует способ ослабить ограничения на MiniKQL-транзакции, выполняя их с контролем выполнения (concurrency control). Реализовано решение, позволяющее транзакционно выполнять список MiniKQL-транзакций, из которых только последняя может быть модицифирующей (остальные - читающие).

### Реализация

Реализованы оптимистичные локи по ключу:

* [Lock (database)](https://en.wikipedia.org/wiki/Lock_(database))
* [Optimistic lock](https://en.wikipedia.org/wiki/Optimistic_concurrency_control)
* [Index locking](https://en.wikipedia.org/wiki/Index_locking)

Первая MiniKQL-транзакция из многошаговой транзакции задает уникальный LockTxID, который выставляется равным ее TxID (cм TxProxy).
Все MiniKQL-транзакции, кроме последней, используют LockTxID для привязки своих локов. Последняя транзакция не выставляет локов, т.к. ее транзакционное выполнения гарантируется и так. Последняя транзакция проверяет актуальность локов и либо фиксирует изменения, либо их откатывает. Если последняя транзакция немодифицирующая, результат проверки лока означает успех или неуспех чтения.

Локи выставляются автоматически на ключи, по которым многошаговые транзакции производили чтения.
Локи инвалидируются автоматически, если по этим ключам (после установки лока) были записи или удаления (не важно, из многошаговых или обычных транзакций).
Лок представляет из себя набор целочисленных полей: {LockTxID, DataShardId, Generation, Counter}.
Транзакция запрашивает установку локов вызовом MiniKQL-функции AcquireLocks(Uint64 lockTxId). Установленные локи возвращаются как результат этой функции.
Последняя транзакция проверяет наличие всех установленных локов средствами MiniKQL. Для этого производится чтение из служебной таблицы /sys/locks по ключу {LockTxID, DataShardId}. Лок считается валидным, если из таблицы /sys/locks удалось прочитать полный перечень локов, и при этом значения их служебных полей (Generation, Counter) совпадают с исходными (полученными при установке).

Локи "волатильны", не сохраняются при перезапуске таблеток. Падение DataShard-а приводит к инвалидации всех локов этого DataShard-а и последующему откату соответствующих транзакций. Поля Generation и Counter служат для обеспечения этой гарантии.

Хороший клиент должен производить очистку своих локов вызовом erase на таблице /sys/locks.
Существует ограничение на одновременное число локов на DataShard-е с целью ограничить их влияние на скорость выполнения и используемую память (сейчас 16*1024 локов на шард). Если лимит локов превышен, новый лок поставить не удастся. Если клиент не очистил локи, они будут постепенно вытеснены новыми (по мере необходимости). Гарантируется невытеснение лока втечении таймаута (сейчас 5 минут). При этом, на ненагруженной системе возможно выполнений и более длительных транзакций.

#### Особенности реализации 

MiniKQL позволяет читать данные по ключу (точечно) и диапазону ключей (range reads). Изменения и удаления возможны только точечно. Текущая релазиция разделяет точечтные и рэнжовые локи. Установка, проверка и снаятие рэнжовых локов дороже, чем точечных.

MiniKQL позволяет использовать составные ключи. Локи по ключам, которые начинаются с простых типов, в общем случае будут работать быстрее, чем локи на том же наборе колонок, ключ которых начинается, например, со строк.

Если лок инвалидирован, нельзя сказать как он будет представлен в таблице /sys/locks. Он может как отсутствовать, так и присутствовать с неверными {Generation, Counter}. В процессе "жизни" DataShard-а инвалидированый лок может как пропасть из /sys/locks так и появитсья снова (в невалидном виде).

DataShard проверяет отсутствие модификаций в транзакциии, запросившей установку лока. Если у транзакции одновременно пристутсвует и запрос локов и модификация данных, такая транзакция абортится. Для последнего шага многошаговой транзакции исключения не делается. Она не должна вызывать функцию AcquireLocks.

#### Тесты 

[Тест изоляции транзакций SmallBank](tablet_datashard_smallbank.md)