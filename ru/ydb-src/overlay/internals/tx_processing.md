Одной из важнейших особенностей дизайна - является эффективное выполнение распределённых транзакций, с правильным (serializable) уровнем изоляции. Слой транзакций строится поверх слоя таблеток, одним из видов которых становится Datashard. Отображая фрагмент адресного пространства Datashard и является единицей гранулярности, между которыми и производится выполнение транзакции (с очевидной оптимизацией важного частного случая - если транзакция затрагивает только один даташард - то выполнение в локальном режиме, без прокручивания машинерии распределённой транзакции).

Что важно - выстраивая слой транзакционности над уровнем таблеток - мы можем строить алгоритмы в предположении надёжности участников.

### Рассматриваемая модель 

Непосредственно в KiKiMR, без дополнительных приседаний, выполняется ограниченный класс транзакций, которые:

  * Могут быть описаны запросом и не требуют взаимодействия с внешним миром (другими словами - вся нужная информация есть внутри системы)
  * read-write наборы могут быть вычислены по запросу, без хождения к данным. Возможно спекулятивно, но с разумным охватом.
  * выполнение запроса на известном наборе данных детерминировано.

Значительная часть пользовательских OLTP запросов является именно такими или может быть сведена к таким небольшой кровью. Значительная часть оставшихся - хорошо работает в режиме оптимистичного выполнения (читаем-читаем-читаем, вычисляем, и пишем в базу если исходные данные не протухли). Для оставшихся - можно нагородить 2PC.

### Обработка транзакций 

Точкой входа в транзакционную обработку является Транзакционная Прокси, именно здесь каждой транзакции в момент начала обработки назначается уникальный номер (aka txid, ui64 состоящий из порядкового номера прокси и ведущегося проксёй счётчика).

  1. Для каждой транзакции выполняется вычисление read-write наборов, определяется набор затронутых шардов и исходный запрос разрезается на фрагменты - каждому шарду по своему фрагменту. И получившиеся фрагменты рассылаются на шарды.
  2. После получения подтверждения от всех участников о надёжном сохранении фрагмента - прокси выбирает один из присутствующих в системе координаторов и передаёт на него список задействованных в транзакции шардов.
  3. Координатор, получив для планирования описание транзакции (фактически txid, список участников и указание на момент времени, до которого шарды обещают хранить и не выбрасывать сохранённые фрагменты программы) назначает шаг выполнения (фактически - назначает момент выполнения транзакции). Разные координаторы работают независимо и неинформированы о существовании соседей, поэтому важно для каждой транзакции выбрать ровно один координатор. На выходе имеем пару stepid:txid - по которой и происходит глобальное упорядочивание транзакций.
  4. Координатор гарантирует что запланировав шаг - более никогда не запланирует ни этот шаг, ни какой-либо из предшествующих. Для выполнения этой гарантии - надёжно сохраняем план шага.
  5. После надёжного сохранения шага - для каждого шага для каждой транзакции разделяем описание транзакций по существующим в системе медиатором и рассылаем каждому медиатору описание шага.
  6. Каждый из медиаторов дожидается планирования шага всеми координаторами, и убедившись что видит полную картину для шага - группирует транзакции по шардам и рассылает план шага каждому из шардов.
  7. Шард, получив план - выполняет транзакции последовательно, в едином для всех шардов порядке (помним про упорядоченность по stepid:txid).
  8. Шарды, входящие в read-набор - вычитывают запрошенные данные и отправляют их на шарды из write-набора. Если шард входит только в read-набор - то для этого шарда выполнение транзакции завершается и переходит к выполнения следующей запланированной транзакции либо, при отсутствии таковых - к ожиданию следующего плана.
  9. Шарды, входящие в write-набор - дожидаются прихода данных с шардов read-набора. Теперь, обладая всем набором входных данных - детерминировано выполняют транзакцию и выясняют выходной набор данных, часть которого, принадлежащую текущему шарду - записывает в базу.

Прогресс read-шага на таблетках не зависит ни от каких других таблеток, каждая из них выполняет шаг независимо. Прогресс write-таблеток зависит только от read-таблеток и не требует синхронизации между собой - выполняя детерминированный запрос на одних и тех же данных - все участники получат один и тот же результат (в частности: примут консистентное решение о коммите или откате транзакции).

Важные оптимизации:

  1. Если транзакция только читает и только с одного шарда - её можно выполнить непосредственно на фазе подготовки, не сохраняя фрагмент программы и не прокручивая машинерию планирования.
  2. Если клиента устраивает неконсистентный срез (например на подготовительной фазе оптимистичной транзакции) - то на подготовке можно выполнить и многошардовые чтения.
  3. Если клиенту не важен конкретный глобальный stepid:txid транзакции (обычно - не важен) - то и пишущие одношардовые транзакции можно выполнять на фазе подготовки.

#### Очистка временных данных

Сохранённые на пункте 2 фрагменты транзакции удаляются либо вместе (одновременно, в той же внутренней операции) с окончанием обработки транзакции. Либо, для "потерянных" транзакций (которые не были запланированы по какой-либо причине) - удаляются шардами по наступлению момента времени, до которого шард обещал хранить фрагмент программы в соответствии с настройками.

### Взгляд пользователя 

Пользователю можно рассказать о двух "моментах успешности"

  1. Когда транзакция успешно запланирована и точно будет выполнена, но фактический момент мы еще не знаем (т.е. транзакция запланирована, мы знаем её stepid:txid - но непосредственного выполнения еще не дождались).
  2. Когда транзакция выполнилась, произвела изменения и сгенерировала результаты.

У системы как целого существует "период неопределённости" - когда состояние системы уже полностью определено (все мутации приняты, точно будут выполнены и известно в каком порядке), но нет возможности выяснить какой именно пока транзакции не будут обработаны.

### Соотношение с классическими схемами 

Можно утверждать что реализованная схема никогда не хуже чем классического подхода с 2PC на блокировках (хотя бы потому как 2PC можно без потерь выразить в виде нескольких внутренних транзакций), но в некоторых важных случаях имеет плюсы.

  1. Появляется возможность потоковой обработки, колоссальный выигрыш для задач вида "транзакционно примени инкрементальное обновление".
  2. Меньшая длительность удержания локов (нулевая для read-таблеток).