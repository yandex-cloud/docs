Хотя пользовательский код таблетки можно писать в терминах сырых записей лог, в целом это - крайне неудобно, ведёт к дублирования нетривиального кода и вообще - ересь =).

Для написания пользовательского кода таблеток предлагается использование примитива локальной базы, предоставляемого библиотекой локального экзекьютора. С точки зрения организации кода - это дополнительный актор (живущий на том же мейлбоксе, что и пользовательский актор таблетки), который прячет за собой взаимодействие с логом таблетки, выставляя для пользовательской таблетки локальную базу как набор табличек и интерфейс выполнения локальных транзакций.

#### Локальная транзакция 

Пользовательский код в процессе работы создаёт и отдает локальному экзекьютору на выполнение объекты-наследники ITransactionBase, у которого пользователь переопределяет операции

  * Execute - непосредственно само тело транзакции, которому подаётся мгновенное состояние локальной базы, над которым можно производить чтение, операции модификации схемы и данных в табличках. Фактические изменения применяются только при успешном завершении транзакции. Наблюдаемый порядок операций:
    * Все чтения.
    * Все модификации схемы.
    * Все апдейты.
  
  * Complete - хотя модификации транзакции применяются атомарно в момент завершения Execute фазы транзакции, надёжно сохраненными они могут считаться только после коммита соответствующей записи лога на надёжное хранилище (в нашем случае - блобосторадж). Complete как раз и вызывается когда успешно закоммичены сама транзакция и все от кого она зависит (поэтому откладываться подтверждение может не только модифицирующих транзакций, но и читающих - если на момент её выполнения есть незакоммиченные пишущие транзакции, от которых зависит читающая).

Таблетка поддерживает состояние в памяти и кеш блоков, в случае недоступности запрошенных транзакцией блоков - инициируется их загрузка, а транзакция откладывается и будет рестартована после загрузки. Т.к. фаза исполнения всегда работает с мгновенным слепком базы - нельзя переносить результаты чтения между рестартами транзакции - к следующему запуску состояние базы может измениться!

Все операции модификации - слепые, поэтому если транзакция только пишет - она никогда не будет рестартована.

#### Локальная база 

Внутри локальная база представляет из себя набор таблиц (количество, набор столбцов - определяется схемой). Столбцы строго типизированы. Хотя на уровне интерфейса это никак не энфорсится, но реализованный вариант - каскад LSM поколений, где самое свежее поколение - забекапленная логом структура в памяти, а более старые - иммутабельные цепочки блоков.

Для каждой таблицы определён список ключевых столбов, вместе формирующих PK таблицы. Все столбцы (включая ключевые) - nullable, при этом null полагается меньшим любого значения и равным другому null (за счёт этого возможно безопасное добавление ключевых столбцов). При модификации схемы возможно добавление столбцов, для неключевых - удаление.

Таблицы формально независимы между собой, но могут атомарно модифицироваться одной локальной транзакцией.

Физическое хранение определяется настройками. Ключевые колонки при этом должны храниться вместе - в одной индексированной цепочке блоков (aka сосиске), остальные колонки могут храниться как вместе с ключевыми, так и отдельно - в соседних блоках или сосисках. Возможно поколоночное сжатие в рамках блока. Блок сосиски является и единицей кеширования.