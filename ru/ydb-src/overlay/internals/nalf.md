Полагаясь на message-passing как основу механизма асинхронной работы - KiKiMR создаёт очень большой трафик на аллокаторе, значительная часть которого - заведомо короткоживующие объекты (хендлы, ивенты, куки). На момент разработки не был известен (и сейчас в общем-то то же) аллокатор общего назначения, хорошо работающий в этих условиях. Плюс к этому качественный рост количества аппаратных потоков в процессорах сделал имеющиеся хорошие аллокаторы (см. lf-alloc) недостаточно хорошим.

Поэтому для KiKiMR был реализован кастомный аллокатор. Из особенностей

  * Режим работы (aka инкрементальный) для выделения короткоживущих объектов, с минимальной ценой аллокации (в типичном случае - несинхронизированный инкремент указателя) и предельной локальностью (все блоки, в том числе разного размера выделяются с непрерывной страницы).
  * Агрессивное thread-local кеширование блоков в основном режиме c приседаниями для выделения соседних аллокаций в одной странице памяти. И хотя сам вызов при этом становится тяжелее, чем в некоторых альтернативных решениях (больше логики - больше cpu жжётся) - окупается при последующем использовании более эффективной загрузкой TLB кеша. + возможность использования больших (2mb и 1gb) страниц.
  * Отслеживание локальности по NUMA-ноде.

Конкретный режим работы выбирается установленным хинтом (либо глобально, либо как параметр функции аллокации - последнее удобно делать через подмешивание миксина, перегружающего new/delete).

По умолчанию сосуществует с системным аллокатором (не переопределяет глобальные функции аллокации) и работает только для специально помеченных объектов (те самые короткоживущие хендлы, ивенты). К повсеместному использованию не рекомендован пока не будет завершён полный набор функциональности (читать - кеш больших аллокаций).