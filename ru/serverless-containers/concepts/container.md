---
title: Контейнер в {{ serverless-containers-full-name }}
description: Из статьи вы узнаете про контейнер, его ревизию и масштабирование.
---

# Контейнер

Контейнер позволяет запустить в {{ yandex-cloud }} приложение, которое содержится в [Docker-образе](../../container-registry/concepts/docker-image.md). После создания ревизии контейнера его можно вызвать:
* через HTTPS;
* с помощью триггера;
* с помощью расширения {{ api-gw-full-name }}.

Подробнее о [вызове контейнера](./invoke.md).

## Ревизия контейнера {#revision}

Ревизию контейнера можно создать только из Docker-образа, который загружен в [реестр](../../container-registry/concepts/registry.md) {{ container-registry-full-name }}. Другие реестры не поддерживаются. Ревизия содержит всю информацию, необходимую для запуска контейнера.

Возможные статусы ревизии:
* `Active` — активная;
* `Obsolete` — устаревшая.

При вызове контейнера запускается активная ревизия. По умолчанию это последняя ревизия, но вы можете [сделать активной](../operations/activate-revision.md) другую. Если вы создадите новую ревизию, она автоматически станет активной.

{% include [manage-revision-note](../../_includes/serverless-containers/manage-revision-note.md) %}

{% include [create-revision-note](../../_includes/serverless-containers/create-revision-note.md) %}

{% include [revision-service-account-note](../../_includes/serverless-containers/revision-service-account-note.md) %}

## Экземпляр контейнера {#container-instance}

Экземпляр контейнера — это виртуальная машина, на которой:

* загружена операционная система;
* запущен bootstrap-процесс;
* проинициализированы компоненты среды выполнения {{ serverless-containers-name }};
* загружено и проинициализировано пользовательское приложение.

{{ serverless-containers-name }} динамически управляет жизненным циклом виртуальных машин на основе внутренних правил. Эти правила могут меняться в связи с развитием сервиса.

### Создание экземпляра {#instance-creating}

При вызове контейнера происходит одно из двух событий:

* для обработки вызова запускается новый экземпляр контейнера;
* вызов перенаправляется в уже запущенный экземпляр контейнера — экземпляр, не завершившийся после обработки предыдущих вызовов или созданный сервисом в фоновом режиме до получения пользовательского запроса.

Принимая решение о запуске нового экземпляра, {{ serverless-containers-name }} учитывает:

* нагрузку на уже запущенные экземпляры;
* количество вызовов, которые ожидают обработки;
* [настройки масштабирования](#scaling) контейнера;
* использование [квот](limits.md#serverless-containers-quotas).

#### Процесс запуска экземпляра {#starting-process}

1. {{ serverless-containers-name }} выбирает узел сервисного кластера, учитывая наличие ресурсов (CPU, RAM, сеть), загруженных образов пользовательского приложения и другие характеристики, влияющие на длительность запуска экземпляра. Приоритет отдается узлу, который обеспечит минимальную длительность запуска. При этом время запуска может варьироваться: например, оно будет меньше, если узел закешировал образ пользовательского приложения с предыдущего вызова.
1. На выбранном узле кластера запускается виртуальная машина, для которой настраиваются сетевые интерфейсы, выделяются ресурсы CPU и RAM, подключаются образы дисков, содержащие операционную систему и пользовательское приложение.
1. Виртуальная машина запускает ядро Linux и стартовый процесс bootstrap.
1. После инициализации bootstrap-процесс запускает пользовательское приложение.

### Работа экземпляра {#instance-work}

После того как экземпляр создан, он может обрабатывать вызовы. Вызовы, переданные экземпляру, попадают в очередь, откуда поступают на выполнение. Результат обработки вызова передается вызывающей стороне. Когда вызовы заканчиваются, экземпляр остается в оперативной памяти в течение переменного времени, которое зависит, например, от таймаута выполнения контейнера.

### Приостановка экземпляра {#instance-suspending}

Если в течение некоторого времени в созданный экземпляр не поступают новые вызовы, он приостанавливается. Операционная система и запущенные процессы остаются в оперативной памяти, но не обрабатываются процессором. Экземпляр возобновляет работу в следующих случаях:

* при поступлении нового вызова;
* при запуске служебного цикла возобновления работы экземпляра, например для обновления таймеров или выполнения служебных задач гостевой операционной системы;
* перед [завершением экземпляра](#instance-termination).

{% note info %}

Когда экземпляр приостановлен, он не потребляет ресурсы CPU, поэтому сетевые соединения могут быть разорваны. Пользовательское приложение должно корректно обрабатывать такие случаи.

{% endnote %}

### Завершение экземпляра {#instance-termination}

{{ serverless-containers-name }} принимает решение о завершении запущенного экземпляра на основе набора факторов, например:

* длительное время отсутствуют новые вызовы;
* произошел таймаут выполнения контейнера;
* произошла ошибка выполнения, которую нельзя исправить.

В некоторых случаях сервис может [принудительно остановить](long-lived-containers.md#possible-termination) экземпляр контейнера. Тогда в пользовательское приложение поступит [уведомление](termination-notifications.md) о предстоящем принудительном завершении работы.

## Режим работы контейнера {#runtime}

{{ serverless-containers-name }} поддерживает следующие режимы работы контейнера:

Режим работы | Описание работы | Что возвращается при успешном вызове контейнера | Данные HTTP-запроса к контейнеру | Ограничения
--- | --- | --- | --- | ---
**HTTP-сервер** | HTTP-запросы к контейнеру принимает HTTP-сервер, который должен быть запущен на порту из [переменной окружения](runtime.md#environment-variables) `PORT`. Значение переменной задается сервисом автоматически | HTTP-ответ, полученный от HTTP-сервера. При передаче в контейнер некоторые HTTP-заголовки ответа [изменяются](invoke.md#filter) | Передаются в HTTP-запросе к HTTP-серверу | —
**Выполнение команд** | При каждом HTTP-запросе к контейнеру выполняются инструкции `ENTRYPOINT` из Dockerfile или команды, заданные при [создании ревизии](../operations/manage-revision.md). Если команды заданы, они переопределяют инструкции `ENTRYPOINT` из Dockerfile | Код ответа 200 и код завершения в заголовке ответа `X-Task-Exit-Code` | Находятся в файле по пути из переменной окружения `REQUEST_PATH` | Количество одновременных вызовов одного экземпляра контейнера не может быть больше 1

## Масштабирование контейнера {#scaling}

Экземпляр контейнера обрабатывает один его вызов в один момент времени. Если контейнер вызывается быстрее, чем экземпляр успевает обработать запрос, сервис масштабирует контейнер — запускает его дополнительные экземпляры. Таким образом обеспечивается _параллельная обработка запросов_.

Чтобы уменьшить количество холодных стартов, {{ serverless-containers-name }} создает экземпляры контейнера в фоновом режиме, не для обработки пользовательских запросов. При этом количество экземпляров, созданных таким образом, не превышает квоты.

Кроме этого, в {{ serverless-containers-name }} можно [изменить](../operations/manage-revision.md#create) максимальное количество одновременных вызовов одного экземпляра контейнера и [указать](../operations/scaling-settings-add.md) количество подготовленных экземпляров контейнера.

{% include [provisioned-instances-time](../../_includes/functions/provisioned-instances-time.md) %}

### Подготовленные экземпляры {#provisioned-instances}

_Подготовленный экземпляр_ — это экземпляр контейнера, при запуске которого гарантированно нет холодного старта. В подготовленном экземпляре до вызова контейнера:
* инициализируются компоненты среды выполнения {{ serverless-containers-name }};
* загружается и инициализируется пользовательское приложение.

Процессы инициализации и работы простого и подготовленного экземпляров контейнера не отличаются. Подготовленный экземпляр приостановлен и не потребляет CPU до тех пор, пока не начнет обрабатывать вызов.

{% include [provisioned-instances-price](../../_includes/serverless-containers/provisioned-instances-price.md) %}

Если количество вызовов контейнера превышает количество подготовленных экземпляров, {{ serverless-containers-name }} масштабирует контейнер в пределах [квот](limits.md#functions-quotas), но в неподготовленных экземплярах при их первом запуске происходит холодный старт.

Подготовленные экземпляры расходуют следующие [квоты](limits.md), даже если не запущены:
* Количество экземпляров контейнеров в каждой зоне доступности.
* Суммарный объем RAM для всех запущенных экземпляров контейнеров в каждой зоне доступности.	
* Количество подготовленных экземпляров контейнеров в одном облаке.

## Примеры использования {#examples}

* [{#T}](../tutorials/movies-database.md)
* [{#T}](../tutorials/pg-connect.md)
* [{#T}](../tutorials/deploy-app-container.md)
* [{#T}](../tutorials/functions-framework-to-container.md)

#### См. также

* [Создать ревизию контейнера](../operations/manage-revision.md#create)
* [Добавить настройки масштабирования](../operations/scaling-settings-add.md)

