# Вторичные индексы

## Описание задачи
В документе [Концепции - Вторичные индексы](../concepts/secondary_indexes.md) кратко описаны возможности и ограничения текущей реализации вторичных индексов. Рассмотрим, как можно использовать вторичные индексы для вывода списка сериалов, удовлетворяющих ограничению на количество просмотров

## Схема данных

<small>Листинг 1 — запрос создания таблицы ```series```</small>
```
CREATE TABLE series
(
    series_id Uint64,
    title Utf8,
    series_info Utf8,
    release_date Uint64,
    views Uint64,
    PRIMARY KEY (series_id),
    INDEX views_index GLOBAL ON (views)
);
```
Таблица ```series``` имеет ключевую колонку ```series_id```. Индекс по первичному ключу в YDB создаётся автоматически и данные хранятся отсортированными по возрастанию значений первичного ключа, поэтому выборки по такому ключу будут эффективны. Пример такой выборки — поиск всех выпусков сериала по его ```series_id``` из таблицы ```series```. Также мы создали индекс с именем ```views_indes``` к колонке ```views```, который позволит эффективно выполнять запросы используя последнюю в предикате.

В более сложных случаях можно создать несколько вторичных индексов:

<small>Листинг 2 — запрос создания таблицы с двумя индексами ```series```</small>
```
CREATE TABLE series
(
    series_id Uint64,
    title Utf8,
    series_info Utf8,
    release_date Uint64,
    views Uint64,
    PRIMARY KEY (series_id),
    INDEX views_index GLOBAL ON (views),
    INDEX date_index GLOBAL ON (release_date)
);
```
Здесь мы создали 2 вторичных индекса: к колонке views и к колонке release_date.


## Вставка данных

{% note info "Prepared queries" %}

В разделе в примерах YQL-запросов используются prepared queries. Чтобы попробовать выполнить их в YQL-редакторе, нужно определить значения параметров, объявленных в верхней части запроса с помощью оператора ```DECLARE```

{% endnote %}

<small>Листинг 3 — пример транзакции добавления данных</small>

```
DECLARE $seriesId AS Uint64;
DECLARE $title AS Utf8;
DECLARE $seriesInfo AS Utf8;
DECLARE $releaseDate AS Uint32;
DECLARE $views AS Uint64;

INSERT INTO series (series_id, title, series_info, release_date, views)
VALUES ($seriesId, $title, $seriesInfo, $releaseDate, $views);
```
Сохранить в базе новое количество просмотров для определённого сериала можно одной операцией ```UPSERT``` в таблицу  ```series```.

<small>Листинг 4 — обновление таблицы ```series```</small>

```
DECLARE $seriesId AS Uint64;
DECLARE $newViews AS Uint64;

UPSERT INTO series (series_id, views)
VALUES ($seriesId, $newViews)
```

## Выборка данных

Без использования вторичных индексов запрос на выборку записей, удовлетворяющих некоему предикату по количеству просмотров, будет работать неэффективно, так как для его выполнения YDB просканирует все строки таблицы ```series```. В текущей версии надо явно указать оптимайзеру, какой индекс использовать.

<small>Листинг 5 — запрос на выборку строк из таблицы ```series```, удовлетворяющих предикату по количеству просмотров</small>

```
SELECT series_id, title, series_info, release_date, views
FROM series view views_index
WHERE views >= someValue
```

## Изменение строк с использованием вторичного индекса

Оператор UPDATE не позволяет указать на использование вторичного индекса для поиска данных, поэтому попытка простого UPDATE ... WHERE indexed_field = $value приведет к full scan таблицы. Для того, чтобы избежать такого эффекта, можно предварительно сделать SELECT по индексу с получением значения PK, а далее выполнить UPDATE по PK, либо воспользоваться конструкцией UPDATE ON:

```
$to_update = (
    SELECT pk_field, field1 = $f1, field2 = $f2, ...
    FROM   table1 view idx_field3
    WHERE  field3 = $f3)

UPDATE table1 ON SELECT * FROM $to_update
```

## Удаление строки с использованием вторичного индекса

Для удаления строки по вторичному индексу используется комбинация SELECT c предикатом по вторичному индексу с последующим вызовом оператора DELETE ON.

<small>Листинг 6 — удаление строки с использованием вторичного индекса, удаляем все строки с нулевым количеством просмотров</small>

```
DELETE FROM ON
SELECT series_id, 
FROM series view views_index
WHERE views == 0;
```

{% note info "Накладные расходы распределённых транзакций" %}

В общем случае транзакции с использованием глобального индекса - распределённые транзакции, таким образом, они требуют больше ресурсов и занимают больше времени. В то время как точечные чтения и записи могут выполняться за время до 10 мс в 99-ом персентиле, распределённые транзакции, как правило, занимают от 20 до 500 мс. Следует отметить, что читающий запрос в ряде случаев может быть выполнен как одношардовая транзакция:
- точечное чтение по первичному ключу
- точечное чтение по индексной колонке, при условии если запрашиваемые данные представляют собой первичный ключ (или его часть)

{% endnote %}


{% note warning "Ограничения на размер ответа" %}

Полный просмотр таблицы может быть невозможен из-за внутренних ограничений: размер ответа клиенту не может превышать 50 МБ; размер данных, извлекаемых из одного шарда таблицы в одном YQL-запросе не может превышать 5 ГБ. Для больших таблиц и запросов эти ограничения могут сделать невозможным полный просмотр всех строк таблицы.

{% endnote %}
