# Работа со схемами данных YT таблиц в YQL
## Введение
YQL специализируется на работе со схематизированными таблицами. Схема данных — перечень колонок с указанием их имен и типов — указывается в метаданных (мета-атрибутах) таблиц и актуальна для всех строк таблицы.

В ходе миграции всего Яндекса к структурированному хранению информации в YT разработан стандартный способ схематизации данных — с помощью мета-атрибута `schema`. Однако исторически большинство данных на кластерах YT — логи в слабоструктурированом виде, поэтому для совместимости поддерживается еще несколько способов схематизации.

Сейчас все схемы на YT задаются с помощью указания различных мета-атрибутов и их комбинаций на таблице.

### Стандартный способ схематизации: мета-атрибуты schema и \_read\_schema
<blockquote>Мы **настоятельно рекомендуем** всем пользователям для новых данных использовать стандартный способ схематизации данных с помощью мета-атрибута `schema`.</blockquote>

Мета-атрибуты таблицы `schema` и `_read_schema` описывают, какие колонки должны присутствовать в таблице и какой тип значения ожидать в каждой колонке. В случае, когда данные в какой-либо из ячеек таблицы не соответствуют ее схеме, происходит ошибка времени выполнения.

* `schema` — системный атрибут в YT, который задает схему и на чтение, и на запись;
* `_read_schema` — пользовательский атрибут, задает базовую схему на чтение, если задан, имеет приоритет над `schema`.

Полезные ссылки:

* Подробнее см. описание атрибута [schema](#schema) ниже.
* (Схема для статической таблицы)[<https://wiki.yandex-team.ru/yt/userdoc/static_schema/]> в документации YT.
* Подробности про работу схем в YT описаны [здесь](https://wiki.yandex-team.ru//yt/design/schema).
* Типы, поддерживаемые в YT и доступные для `schema` и `_read_schema`, описаны [здесь](/yt/userdoc/yson/).
* О схематизации данных в общей квоте logfeller //logs читайте [здесь](https://wiki.yandex-team.ru/logfeller/schema/yt/).


### Альтернативная схема для таблицы — VIEW и UDF
В ряде случаев помимо основной схемы для таблицы удобно опредилить иметь одну или несколько дополнительных схем, которые чем-то отличаются от основной. Например, схемы, адаптированные под типичные паттерны использования или с дополнительной рекомендуемой пред- или постобработкой.

Для решения этой задачи можно:

1. Задать представление данных (VIEW), указав его в мета-атрибуте `_yql_view_$viewname`.
2. Написать UDF-конвертер для преобразования данных и указать его в мета-атрибуте `_yql_read_udf`. Такой конвертер работает поверх представлений, указанных в `_read_schema/schema`, и если он задан, вызывается по умолчанию, прозрачно для пользователя.


### Способы схематизации, поддерживаемые для совместимости
<blockquote>Все перечисленные в этом разделе способы <strong>не рекомендуются</strong> к использованию и поддерживаются для совместимости.</blockquote>

#### Схематизация таблиц в формате Key—Subkey—Value (YaMR-формат)
Типовой исторически сложившийся формат — таблица из трех колонок строкового типа key—subkey—value, где в значении value запаковано несколько логических значений-колонок в произвольном формате. В этом случае в схеме указываются key/subkey/value и UDF-функция (UDF-ремаппер), которая умеет распаковывать из value логические колонки. При таком способе схематизации пользователь YQL работает с таблицей в терминах логических колонок, а функция-распаковщик от него скрыта и вызывается прозрачно.


#### Приведение таблиц к формату Key—Subkey—Value (YaMR-формат)

Чтобы YT-таблицу в формате, отличном от [yamr](https://wiki.yandex-team.ru/yt/userdoc/formats#yamr), можно было бы прочитать с кластера в представлении key—subkey—value, необходимо выставить атрибут `_format` в значение [yamred_dsv](https://wiki.yandex-team.ru/yt/userdoc/formats#yamreddsv), с указанием, какие колонки сделать ключом и подключом.

**NB**: //Важно не переопределять этот атрибут, если он уже выставлен на таблице, это сломает процессы остальным пользователям.//

<blockquote>Подробнее см. описание атрибута [_formats](#formats).</blockquote>

#### Таблицы, содержащие сериализованные данные protobuf message

Если в колонке таблицы хранятся сериализованные protobuf message, то YQL умеет прозрачно представлять их в виде конструкции из [контейнеров](../types/containers.md) (в основном Struct+List+Optional) и простых типов.

#### Таблицы, не имеющие схемы

При отсутствии какой-либо схемы на таблице по умолчанию запросы не будут выполняться, но есть возможность вручную включить режим вывода схемы по данным в первой строке таблицы. Для всех таблиц, для которых не указано никаких связанных со схемами мета-атрибутов, можно воспользоваться inferscheme в самом запросе. Тогда по первой строке таблицы YQL автоматически выводит схему, получив из YT названия присутствующих в ней столбцов и их типы.

Включить данный режим с помощью добавления `PRAGMA yt.InferSchema;` в начало запроса.

<blockquote>Автоматическое выведение схемы не рекомендуется, поскольку его результат <strong>зависит от порядка строк в таблице</strong>.  Схема выводится только по первой строке таблицы и если где-либо в данных встречаются логические NULL, то получающаяся схема будет в каком-то смысле случайна: если какой-то колонке не повезло быть NULL на первой строке, то она не попадет в схему, а, например, в соседней полностью аналогичной таблице может и попасть.</blockquote>

## Мета-атрибуты для схематизации данных
Сейчас схему для таблицы в YT можно задать с помощью специальных атрибутов. Различные комбинаций этих атрибутов позволяют достаточно гибко работать с существующими таблицами. На результатах YQL-запросов атрибуты со схемой проставляются автоматически.

### (schema) schema — !!(зел)рекомендуется к использованию!!
Системный атрибут `schema` задает схему таблицы в терминах YT. Схема может быть или не быть строгой (определяется YSON-атрибутом `strict` на схеме). При нестрогой схеме в таблице могут встречаться и не указанные в ней столбцы, для доступа к которым YQL создает дополнительную колонку `_other` типа `Dict<String,String>`, к которой можно обратиться через `SELECT t._other{"name"} FROM [path/to/table] AS t;`.

<blockquote>**Крайне полезно** ознакомиться с [инструкцией по установке schema (с примерами)](/yt/userdoc/staticschema/) в документации YT про схематизацию.</blockquote>

Соответствие поддерживаемых типов:

| **Указывается в мета-атрибуте** | **Как выглядит со стороны YQL** |
| --- | --- |
| boolean | `Bool?` |
| int64 | `Int64?` |
| uint64 | `Uint64?` |
| double | `Double?` |
| string | `String?` |
| any | `Yson?` |

В колонке с типом `any` может храниться произвольного вида YSON, с которым затем рекомендуется работать с помощью [одноименного модуля Yson](../udf/list/yson.md) или [Python UDF](../udf/python.md). Это может быть удобно как решение на переходный период от слабоструктурированных данных к строго схематизированным.

Пример значения мета-атрибута `schema`:
```
<strict=%false>[
  {
    name = "foo";
    type = "string";
  };{
    name = "bar";
    type = "int64";
  }
]
```

### \_read\_schema — не рекомендуется
<a name="read_schema"></a>

До того, как в YT появилась нативная поддержка схематизации, аналогичного поведения в YQL можно было добиться с помощью пользовательского атрибута `_read_schema`, который с точки зрения YQL ведет себя ровно так же, как и `schema`, но никак не интерпретируется самим кластером YT.

### \_yql\_read\_udf
<a name="yqlreadudf"></a>

Есть случаи, когда в колонке хранятся произвольные данные, или же из них можно получить более удобное представление (например, развернуть таблицу в историческом формате YaMR — с 3-мя столбцами key—subkey—value — в настоящую таблицу с нужным количеством столбцов).

Для такого случая предусмотрена возможность задать специальную функцию-конвертертер (UDF-конвертер). Для этого на таблицу требуется проставить атрибут `_yql_read_udf` — он указывает на UDF-конвертер для преобразования данных ([документация по написанию C++ UDF](../udf/cpp.md)). UDF-конвертер принимает на вход схематизированные с помощью атрибутов `schema/_read_schema/_format=yamred_dsv` данные в формате Key—Subkey—Value, и обрабатывает их построчно.

Дополнительно с этим атрибутом могут указываться `_yql_read_udf_run_config` / `_yql_read_udf_type_config` — опциональные конфиги, которые функция, указанная в `_yql_read_udf`, может использовать для изменения своего поведения.

### (proto\_field) \_yql\_proto\_field
Если в колонке таблицы хранятся сериализованные protobuf message, то YQL умеет прозрачно представлять их в виде конструкции из [контейнеров](../types/containers.md) (в основном Struct+List+Optional) и простых типов. Работает это без перекомпиляции с помощью [механизма сериализации protobuf-дескрипторов с последующим reflection](https://developers.google.com/protocol-buffers/docs/techniques#self-description), то есть добавление новых новых полей или таблиц не требует никаких релизов, только изменения мета-атрибутов таблиц.

Есть две возможности указывать схему полей для запросов:

1. Установить на таблицу мета-атрибут `_yql_proto_field_mycolumn` со значением ` {"name":"TMyMessage","meta":"Base64AndGzippedProtoDescription"}`, где:

  * **mycolumn** — имя колонки с protobuf в таблице (можно установить несколько атрибутов, если нужно применить механизм к нескольким колонкам);
  * **TMyMessage** — имя message из нужного `.proto`-файла;
  * **Base64AndGzippedProtoDescription** — результат вызова `protoc --descriptor_set_out`, пропущенный сначала через gzip, а затем через base64 encode.
  * Также в этом словаре могут указываться дополнительные опции.
  Для данного действия нужен доступ на запись в эту таблицу, в случае его отсутствия есть два варианта: обратиться к ответственным за таблицу, либо сделать копию и работать с ней.
2. Указать схему в самом запросе, не изменяя таблицу. ((https://yql.yandex-team.ru/Operations/Wljxusx7dgmAy7aCaVMjGtcvevhJ97GgqX20GvnPhq8= Вот рабочий пример)), правда возможно слишком громоздкий.

Для удобства в [консольный клиент YQL](../interfaces/cli.md) встроена утилита `yql proto_field`, которая правильным образом устанавливает описанный выше мета-атрибут. Для ее работы нужен консольный клиент yt и protoc, по умолчанию используются утилиты из `$PATH`. Есть возможность выбрать формат сериализации protobuf с помощью опции `-f` (`protobin` — по умолчанию бинарный, `prototext` — текстовый, `json`), а также игнорировать фиксированное число байт в начале каждой ячейки с помощью опции `-s` (там может лежать ее длина или что-то еще). Все остальные опции обязательны и описаны в `yql proto_field -h`. Также должен быть получен и сохранен YT-токен, команду для этого можно [получить здесь](http://locke.yt.yandex.net/auth/new).

Пример вызова yql proto_field:
``` bash
$ ya yql proto_field -c hahn -t //home/yql/tutorial/samples/proto_field/news_entries -p yweb/news/proto/storage/news_db.proto -m TRawNewsDoc -n data -y
```

Также есть библиотеки [на c++](https://a.yandex-team.ru/arc/trunk/arcadia/library/protobuf/yql) и [на python](https://a.yandex-team.ru/arc/trunk/arcadia/library/python/protobuf/yql), позволяющие генерировать описание поля из класса, соответствующего сообщению. Примеры использования смотрите в папках ut и в README.md этих библиотек.

<details markdown="1">
<summary>Примеры таблиц с установленным _yql_proto_field_mycolumn.</summary>
https://yt.yandex-team.ru/hahn/#page=navigation&path=//home/yql/tutorial/samples/proto_field
https://yt.yandex-team.ru/banach/#page=navigation&path=//home/yql/tutorial/samples/proto_field
</details>

Для генерации содержимого `_yql_proto_field` из **C++**, следует воспользоваться функцией [GenerateProtobufTypeConfig](https://a.yandex-team.ru/arc/trunk/arcadia/library/protobuf/yql/descriptor.h?rev=2514893#L50).

Если вы захотите повторить эту логику в каком-то другом окружении без консольного клиента yql, то может оказаться полезным [почитать код этой утилиты](https://a.yandex-team.ru/arc/trunk/arcadia/yql/library/python/yql/util/proto_field.py).

Из текущих ограничений:

* Не поддерживаются рекурсивные message, можно только включить игнорирование (если вы их используете — расскажите нам о своем сценарии письмом на [yql@](https://ml.yandex-team.ru/lists/yql)).
* Не совместимо с [_yql_read_udf](#yqlreadudf).
* Не поддерживаются фичи из [protobuf3](https://developers.google.com/protocol-buffers/docs/proto3), например map.
* См. также [yql proto_field: remove/warn about @_yql_row_spec ](https://st.yandex-team.ru/YQL-2348)

### \_format — не рекомендуется
Множество логов в YT в разделе `//statbox` для совместимости с YaMR имеют атрибут _format=[yamred_dsv](https://wiki.yandex-team.ru/yt/userdoc/formats#yamreddsv), этот атрибут позволяет прочитать данные из таблицы в виде key—subkey—value.

При наличии `schema` или `_read_schema` этот атрибут игнорируется, в противном случае таблица будет читаться в виде Key—Subkey—Value, соответственно, в таком виде будет возвращена в клиент YQL или передана на обработку UDF-конвертеру.

**NB**: //Важно не переопределять этот атрибут, если он уже выставлен на таблице, это сломает процессы остальным пользователям.//

### \_yql\_view\_$viewname
В YQL реализовано два вида представления данных:

* привязанные к конкретным таблицам;
* независимые, в которых могут использоваться произвольное число таблиц в рамках кластера.
Оба они не являются материализованными, то есть подставляются в граф вычислений при каждом использовании.

Для создания независимого VIEW в YT, нужно:

1. создать узел с типом `document`,
2. в содержимое положить строку с текстом запроса,
3. указать на нем мета-атрибут `_yql_type=view`.
[Пример.](https://yt.yandex-team.ru/hahn/#page=navigation&path=//home/yql/tutorial/users_view&mode=attributes)

За наличие VIEW на таблице отвечает атрибут `_yql_view_foo`, где foo — имя VIEW, а в значении атрибута указывается SQL-запрос для создания VIEW. Этому SQL-запросу доступно только две таблицы:

* `self_raw` — исходные данные в формате key—subkey—value текущей таблицы или результат применения `_read_schema`;
* `self` — результат работы UDF, указанной в `_yql_read_udf` (если отсутствует — идентична таблице `self_raw`).
У каждой таблицы может быть много таких VIEW — это удобно в случае, если в одной MR-таблице хранятся несколько наборов разнородных данных.

Если на таблице установлен мета-атрибут `_yql_read_udf`, то доступ к исходным данным до его применения можно получить с помощью специального VIEW `raw`.
Синтаксис SQL позволяет обратиться к конкретному VIEW следующим образом: `cluster.[table]:[view]`. [Подробнее](../syntax/extensions.md#view).

<details markdown="1">
<summary>Пример для YT</summary>
Рассмотрим: `//statbox/reqans-log/2016-03-08`
Превью таблицы в YT
https://jing.yandex-team.ru/files/vag-ekaterina/2016-03-08_-_Navigation_-_Plato_2016-03-11_01-39-05.png

Атрибуты на таблице
https://jing.yandex-team.ru/files/vag-ekaterina/2016-03-08_-_Navigation_-_Plato_2016-03-11_01-37-40.png

Превью в YQL
https://jing.yandex-team.ru/files/vag-ekaterina/YQL_Query_Constructor_2016-03-11_01-41-07.png

</details>

### \_yql\_row\_spec — не рекомендуется
На YT крайне рекомендуется пользоваться нативной схематизацией (см. [выше](#schema)), но если хочется пока продолжить жить в мире key—subkey—value, то нужно указать на такой таблице атрибут `_yql_row_spec`, значение которого можно списать с <https://yt.yandex-team.ru/hahn/#page=navigation&path=//user_sessions/pub/spy_log/daily/2016-07-17/clean&mode=attributes>

Дополнительные нюансы:

* Если в таблице бывает пропущен subkey, то еще нужны `_yql_row_spec -> DefaultValues` как тут <https://yt.yandex-team.ru/hahn/#page=navigation&path=//statbox/reqans-log/2016-07-18&mode=attributes>
* Если таблица не отсортирована по key/subkey, то нужно пропустить подполя `_yql_row_spec` со словом sort, то есть получится ровно как по ссылке в предыдущем пункте. Либо просто сначала отсортировать таблицу по key/subkey средствами YT.

Пример команды:
`$ yt set --proxy CLUSTER //PATH/TO/TABLE/@_yql_row_spec < _YQL_ROW_SPEC.txt`
CLUSTER и //PATH/TO/TABLE следует заменить на имя кластера и путь к таблице.

Пример значения `_yql_row_spec`: <https://paste.yandex-team.ru/149089>

## Как проверить, схематизированы ли ваши данные?
Большинство общих данных уже размечено, так что, возможно, нужные вам данные уже схематизированы. Проверить несложно:

  * Самое простое — сделать запрос вида `SELECT * FROM cluster.[path/to/table] LIMIT 1;`, если он выдаст какую-либо ошибку вместо первой строки — практически наверняка у этой таблицы проблема со схемой.
  * В интерфейсе YQL пример для таблицы `//home/yql/tutorial/users` на Hahn: <https://yql.yandex-team.ru/?cluster=hahn&path=home/yql/tutorial/users>
  <details markdown="1"><summary>PrintScreen</summary>
  <https://jing.yandex-team.ru/files/vag-ekaterina/YQL_Query_Constructor_2015-10-28_19-01-00.png</details>>
  * Проверить наличие атрибутов и воспользоваться описанной логикой **для YT**:
  `yt --proxy cluster get //table/@attribute_name`
  Например, `yt --proxy hahn.yt.yandex.net get //home/yql/tutorial/users/@_read_schema`
</details>

## Как разметить/переразметить свои данные?

  * Выставить самостоятельно для YT:
    * `echo 'attribute_value' | yt --proxy cluster set //table/@_yql_attribute_name` <span style="color:gray;">// какие возможны имена и значения атрибутов - см. выше</span>
    * Подробнее про работу с атрибутами [здесь](https://wiki.yandex-team.ru/yt/pythonwrapper)
* Если вы используете логи в общих квотах (`//logs,//statbox`), то можно завести тикет в st/DATA с заданием на разметку лога и перечнем списка полей, которые необходимо прописать, либо сделать настройку самостоятельно, как написано на [вики](https://wiki.yandex-team.ru/logfeller/schema/yt/).
* В остальных случаях написать на [yql@](https://ml.yandex-team.ru/lists/yql).


## Какие данные сейчас схематизированы?
О схематизации данных в общей квоте logfeller `//logs` читайте [здесь](https://wiki.yandex-team.ru/logfeller/schema/yt/).

Сейчас данные схематизированы с разной степенью детализации:


1. Часть таблиц (в основном на YT) представляют собой набор из 3 столбцов с именами key, subkey, dict следующих типов:

| key| subkey|dict |
| --- | --- | --- |
| String|String|Dict<String,String>|
dict — словарь, элементы которого — ключи в исходной таблице в формате tab separated key—value (`key1=value1\tkey2=value2\t...\tkeyN=valueN`). Oбратиться к ключам словаря можно с помощью вызова `dict{имя колонки}`.

2. Часть таблиц на **YT** размечены с помощью [YT-схем](/yt/design/schema) как набор независимых столбцов (то есть не полученных из одного физического столбца с помощью UDF-конвертера или других обсуждавшихся выше механизмов).
Пока **в большинстве случаев все колонки таких таблиц имеют тип String**, потому что логи не типизированы.
В будущем эта ситуация будет меняться, а чтобы сейчас привести данные к иному типу, можно воспользоваться VIEW поверх этой схемы.
VIEW, в свою очередь, тоже уже указаны на части таблиц.

| column1| column2|column3 |
| --- | --- | --- |
| String|String|String|

3. Для таблиц в нестандартных форматах существуют собственные конвертеры, позволяющие привести строки исходной таблицы к схематизированному виду для YQL. В таких случаях схемы могут содержать колонки с типами, отличными от String.

| column1| column2|column3|column4 |
| --- | --- | --- | --- |
| String|Int64|Uint64|Dict<String,String>|

## Порядок обработки мета-атрибутов для схематизации
Данные на кластере YT могут быть схематизированы несколькими способами.
Сейчас все схемы на YT задаются с помощью указания различных атрибутов и их комбинаций на таблице.


1. На таблице указан атрибут `schema` и он не пустой.
2. На таблице указан атрибут `_read_schema`.
3. `_read_schema`/`schema` + `_yql_read_udf`.
3. На таблице указан `_format = yamred_dsv`  или она в формате `yamr`.
4. На таблице указан `_format = yamred_dsv` или она в формате `yamr + _yql_read_udf`.

Для всех случаев может быть указан VIEW через атрибут: `_yql_view_$viewname`.

Для случаев 1—3, если при чтении таблицы найдены столбцы, не описанные в схеме, а в атрибуте дополнительно указан [атрибут](https://wiki.yandex-team.ru/yt/userdoc/yson/) `<strict=%false>`, то данные из этих столбцов доступны в поле `_other` типа `Dict<String,String>` и обратиться к ним можно через `_other{"name"}`.

Приоритет исполнения:

  1. При чтении по дефолту берется схема из `_read_schema`, если не указано иное.
  2. Если `_read_schema` нет, то используется `schema`, если она не пуста.
  3. Если `_read_schema` и `schema` пусты (отсутствуют или не содержат колонок), то проверяется наличие `_format=yamred_dsv`.
  4. При отсутствии какой-либо схемы на таблице по умолчанию запросы не будут выполняться, но есть возможность вручную включить [режим вывода схемы по данным (inferschema)](../pragmas.md#inferschema).

Дальнейшая схематизация с помощью `_yql_read_udf` работает поверх данных представлений, и если она указана, то является дефолтной.
`_yql_view_$viewname` задает дополнительные VIEW для таблицы.

<blockquote>

* Подробности про работу схем в YT описаны [здесь](https://wiki.yandex-team.ru/yt/design/schema).
* Типы, поддерживаемые в YT и доступные для schema и `_read_schema`, описаны [здесь](https://wiki.yandex-team.ru/yt/userdoc/yson/).
* Все колонки из YT-схем сейчас являются типами, допускающими значение NULL ([Optional](../types/optional.md)).</blockquote>

## FAQ

#### 1) Почему схем нет по умолчанию на «поколоночных» YT-таблицах, почему не сделать так же, как там, для всех таблиц?
Максимально похожим такое поведение вы можете сделать сами с помощью inferscheme. В качестве дефолтного поведения это плохо по нескольким причинам: не все таблицы однородны, и даже в однородных таблицах одна и та же колонка somefield в разных строчка может быть как строчкой, так и числом.

#### 2) Какие типы сейчас доступны?
Полный список доступных в YQL типов можно найти [здесь](../types/primitive.md).
Так как текущие механизмы поставки и предобработки логов ничего не знают про типы данных, то по умолчанию во всех логах, размеченных `read_schema`, все колонки — строкового типа.
В новом конвейере LogFeller мы уже [закладываемся](https://wiki.yandex-team.ru/logfeller/schema/yt/) на различные типы при поставке данных потребителям.

#### 3) Как залить данные с колонками разных типов?
<https://yql.yandex-team.ru/?cluster=hahn&path=home/yql/examples/complex_types>
```SELECT * FROM hahn.[home/yql/complex_types];
```
#### 4) Что значат вопросики в превью схем?
Все типы колонок сейчас допускаю значение NULL (optional/nullable), вопросик после имени типа — условное обозначение для optional.

#### 5) Что делать, если я хочу обращаться в YQL к чужим данным, которые не схематизированы?
В нашем понимании за схему данных отвечает тот же человек, что и за саму таблицу, где эти данные лежат. Поэтому правильный способ — это написать владельцу таблиц и попросить его схематизировать данные. При возникновении вопросов, можно смело писать нам. А если вас заинтересовали данные в квоте statbox-logs, то вопросы можно сразу писать кому:vag-ekaterina.

#### 6) Почему способов «описать» данные так много?
Исторически для поддержки совместимости с YaMR-таблицами была придумана схема с ремаппингом (UDF-конверторами), чтобы структурировать неструктурированное.
Надо понимать, что при работе с такими данными неизбежно происходит чтение всей строки, а не только указанных в запросе колонок.

#### 7) Почему есть \_read\_schema и schema?
Мы будем вынуждены потерять все, что задано в `schema` при миграции на настоящую схему, которая будет валидироваться при записи; ведь дефолтная, гарантированная схема для смигрированной статической таблицы — это `<strict=false>[]`.

Поэтому был заведен специальный атрибут `_read_schema` — система его не интерпретирует, зато это будет делать обертка и подставлять в качестве дефолтной схемы на чтение для данной таблицы (по аналогии с атрибутом `_format`).
В принципе этот атрибут сможет работать и после миграции — как дефолтная схема на чтение. Плюс мы сможем мигрировать и ничего не сломать.

*strict — это параметр, указывающий системе, допустимы ли в таблице быть колонки, не указанные в схеме, подробности [здесь](https://wiki.yandex-team.ru/yt/design/schema/).
