# Обзор методов проверки строки на соответствие шаблону

В этом разделе собраны все методы для проверки строки на соответствие шаблону

## `LIKE`, `ILIKE`
[ссылка](_includes/expressions/check-match.md)

Самый простой способ проверки строки. Проверяемая строка должна полностью совпасть с шаблоном.

**Пример**
```yql
SELECT * FROM 
    (values(@@Yandex.Cloud
Облачная платформа, где каждый может создавать и совершенствовать свои цифровые сервисы, используя инфраструктуру и уникальные технологии Яндекса.@@u)) as t(column1)
WHERE column1 LIKE '%Cloud%Облачная%';
```

## `REGEXP`, `RLIKE`, `MATCH`
[ссылка](_includes/expressions/check-match.md)

`REGEXP`, `RLIKE` являются алиасами и представляют собой короткий способ записи для вызова [Hyperscan::Grep](../../../udf/list/hyperscan.md#grep). 

`MATCH` — аналогично для [Hyperscan::Match](../../../udf/list/hyperscan.md#match).

[Синтаксис](http://intel.github.io/hyperscan/dev-reference/compilation.html#building-a-database) читайте со слов "Supported Constructs".

Unicode character properties, such as \p{L}, \P{Sc}, \p{Greek}.

**Пример**

Каждый закомментированный вариант совпадает со строкой. @@ начинают и завершают raw строку что позволяет не дублировать слеш на управляющих знаках. u обозначет литерал UTF строки.
```yql
SELECT * FROM 
(values(@@Yandex.Cloud
Облачная платформа, где каждый может создавать и совершенствовать свои цифровые сервисы, используя инфраструктуру и уникальные технологии Яндекса.
123 число
@@u)) as t(column1)
-- WHERE column1 REGEXP @@\d+@@
-- WHERE column1 REGEXP @@\d+\pZчисло@@  -- \d - число  \pZ - разделитель
WHERE column1 REGEXP @@(?m)\PL\pLаждый@@ --  (?m) - multilinr \PL - не буква \pL - буква  
```

## Re2
Библиотека Re2 хороша когда Вам необходимо посмотреть на результат Capture
[Ссылка](../udf/list/re2.md)

``` yql
$value = "ВАСЯ ел банан и сосал сушку"u;
-- включить режим без учета регистра
$capture = Re2::Capture(@@(?i)(вася)@@);
$capture = Re2::Capture(@@(?i)(?P<vasya>вАсЯ).*(?P<banan>банан)@@);

SELECT  $capture($value) AS capture;

-- Результат:
-- (
--     "_0": "ВАСЯ ел банан",
--     "banan": "банан",
--     "vasya": "ВАСЯ"
-- )
```

## FIND, RFIND
    
Поиск позиции подстроки в строке. [Документация](../builtins/_includes/basic/find.md)

## SUBSTRING

Возвращает подстроку. [Документация](../builtins/_includes/basic/substring.md)

## StartsWith, EndsWith

Проверка наличия префикса или суффикса в строке. [Документация](../builtins/_includes/basic/starts_ends_with.md)

## Прочие библиотеки C++

[Ссылка](../udf/list/index.md)

String - Функции для работы с ASCII-строками. (скорее всего вряд ли Вам понадобится потому что рекмонедуется хранить строки в кодировке UTF)

Hyperscan - функции из нее были рассмотрены выше.


Re2 - рекомендуемая к использованию библиотека особенно когда Вам нужна функция Capture

Pire - библиотека от Yandex

К сожалению ни в одной из вышеприведенных библиотек не поддерживается возврат (литерал \1)

Unicode - Функции для работы с Unicode строками. Работает странно, метод Find не реализован. Но возможно что нужный Вам метод найдется. Рекомендуется пользоваться стандартынми методами, перечисленными выше (find и тд).