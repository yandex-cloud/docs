
# Лексическая структура

{% if feature_mapreduce %}Программа {% else %}Запрос {% endif %} на языке YQL представляет собой валидный UTF-8 текст, который состоит из _команд_ (statement) разделенных символом точка с запятой (`;`).
Последняя точка с запятой при этом может отсутствовать.
Каждая команда, в свою очередь, состоит из последовательности _токенов_ допустимых для данной команды.
Токеном может быть _ключевое слово_, _идентификатор_, _литерал_ и другие.
Токены разделяются пробельными символами (пробел, табуляция, перевод строки) либо _комментариями_. Комментарий не является частью команды и синтаксически эквивалентен пробельному символу.

## Режимы совместимости синтаксиса {#lexer-modes}

Поддерживаются два режима совместимости синтаксиса: 
* Расширенный C++ (по-умолчанию)
* ANSI SQL

Режим ANSI SQL включается с помощью специального комментария `--!ansi-lexer`, который должен стоять в начале {% if feature_mapreduce %}программы{% else %}запроса{% endif %}.

Особенности интерпретации лексических элементов в разных режимах совместимости описаны ниже.

## Комментарии {#comments}

Поддерживаются следующие виды комментариев:

* Однострочные: начинается с последовательности символов `--` (два минуса _подряд_) и продолжается до конца строки
* Многострочные: начинается с последовательности символов `/*` и заканчивается на последовательности символов `*/`

``` sql
SELECT 1; -- A single-line comment
/*
   Some multi-line comment
*/
```
В режиме совместимости синтаксиса C++ (по-умолчанию) многострочный комментарий заканчивается на _ближайшей_ последовательности символов `*/`.
В режиме совместимости синтаксиса ANSI SQL учитывается вложенность многострочных комментариев:

``` sql
--!ansi_lexer
SELECT * FROM T; /* комментарий /* вложенный комментарий, без ansi_lexer будет ошибка  */ */
```

## Ключевые слова и идентификаторы {#keywords-and-ids}

**Ключевые слова** – это токены, имеющее фиксированное значение в языке YQL. Примеры ключевых слов – `SELECT`, `INSERT`, `FROM`, `ACTION` и т.д. Ключевые слова регистронезависимы, то есть `SELECT` и `SeLEcT` эквивалентны.
Список ключевых слов не фиксирован – по мере развития языка он будет расширяться. Ключевое слово не может содержать цифры и начинаться или заканчиваться символом подчеркивания.

**Идентификаторы** – это токены, которые идентифицируют имена таблиц, колонок и других объектов в YQL. Идентификаторы в YQL всегда регистрозависимы.
Идентификатор может быть записан в теле программы без специального оформления, если он:
* Не является ключевым словом
* Начинается с латинской буквы или подчеркивания
* Последующими символами могут быть латинская буква, подчеркивание или цифра

``` sql
SELECT my_column FROM my_table; -- my_column and my_table are identifiers
```

Для записи в теле {% if feature_mapreduce %}программы{% else %}запроса{% endif %} произвольного идентификатора он заключается в обратные кавычки (бэктики):
``` sql
SELECT `column with space` from T;
SELECT * FROM `my_dir/my_table`
```

Идентификатор в обратных кавычках никогда не интерпретируется как ключевое слово:

``` sql
SELECT `select` FROM T; -- select - имя колонки в таблице T
```
При использовании обратных кавычек применим стандартный C-эскейпинг:

``` sql
SELECT 1 as `column with\n newline, \x0a newline and \` backtick `;
```

В режиме совместимости синтаксиса ANSI SQL произвольные идентификаторы также могут быть выделены заключением их в двойные кавычки. Для включения двойной кавычки в идентификатор в кавычках она должна быть удвоена:

``` sql
--!ansi_lexer
SELECT 1 as "column with "" double quoute"; -- имя колонки будет: column with " double quoute
```

## Строковые литералы {#string-literals}

Строковой литерал (константа) записывается как последовательность символов, заключенных в одинарные кавычки. Внутри строкового литерала можно использовать правила эскейпинга в стиле C:
``` yql
SELECT 'string with\n newline, \x0a newline and \' backtick ';
```

В режиме совместимости синтаксиса С++ (по-умолчанию) разрешается использовать вместо одинарных кавычек двойные:
```yql
SELECT "string with\n newline, \x0a newline and \" backtick ";
```

В режиме совместимости синтаксиса ASNI SQL двойные кавычки используются для идентификаторов, а единственный вид эскепинга который действует для строковых литералов – это  дублирование символа одиночной кавычки:

```sql
--!ansi_lexer
SELECT 'string with '' quote'; -- результат: string with ' quote
```

### Многострочные строковые литералы {#multiline-string-literals}

Многострочный строковой литерал записывается в виде произвольного набора символов между двойными собачками `@@`:

``` yql
$text = @@some
multiline
text@@;
SELECT LENGTH($text);
```

Если необходимо вставить в текст двойную собачку, ее необходимо удвоить:

``` yql
$text = @@some
multiline with double at: @@@@
text@@;
SELECT $text;
```

### Типизированные строковые литералы {#typed-string-literals}

* Для строкового литерала, включая [многострочный](#multiline-string-literals), по умолчанию используется тип `String`.
* С помощью следующих суффиксов можно явно управлять типом литерала:
    * `u` — `Utf8`;
    * `y` — `Yson`;
    * `j` — `Json`.

**Пример:**
``` yql
SELECT "foo"u, '[1;2]'y, @@{"a":null}@@j;
```

## Числовые литералы {#literal-numbers}

* Целочисленные литералы по умолчанию имеют тип `Int32`, если попадают в его диапазон, и в противном случае автоматически расширяются до `Int64`.
* С помощью следующих суффиксов можно явно управлять типом литерала:
    * `l` — `Int64`;
    * `s` — `Int16`;
    * `t` — `Int8`.
* Добавление суффикса `u` превращает тип в соответствующий беззнаковый:
    * `ul` — `Uint64`;
    * `u`  — `Uint32`;
    * `us` — `Uint16`;
    * `ut` — `Uint8`.
* Также для целочисленных литералов доступна запись в шестнадцатеричной, восьмеричной и двоичной форме с помощью префиксов `0x`, `0o` и `0b`, соответственно. Их можно произвольным образом комбинировать с описанными выше суффиксами.
* Литералы с плавающей точкой по умолчанию имеют тип `Double`, но с помощью суффикса `f` его можно сузить до `Float`.

``` sql
SELECT
  123l AS `Int64`,
  0b01u AS `Uint32`,
  0xfful AS `Uint64`,
  0o7ut AS `Uint8`,
  456s AS `Int16`,
  1.2345f AS `Float`;
```
