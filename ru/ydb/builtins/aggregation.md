# Агрегатные функции в YQL

## COUNT

Подсчет количества строк в таблице (если в качестве аргумента указана `*`) или непустых значений в столбце таблицы (если в качестве аргумента указано имя столбца).

Как и другие агрегатные функции, может использоваться в сочетании с `GROUP BY` для получения статистики по частям таблицы, соответствующим значениям в столбцах, по которым идет группировка.

**Примеры:**
``` yql
SELECT COUNT(*) FROM my_table;
```
``` yql
SELECT COUNT(value) FROM my_table GROUP BY key;
```

## MIN и MAX

Минимальное или максимальное значение.

В качестве аргумента допустимо произвольное вычислимое выражение с числовым результатом.

**Примеры:**
``` yql
SELECT MIN(value), MAX(value) FROM my_table;
```

## SUM

Сумма чисел.

В качестве аргумента допустимо произвольное вычислимое выражение с числовым результатом.

Целые числа автоматически расширяются до 64 бит, чтобы снизить риск переполнения.

``` yql
SELECT SUM(value) FROM my_table;
```

## AVG

Арифметическое среднее.
В качестве аргумента допустимо произвольное вычислимое выражение с числовым результатом.
Целочисленные значения и интервалы времени автоматически приводятся к Double.

**Примеры:**
``` yql
SELECT AVG(value) FROM my_table;
```

## COUNT_IF

Количество строк, для которых указанное в качестве аргумента выражение истинно (результат вычисления выражения — true).

Значение NULL приравнивается к false (в случае если тип аргумента Bool?).

Функция не выполняет неявного приведения типов к булевым для строк и чисел.

**Примеры:**
``` yql
SELECT
  COUNT_IF(value % 2 == 1) AS odd_count
FROM my_table;
```

## SUM_IF и AVG_IF

Сумма или арифметическое среднее, но только для строк, удовлетворяющих условию, переданному вторым аргументом.

Таким образом, `SUM_IF(value, condition)` является чуть более короткой записью для `SUM(IF(condition, value))`, аналогично для `AVG`. Расширение типа данных аргумента работает так же аналогично функциям без суффикса.

**Примеры:**
``` yql
SELECT
  SUM_IF(value, value % 2 == 1) AS odd_sum,
  AVG_IF(value, value % 2 == 1) AS odd_avg,
FROM my_table;
```

## CountDistinctEstimate, HyperLogLog и HLL

Примерная оценка числа уникальных значений по алгоритму [HyperLogLog](https://en.wikipedia.org/wiki/HyperLogLog). Логически делает то же самое, что и `COUNT(DISTINCT ...)`, но работает значительно быстрее ценой некоторой погрешности.

Аргументы:

1. Значение для оценки;
2. Точность (от 4 до 18 включительно, по умолчанию 14).

Выбор точности позволяет разменивать дополнительное потребление вычислительных ресурсов и оперативной памяти на уменьшение погрешности.

На данный момент все три функции являются алиасами, но в будущем `CountDistinctEstimate` может начать использовать какой-то другой алгоритм.

**Примеры:**
``` yql
SELECT
  CountDistinctEstimate(my_column)
FROM my_table;
```

``` yql
SELECT
  HyperLogLog(my_column, 4)
FROM my_table;
```

## SOME

Получить значение указанного в качестве аргумента выражения для одной из строк таблицы. Не дает никаких гарантий о том, какая именно строка будет использована. Аналог функции [any()](https://clickhouse.yandex/docs/ru/agg_functions/reference/#anyx) в ClickHouse.

Из-за отсутствия гарантий `SOME` вычислительно дешевле, чем часто использующиеся в подобных ситуациях `MIN/MAX`.

**Примеры:**
``` yql
SELECT
  SOME(value)
FROM my_table;
```

## LIST

Получить все значения столбца в виде списка. В сочетании с `DISTINCT` возвращает только уникальные значения. Порядок элементов в результирующем списке зависит от реализации и снаружи не задается, чтобы получить упорядочный список необходимо отсортировать результат, например с помощью [ListSort](list.md#listsort).

Выполняется **НЕ** ленивым образом, поэтому при использовании нужно быть уверенным, что список получится разумных размеров, примерно в пределах тысячи элементов, иначе запрос не отработает с ошибкой `Memory limit exceeded`. Чтобы подстраховаться, можно воспользоваться вторым опциональным числовым аргументом, который включает ограничение на число элементов в списке.

Например, можно использовать в сочетании с `DISTINCT` и функцией [String::JoinFromList](../udf/list/string.md) (аналог `','.join(list)` из Python) для распечатки в строку всех значений, которые встретились в столбце после применения `GROUP BY`.

**Примеры:**
``` yql
SELECT
  key,
  String::JoinFromList(
    LIST(DISTINCT value),
    ","
  )
FROM my_table
GROUP BY key;
```

``` yql
SELECT
  key,
  LIST(value, 1000)
FROM my_table
GROUP BY key;
```

## MAX_BY и MIN_BY

Вернуть значение первого аргумента для строки таблицы, в которой второй аргумент оказался минимальным/максимальным.

Опционально можно указать третий аргумент N, который влияет на поведение в случае, если в таблице есть несколько строк с одинаковым минимальным или максимальным значением:

* Если N не указано — будет возвращено значение одной из строк, а остальные отбрасываются.
* Если N указано — будет возвращен список со всеми значениями, но не более N, все значения после достижения указанного числа отбрасываются.

Рекомендуется указывать значения N порядка сотен или тысяч, чтобы избегать проблем с ограничениями доступной памяти на кластерах MapReduce.

Если для задачи обязательно нужны все значения, и их количество может измеряться десятками тысяч и больше, то вместо данных агренационных функций следует использовать `JOIN` исходной таблицы с подзапросом, где по ней же сделан `GROUP BY + MIN/MAX` на интересующих вас колонках.

!!! warning "Внимание"
    Если второй аргумент всегда NULL, то результатом агрегации будет NULL.

**Примеры:**
``` yql
SELECT
  MIN_BY(value, LENGTH(value)),
  MAX_BY(value, key, 100),
FROM my_table;
```

## STDDEV и VARIANCE
<a name="stddev"></a><a name="variance"></a>

Стандартное отклонение и дисперсия по колонке. Используется [однопроходной параллельный алгоритм](https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Parallel_algorithm), результат которого может отличаться от полученного более распространенными методами, требующими двух проходов по даным.

По умолчанию вычисляются выборочная дисперсия и стандартное отклонение. Доступны несколько способов записи:

* с суффиксом/префиксом `POPULATION`, например: `VARIANCE_POPULATION`, `POPULATION_VARIANCE` — вычисляет дисперсию/стандартное отклонение для генеральной совокупности;
* с суффиксом/префиксом `SAMPLE` или без суффикса, например `VARIANCE_SAMPLE`, `SAMPLE_VARIANCE`, `SAMPLE` — вычисляет выборочную дисперсию и стандартное отклонение.

Также определено несколько сокращенных алиасов, например `VARPOP` или `STDDEVSAMP`.
Если все переданные значения — NULL, возвращает NULL.

**Примеры:**
``` yql
SELECT
  STDDEV(numeric_column),
  VARIANCE(numeric_column)
FROM my_table;
```

## CORRELATION и COVARIANCE

Корреляция и ковариация двух колонок.

Также доступны сокращенные версии `CORR` или `COVAR`, а для ковариации - версии c суффиксом `SAMPLE` / `POPULATION` по аналогии с описанной выше [VARIANCE](#variance).

В отличии от большинства других агрегатных функций не пропускают `NULL`, а считают его за 0.


``` yql
SELECT
  CORRELATION(numeric_column, another_numeric_column),
  COVARIANCE(numeric_column, another_numeric_column)
FROM my_table;
```

## PERCENTILE и MEDIAN

Подсчет процентилей по амортизированной версии алгоритма [TDigest](https://github.com/tdunning/t-digest). `MEDIAN` — алиас для `PERCENTILE(N, 0.5)`.

!!! info "Ограничение"
    Первый аргумент (N) должен быть именем колонки таблицы. Если это ограничение необходимо обойти, можно использовать подзапрос. Ограничение введено для упрощения вычислений, поскольку в реализации несколько вызовов с одинаковым первым аргументом (N) склеиваются в один проход.

``` yql
SELECT
    MEDIAN(numeric_column),
    PERCENTILE(numeric_column, 0.99)
FROM my_table;
```

## HISTOGRAM

Построение примерной гистограммы по числовому выражению с автоматическим выбором корзин.

[Вспомогательные функции](../udf/list/histogram.md#histogram)

### Базовые настройки

* Ограничение на число корзин можно задать с помощью опционального аргумента, значение по умолчанию — 100. Следует иметь в виду, что дополнительная точность стоит дополнительных вычислительных ресурсов и может негативно сказываться на времени выполнения запроса, а в экстремальных случаях — и на его успешности.
* У `Histogram::Print` есть опциональный числовой аргумент, который задает максимальную длину столбцов гистограммы (в символах, так как гистограмма рисуется в технике ASCII-арт). Зачение по умолчанию — 25.

### Поддержка весов

Имеется возможность указать «вес» для каждого значения, участвующего в построении гистограммы. Для этого вторым аргументом в агрегатную функцию нужно передать выражение для вычисления веса. По умолчанию всегда используется вес `1.0`. Если используются нестандартные веса, ограничение на число корзин можно задать третьим аргументом.

В случае если передано два аргумента, смысл второго аргумента определяется по его типу (целочисленный литерал — ограничение на число корзин, в противном случае — вес).

### Алгоритмы

[Оригинальный whitepaper](http://jmlr.org/papers/volume11/ben-haim10a/ben-haim10a.pdf)
[Используемая библиотека с реализацией в Аркадии](https://a.yandex-team.ru/arc/trunk/arcadia/yweb/robot/kiwi_aggregators/histogram/)

Доступны разные модификации алгоритма:
``` yql
AdaptiveDistanceHistogram
AdaptiveWeightHistogram
AdaptiveWardHistogram
BlockWeightHistogram
BlockWardHistogram
```

По умолчанию `HISTOGRAM == AdaptiveWardHistogram`. Обе функции эквивалентны и взаимозаменимы во всех контекстах.

Алгоритмы Distance, Weight и Ward отличаются формулами объединения двух точек в одну, см. реализацию: <https://a.yandex-team.ru/arc/trunk/arcadia/yweb/robot/kiwi_aggregators/histogram/common.cpp>

Чем отличается Adaptive и Block:
<blockquote>Contrary to adaptive histogram, block histogram doesn't rebuild bins after the addition of each point. Instead, it accumulates points and in case the amount of points overflows specified limits, it shrinks all the points at once to produce histogram. Indeed, there exist two limits and two shrinkage operations:

1. FastGreedyShrink is fast but coarse. It is used to shrink from upper limit to intermediate limit (override FastGreedyShrink to set specific behaviour).
2. SlowShrink is slow, but produces finer histogram. It shrinks from the intermediate limit to the actual number of bins in a manner similar to that in adaptive histogram (set CalcQuality in constuctor)
While FastGreedyShrink is used most of the time, SlowShrink is mostly used for histogram finalization
</blockquote>

### Если нужна точная гистограмма

1. Можно воспользоваться описанными ниже агрегатными функциями с фиксированными сетками корзин: [LinearHistogram](#linearhistogram) или [LogarithmicHistogram](#logarithmichistogram).
2. Можно самостоятельно вычислить номер корзины для каждой строки и сделать по нему [GROUP BY](../syntax/basic.md#group-by).

### Примеры

``` yql
SELECT
        HISTOGRAM(numeric_column)
FROM my_table;
```

``` yql
SELECT
    Histogram::Print(
        HISTOGRAM(numeric_column, 10),
        50
    )
FROM my_table;
```

## LinearHistogram, LogarithmicHistogram и LogHistogram
<a name="linearhistogram"></a><a name="logarithmichistogram"></a><a name="loghistogram"></a>

Построение гистограммы по явно указанной фиксированной шкале корзин.

Аргументы:

1. Выражение, по значению которого строится гистограмма. Все последующие — опциональны.
2. Расстояние между корзинами для `LinearHistogram` или основание логарифма для `LogarithmicHistogram` / `LogHistogram` (это алиасы). В обоих случаях значение по умолчанию  — 10.
3. Минимальное значение. По умолчанию минус бесконечность.
4. Максимальное значение. По умолчанию плюс бесконечность.

Формат результата полностью аналогичен [адаптивным гистограммам](#histogram), что позволяет использовать тот же [набор вспомогательных функций](../udf/list/histogram.md).

Если разброс входных значений неконтролируемо велик, рекомендуется указывать минимальное и максимальное значение для предотвращения потенциальных падений из-за высокого потребления памяти.

**Примеры:**
``` yql
SELECT
    LogarithmicHistogram(numeric_column, 2)
FROM my_table;
```

## BOOL_AND и BOOL_OR

Применение соответствующей логической операции (`AND / OR`) ко всем значениям булевой колонки или выражения.
Логика работы эквивалентна функциям Python `all()` и `any()` соответственно.

**Примеры:**
``` yql
SELECT
  BOOL_AND(bool_column),
  BOOL_OR(bool_column)
FROM my_table;
```

## BIT_AND, BIT_OR и BIT_XOR

Применение соответствующей битовой операции ко всем значениям числовой колонки или выражения.

``` yql
SELECT
  BIT_XOR(unsigned_numeric_value)
FROM my_table;
```
{% if yt %}
## UDAF

Если по каким-то причинам перечисленных выше агрегатных функций оказалось недостаточно, в YQL имеется механизм описания пользовательских агрегатных функций. Подробнее [см. в отдельной статье](../guides/udaf.md).
{% endif %}
