# Использование диагностического дашборда

В разделе даны рецепты диагностики типовых проблем в работе базы данных. Для диагностики используются графики, собранные на [диагностическом дашборде в Соломоне](../maintenance/monitoring.md#diagnostics).

## Поиск перегруженных шардов {#overloaded-shards}

Как правило, в обработке каждого запроса к базе данных участвуют один или больше шардов таблиц. Подробнее про [шардирование таблиц](../concepts/datamodel#sharding) можно узнать из раздела [{#T}](../concepts/datamodel.md).

Каждому шарду для обработки запросов доступно не более одного ядра. Нагрузка, приводящая к потребленияю выделенного ядра на 90% и более процентов может приводить к ухудшению времени выполнения запросов. На графике CPU Utilization диагностического дашборда показано количество шардов таблиц, загрузка которых превысила 70%. Количество шардов разложено по корзинам в соответствии с мгновенным потреблением выделенного ядра:

* 70% - 80%;
* 80% - 90%;
* 90% - 100%.

На рисунке 1 показан примерный вид графика CPU Utilization для базы с перегруженными шардами

![Monitoring_CPU_Utilization_Chart](../_assets/monitoring_cpu_utilization_chart.png)

<small>Рисунок 1 — примерный вид графика использования CPU шардами таблиц базы</small>

Из графика видно, что около 04:05 в рассматриваемой базе данных было несколько шардов, попавших в корзину 90% - 100% по использованию CPU.

Повышенное (больше 90%) потребление CPU шардом, свидетельствует о близости потока запросов к максимальной пропусной способности шарда. Такая ситуация может привести к росту времени выполнения запросов к базе и росту очередей выполнения запросов.

Так как размеры очередей запросов в системе ограничены, после достижения установленного ограничения, все запросы с участием перегруженных шардов будут заканчиваться ошибкой. Подробнее мониторинг размеров очередей описан разделе [Размеры очередей](diag_dashboard.md#queues).

{% note warning %}

Ситуации повышенного потребления критична и требует скорейшего разбирательства.

{% endnote %}

### Типичные причины перегрузки

**Большие выборки**

При выполнении YQL-запроса шарды таблиц YDB читают данные с [групп хранения](https://ydb.yandex-team.ru/docs/concepts/databases#gruppy-hraneniya-(storage-groups)) и выполняют вычисления. Для каждого шарда существует максимальная пропускная способность, которую можно измерить в количестве прочитанных строк в единицу времени. Ситуации, в которых на шард поступает поток запросов, близкий к его пропускной способности, приводят к высокому потреблению CPU шардом. Таких ситуаций следует избегать.

Наиболее вредны запросы, не использующие индексы и просматриваюшие все строки таблицы. Количество ресурсов и времени, необходимое для выполнения такого запроса, растёт линейно или круче с ростом количества строк в таблице.

Чтобы убедиться в отсутствии запросов, нагружающих шарды таблицы широкими выборками, можно воспользоваться следующим алгоритмом:

1. Найти таблицу с перегруженными шардами
1. С помощью [системных таблиц](system_views.md) уточнить скорость чтения для данной таблицы, пример запроса приведён на листинге 2.
1. Проанализировать запросы к этой таблице: убедиться, что нет запросов, сканирующих все строки и запросов, читающих большие диапазоны (больше тысячи строк).

Подробнее анализ плана выполнения запросов описан в разделе [Использование консольного клиента YDB](../getting_started/ydb_cli.md#explain_plan).

```sql
use ydb_ch;

SELECT
    Path,
    PartIdx,
    RangeReadRows,
    RowReads,
    RowCount,
    cast(RangeReadRows/RowCount as UInt64) as AvgRangeReadPerRow,
    cast((RowReads / RowCount) as UInt64) as AvgReadPerRow,
    cast((RangeReadRows + RowReads) / (toUnixTimestamp(now()) - StartTime/1000000) as UInt64) as ReadRowsPerSecond
FROM
    ydbTable('ru-prestable', '/ru-prestable/metrika/testing/visits', '.sys/partition_stats')
ORDER BY RangeReadRows DESC
LIMIT 20
```
<small>Листинг 2 — Пример запроса для оценки количества читаемых шардами строк.</small>

В случае обнаружения запросов, сканирующие все строки таблицы или слишком большие диапазоны, следует переработать такие запросы.

**Горячий шард**

Высокое потребление CPU шардом таблицы может быть связано с тем, что все записи попадают в один шард. Это может быть вызвано неоптимальным выбором первичного ключа. Например, в случае монотонного возрастания его значений, все записи будут попадать в последний шард. Подробнее рекомендации по проектированию первичного ключа описаны в разделе [{#T}](../best_practices/schema_design.md).

## Нехватка CPU {#cpu-shortage}

На рисунке 2 приведён пример графика User Pool CPU Utilization %, показывающий долю использованию CPU, выделенного процессам базы для обработки пользовательских запросов. Потребление каждого процесса на графике показано отдельной линией. При утилизации каким-либо из процессов больше 80% выделенного CPU возможны ухудшения во времени обработки запросов.

![Diag_Dashboard_UserPool_Utilization_Chart](../_assets/diag_dashboard_userpool.png)

<small>Рисунок 2 — примерный вид графика использования CPU в UserPool процессами базы</small>

Если у базы данных наблюдается систематический недостаток CPU, следует оформить [заявку на квоту](../concepts/quotas_and_limits.md#request_qouta) в YDB и на изменение конфигурации базы [с помощью формы](https://forms.yandex-team.ru/surveys/30510/).

## Нехватка памяти {#memory-shortage}

На рисунке 3 показан примерный вид графика выделения памяти процессами, обслуживающими базу данных. Размер памяти, доступной процессу, обслуживающему базу, ограничен настройками cgroup и составляет 50 Гб. На этот график стоит обратить внимание, если на нём наблюдаются регулярные падения линий до нуля и резкий рост. Такой график с высокой вероятностью иллюстрирует нехватку памяти, приводящую к принудительному завершению процесса базы по Out of Memory.

![Diag_Dashboard_Node_Memory_Chart](../_assets/diag_dashboard_nodes_memory.png)

<small>Рисунок 3 — примерный вид графика выделения памяти процессами базы</small>

Частые перезапуски процессов, обслуживающих базу, приведут к росту доли [ошибочных ответов](../api/error_handling.md#statusy-zaversheniya-ydb) `Unavailable`, что в свою очередь приведёт к росту доли ошибок в ответах приложения пользователю или к росту времени выполнения запросов.

Одной из возможных причин выского потребления памяти могут быть запросы к базе, читающие много данных. Для проверки такой гипотезы следует использовать системные таблицы. Пример запроса, который выводит top запросов по размеру прочитанных данных, приведён на листинге 3.

```sql
use ydb_ch;

SELECT
    QueryText,
    ReadBytes/10000000 as ReadMegabytes
FROM
    ydbTable('ru-prestable', '/ru-prestable/tutorial/home/testdb', '.sys/top_queries_by_read_bytes_one_hour')
ORDER BY ReadBytes DESC
LIMIT 20
```
<small>Листинг 3 — Пример запроса к системным  таблицам для поиска  запросов, читающих больше всех данных.</small>

В результате выполнения запроса к системным таблицам могут быть обнаружены запросы к базе, читающие больше сотен мегабайт данных. Стоит исследовать такие запросы.

Если у базы данных наблюдается систематический недостаток доступной памяти, следует увеличить количество [вычислительных ресурсов](../concepts/databases.md#compute_units), доступных базе. Для этого нужно оформить [заявку на квоту](../concepts/quotas_and_limits.md#request_qouta) в YDB и на изменение конфигурации базы [с помощью формы](https://forms.yandex-team.ru/surveys/30510/).

## Запросы, закончившиеся ошибкой {#request-errors}

На диагностическом дашборде количество запросов в единицу времени, закончившихся ошибкой, можно определить по двум графикам:

* Query Error Responses – Hard Errors (Non-Retriable) - отображает ошибки, в ответ на которые нельзя повторять запрос и следует найти и устранить причину возникновения ошибки;
* Query Error Responses – Soft Errors (Retriable) - отображает ошибки, в ответ на которые приложению следует повторит запрос с выбранной политикой задержки.

Подробно коды ответов, возвращаемые в результате выполнения запроса, описаны в документе [{#T}](../api/error_handling.md).

## Блокировки {#locks}

На графике Transaction Locks Invalidation отображено количество транзакций в секунду, выполнение которых закончилось ошибокой `Transaction locks invalidated`, (TLI) – являющейся результатом нарушения [оптимистических блокировок](https://en.wikipedia.org/wiki/Optimistic_concurrency_control). Доступные режимы транзакций и блокировки рассмотрены в разделе [{#T}](..//concepts/transactions.md).

Ситуации, в которых доля запросов, закончившихся ошибкой `Transaction locks invalidated`, превышает доли процента, является ненормальной и требует улучшения. Для поиска причины высокой доли нарушения  блокировок можно воспользоваться следующим алгоритмом:

1. Журналировать полный текст ошибки, возвращаемый YDB в ответ на запрос, закончившийся ошибкой `Transaction locks invalidated`. В Issues, возвращаемых с таким ответом, будет указано имя таблицы, нарушение блокировок на которой привело к ошибке.
2. После определения таблиц, транзакции над которыми завершаются ошибкой наиболее часто, следует изучить запросы к таким таблицам. Как правило причиной ошибки `Transaction locks invalidated` служат чтения широких диапазонов в транзакции или изменение одних и тех же ключей в разных транзакциях.

Запросы, читающие широкие диапазоны,  можно разбить на несколько независимых транзакций или, если это допускает логика приложения, изменить режим выполнения транзакции на один из доступных режимов, в котором не создаются блокировки, например `Online Read-Only`. Подробнее режимы выполнения транзакции рассмотрены в разделе [{#T}](..//concepts/transactions.md).

В случае выявления ключей, подвергающихся одновременному изменению из разных транзакций со скоростью, превышающей сотни запросов в секунду, следует рассмотреть варианты изменения шаблона доступа к горячим ключам. Например, строго упорядочить изменения на стороне приложения.

На графике Whole shard locks отображено, количество событий установки оптимистической блокировки на все ключи шарда в единицу времени. Наличие любого количество блокировок целого шарда является очень тревожным признаком и должно быть исследовано.


{% note warning "Блокировка всех ключей шарда" %}

Запросы, затрагивающие на одном шарде больше 16 000 ключей, приводят к установке блокировок на весь шард целиком.

{% endnote %}


## Размеры очередей {#queues}

### Размер очереди grpc-сервера

На графике Queues – GRPC Server inflight показано количество запросов, находящихся в обработке на уровне  grpc-сервера, т.е. на входе в базу данных. Максимальное количество запросов в полёте на уровне grpc-cервера ограничено 1000 для каждого из [слотов](../concepts/databases.md#compute_units). Запросы к слотам, у которых уже есть 1000 запросов в полёте, будут заканчиваться ошибкой `CLIENT_RESOURCE_EXHAUSTED`. Причиной роста очереди может быть недостаток вычислительных ресурсов для обработки входящего потока запросов.

В такой ситуации следует увеличить количество [вычислительных ресурсов](../concepts/databases.md#compute_units), доступных базе. Для этого нужно оформить [заявку на квоту](../concepts/quotas_and_limits.md#request_qouta) в YDB и на изменение конфигурации базы [с помощью формы](https://forms.yandex-team.ru/surveys/30510/).

Также причиной роста очередей на входе в систему могут служить запросы, выполнение которые занимает больше времени, чем интервал между поступлением таких запросов в систему.

Для поиска медленных запросов рекомуендуется использовать [{#T}](system_views.md).

### Размер очереди immediate транзакций на шардах

На графике Queues – Datashard ImmediateTx Inflight показано количество immediate транзакций, находящихся в исполнении в момент времени на всех шардах базы данных. Immediate транзакции не требуют координации и затрагивают один шард базы. Количество одновременно исполняемых immediate транзакции для каждого шарда ограничено 10 000. В случае превышения установленного огранчиения, транзакции будут завершаться с ошибкой `OVERLOADED`.

Для поиска медленных запросов рекомуендуется использовать [{#T}](system_views.md).

На листинге 4 приведён пример запроса к [системным таблицам](system_views.md), возвращающий запросы, затрагивающие 1 шард, отсортированные по количеству прочитанных строк в порядке убывания.

```sql
use ydb_ch;

SELECT
    QueryText, Rank,
    ReadRows
FROM
    ydbTable('ru-prestable', '/ru-prestable/tutorial/home/testdb', '.sys/top_queries_by_read_bytes_one_hour')
WHERE
    Partitions = 1
ORDER BY ReadRows DESC
LIMIT 20;
```

<small>Листинг 4 — запрос к системным таблицам для поиска одношардовых запросов.</small>

### Размер очереди планируемых транзакций на шардах

На графике Queues – Datashard Transaction Completion Lag в милисекундах показана сумма интервалов отставания времени выполнения планируемых транзакций на шардах от времени планирования на координаторе. Наличие редких запросов с отставанием в десятки секунд и больше, свидетельствует о наличии медленных запросов от приложения к базе.

Для поиска медленных запросов рекомуендуется использовать [{#T}](system_views.md).

Плохим признаком является наличие монотонно растущего отставания на данном графике. Такая ситуация свидетельствует о появлении планируемых транзакций, которые не успевают выполняться до поступления в систему новых транзакций такого вида. Причиной такой ситуации может служить появление медленных запросов или недостаток вычислительных ресурсов для обработки входящего потока запросов.

В такой ситуации следует увеличить количество [вычислительных ресурсов](../concepts/databases.md#compute_units), доступных базе. Для этого нужно оформить [заявку на квоту](../concepts/quotas_and_limits.md#request_qouta) в YDB и на изменение конфигурации базы [с помощью формы](https://forms.yandex-team.ru/surveys/30510/).
