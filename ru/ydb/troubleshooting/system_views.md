# Системные таблицы

Для возможности внутренней интроспекции состояния базы данных пользователю предоставляется возможность осуществлять запросы в специальные служебные таблицы (system views). Эти таблицы доступны из корня дерева базы данных и используют системный префикс пути `.sys`.
{% if audience != "external" %}

В настоящее время доступ к системным таблицам возможен только через [ClickHouse over YDB](../getting_started/start_chydb.md). Примеры запросов далее приведены в синтаксисе ClickHouse. Для обращения к системным таблицам следует использовать табличную функцию `ydbTable`, например: `ydbTable('cluster_name', '/path/to/database', '.sys/system_view_name')`.
{% endif %}

В описаниях доступных полей далее по тексту колонка **Ключ** содержит индекс поля первичного ключа соответствующей таблицы.

{% note info %}

Поля с типами Timestamp и Interval при запросах через СlickHouse over YDB будут представлены типами Uint64 и Int64 (микросекунды) соответственно.

{% endnote %}

----

## Партиции таблиц

* **partition_stats**

Системная таблица, предоставляющая детализированную информацию об отдельных партициях всех таблиц базы данных. Содержит информацию о моментальных метриках, таких как нагрузка на CPU или количество транзакций в полёте, а также кумулятивные счётчики операций различного характера над партицией (например, общее количество прочитанных строк). Предназначена в первую очередь для выявления различных неравномерностей в нагрузке на партицию таблицы или размерах данных партиции таблицы.

Структура таблицы partition_stats:

| **Поле** | **Тип** | **Ключ** | **Значение** |
|---|---|---|---|
| OwnerId | Uint64 | 0 | Идентификатор скимшарда, обслуживающего таблицу
| PathId | Uint64 | 1 | Идентификатор пути в скимшарде
| PartIdx | Uint64 | 2 | Порядковый номер партиции
| DataSize | Uint64 | | Приблизительный размер партиции в байтах
| RowCount | Uint64 | | Приблизительное количество строк
| IndexSize | Uint64 | | Размер индекса партиции в таблетке
| CPUCores | Double | | Моментальное значение нагрузки на партицию (доля ядра)
| TabletId | Uint64 | | id таблетки, обслуживающей партицию
| Path | Utf8 | | Полный путь к таблице
| NodeId | Uint32 | | id ноды, на которой в данный момент обслуживается партиция
| StartTime | Timestamp | | Последний момент запуска таблетки, обслуживающей партицию
| AccessTime | Timestamp | | Последний момент чтения из партиции
| UpdateTime | Timestamp | | Последний момент записи в партицию
| RowReads | Uint64 | | Количество точечных чтений с момента старта таблетки партиции
| RowUpdates | Uint64 | | Количество записанных строк с момента старта
| RowDeletes | Uint64 | | Количество удалённых строк с момента старта
| RangeReads | Uint64 | | Количество чтений диапазонов строк с момента старта
| RangeReadRows | Uint64 | | Количество строк, прочитанных в диапазонах с момента старта
| InFlightTxCount | Uint64 | | Количество транзакций к партиции в моменте
| ImmediateTxCompleted | Uint64 | | Количество завершившихся одношардовых транзакций с момента старта
| PlannedTxCompleted | Uint64 | | Количество завершившихся координируемых транзакций с момента старта
| TxRejectedByOverload | Uint64 | | Количество транзакций, отменённых по причине слишком высокой нагрузки (с момента старта)
| TxRejectedBySpace | Uint64 | | Количество транзакций, отменённых из-за нехватки места (с момента старта)

Ограничения:

* кумулятивные поля (RowReads, RowUpdates и т.д.) хранят накопленные значения с момента последнего старта таблетки, обслуживающей партицию

Примеры запросов:

Топ-5 самых загруженных партиций среди всех таблиц базы данных:
```sql
SELECT
    Path,
    PartIdx,
    CPUCores
FROM
    ydbTable('cluster_name', '/path/to/database', '.sys/partition_stats')
ORDER BY CPUCores DESC
LIMIT 5
```
Список таблиц базы с размерами и нагрузкой в моменте:
```sql
SELECT
    Path,
    COUNT() as Partitions,
    SUM(RowCount) as Rows,
    SUM(DataSize) as Size,
    SUM(CPUCores) as CPU
FROM
    ydbTable('cluster_name', '/path/to/database', '.sys/partition_stats')
GROUP BY Path
```

----

## Информация о запросах

Группа системных таблиц для анализа потока пользовательских запросов. Таблицы позволяют видеть ограниченную по времени историю запросов, разбитую на интервалы. В пределах одного интервала времени сохраняется топ-5 запросов по определённой характеристике. В настоящее время доступны минутные и часовые интервалы, а топ может быть построен по полному времени исполнения запроса (самые медленные) и по количеству прочитанных из таблицы байт (самые широкие). Таблицы предназначены в первую очередь для поиска узких мест производительности в пользовательской нагрузке.

Различные запуски запроса с одним и тем же текстом дедуплицируются. Топ содержит информацию о конкретном запуске с максимальным значением соответствующей характеристики запроса в пределах одного временного интервала.

Названия таблиц:

* **top_queries_by_duration_one_minute**
* **top_queries_by_duration_one_hour**
* **top_queries_by_read_bytes_one_minute**
* **top_queries_by_read_bytes_one_hour**

Структура таблиц:

| **Поле** | **Тип** | **Ключ** | **Значение** |
|---|---|---|---|
| IntervalEnd | Timestamp | 0 | Момент закрытия минутного или часового интервала
| Rank | Uint32 | 1 | Ранг запроса в топе
| QueryText | Utf8 | | Текст запроса
| Duration | Interval | | Полное время исполнения запроса
| EndTime | Timestamp | | Момент окончания исполнения запроса
| ReadRows | Uint64 | | Количество прочитанных строк
| ReadBytes | Uint64 | | Количество прочитанных байт
| UpdateRows | Uint64 | | Количество записанных строк
| UpdateBytes | Uint64 | | Количество записанных байт
| DeleteRows | Uint64 | | Количество удалённых строк
| DeleteBytes | Uint64 | | Количество удалённых байт
| Partitions | Uint64 | | Количество партиций таблиц, участвовавших в обработке запроса
| UserSID | String | | Security ID пользователя
| ParametersSize | Uint64 | | Размер параметров запроса в байтах
| CompileDuration | Interval | | Длительность компиляции запроса
| FromQueryCache | Bool | | Использовался ли кэш подготовленных запросов

Ограничения:

* текст запроса ограничен 4 килобайтами;
* таблицы с поминутными интервалами содержат историю за последние 6 часов;
* таблицы c почасовыми интервалами содержат историю за последние 2 недели;
* предоставляемая информация волатильна и может быть обнулена при рестартах нод.

Персистентное хранение истории запросов включено в ближайшие планы разработки.

Примеры запросов:

Топ запросов по времени выполнения за последнюю минуту, когда случались запросы:
```sql
SELECT
    IntervalEnd,
    Rank,
    QueryText,
    Duration
FROM ydbTable('cluster_name', '/path/to/database', '.sys/top_queries_by_duration_one_minute')
WHERE IntervalEnd = (
    SELECT
        MAX(IntervalEnd)
    FROM ydbTable('cluster_name', '/path/to/database', '.sys/top_queries_by_duration_one_minute')
);
```
Запросы, прочитавшие больше всего байт, в разбивке по минутам:
```sql
SELECT
    IntervalEnd,
    QueryText,
    ReadBytes,
    ReadRows,
    Partitions
FROM ydbTable('cluster_name', '/path/to/database', '.sys/top_queries_by_read_bytes_one_minute')
WHERE Rank = 1
```

----

## Ноды

**nodes**

Информация о нодах, обслуживающих базу данных.

Структура таблицы nodes:

| **Поле** | **Тип** | **Ключ** | **Значение** |
|---|---|---|---|
| NodeId | Uint32 | 0 | Идентификатор ноды
| Address | String | | IP адрес
| Host | String | | Имя хоста
| Port | Uint32 | | Порт интерконнекта
| StartTime | Timestamp | | Последний момент запуска ноды
| UpTime | Interval | | Время с момента запуска ноды

Примеры:

Суммарная нагрузка на таблицы, сгруппированная по нодам:
```sql
SELECT
    NodeId,
    Host,
    Port,
    CPUCores
FROM (
    SELECT
        NodeId,
        SUM(CPUCores) as CPUCores
    FROM ydbTable('cluster_name', '/path/to/database', '.sys/partition_stats')
    GROUP BY NodeId
) JOIN (
    SELECT
        NodeId,
        Host,
        Port
    FROM ydbTable('cluster_name', '/path/to/database', '.sys/nodes')
) USING NodeId
ORDER BY CPUCores DESC
```

----

## Замечания

Следует иметь в виду, что обращение к системным таблицам имеет скорее аналитический характер нагрузки, и поэтому частое обращение к ним в больших базах будет существенно расходовать системные ресурсы. Нагрузка порядка 1 rps вполне допустима.
