# Запуск запросов на YQL по расписанию

## Введение {#introduction}
Пока в YQL нет встроенного или тесно интегрированного способа запускать запросы регулярно, здесь будут собраны рецепты, как этого можно добиться доступными на сегодняшний день инструментами.

## Crontab {#crontab}
Справедливости ради, начнем с самого очевидного и простого, но не отличающегося надежностью способа (из-за чего мы его НЕ рекомендуем):

1. Берем [консольный клиент YQL](../interfaces/cli.md).
2. Пишем скрипт-обертку на bash или любом другом языке программирования, смысл действий которого сводится к: `./yql -i query.sql -o results.tsv`
3. Cохраняем этот скрипт в `/etc/cron.***ly` на любом стабильно работающем сервере или добавляем в crontab любым другим способом.
4. Для пользователя, от имени которого он будет запускаться, кладем [YQL-токен](https://yql.yandex-team.ru/?settings_mode=token) (можно не свой, а [роботный](https://wiki.yandex-team.ru/DIY/zombik#zavestirobota)) в `~/.yql/token` .

## Sandbox {#sandbox}
В [Sandbox](/sandbox/) есть инфраструктура, позволяющая настроить регулярный запуск запросов на YQL, не покидая браузера:

* Тип задач (task) RUN_YQL, который позволяет запускать запросы на YQL.
* Механизм запуска задач по расписанию (scheduler).
* Безопасное хранилище (vault), куда можно положить свой (или [роботный](https://wiki.yandex-team.ru/DIY/zombik#zavestirobota)) YQL-токен.

!!! info "Статус задачи**"
    Чтобы не тратить ресурсы sandbox на ожидание выполнения запроса, задача не дожидается его окончания. То есть статус задачи <span style="color:green;">SUCCESS</span> означает лишь, что соединение с YQL удалось и операция началась. Получить статус и результат запущенных запросов сейчас можно или [средствами консольного клиента](../interfaces/cli.md), или просто по данным в целевой таблице, если запрос заканчивался `INSERT INTO` (что для регулярных запросов в любом случае рекомендуется использовать).

Можно подписаться на уведомления о завершении выполнения операции на почту/jabber/sms/telegram в настройках YQL (см. инструкцию по [консольному клиенту](../interfaces/cli.md#uvedomlenijaozaversheniioperacijj) или [веб-клиенту](../interfaces/web.md#nastrojjki)).</blockquote>

### Cохранение токена {#save-token}

Эту операцию достаточно выполнить **один раз**. Сохраненный токен можно затем использовать для любого количества регулярных запросов.


1. [Получаем YQL-токен](https://yql.yandex-team.ru/?settings_mode=token) (для [роботного](https://wiki.yandex-team.ru/DIY/zombik#zavestirobota) — предпочтительно получть токен в инкогнито-режиме браузера и затем залогиниться под именем роботного пользователя);
2. Идем на [страницу управления хранилищами](https://sandbox.yandex-team.ru/admin/vault) (vault);
3. В окошке, всплывающем по нажатию на «Create record», заполняем:

  * Owner — выбираем свой логин;
  * Name — `YQL_TOKEN` (обязательно именно так);
  * Secret note — значение YQL-токена;
4. По нажатию на «Create vault» хранилище YQL_TOKEN должно появиться в списке, после чего можно перейти к следующему разделу.

### Настройка запуска запроса по расписанию {#setting-up-a-scheduled-request-launch}

1. Заходим на <https://sandbox.yandex-team.ru/schedulers> , жмём «Create scheduler», в появившемся всплывающем окне выбираем RUN_YQL.
2. Заполняем форму на свой вкус, некоторые рекомендации:

  * Если по названию поля не очевидно его назначение, как правило, стоит оставить в этом поле значение, выставленное по умолчанию.
  * Description зачем-то обязательно требуют, но никто не мешает поставить в нем прочерк.
  * В поле Owner обязательно должно быть выбрано ровно то же самое, что и при создании хранилища с токеном, как правило, это просто логин.
  * В поле с запросом (YQL Query) можно использовать простые placeholder'ы, которые будут заменены на соответствующие значения на клиенте перед отправкой в YQL (при необходимости можно добавить и других, пишите на yql@):
``` python
{
    '%YEAR%': now.year,
    '%MONTH%': '%02d' % now.month,
    '%DAY%': '%02d' % now.day,
    '%HOUR%': '%02d' % now.hour,
    '%MINUTE%': '%02d' % now.minute,
    '%SECOND%': '%02d' % now.second,
    '%UTC_YEAR%': utc_now.year,
    '%UTC_MONTH%': '%02d' % utc_now.month,
    '%UTC_DAY%': '%02d' % utc_now.day,
    '%UTC_HOUR%': '%02d' % utc_now.hour,
    '%UTC_MINUTE%': '%02d' % utc_now.minute,
    '%UTC_SECOND%': '%02d' % utc_now.second,
    '%YESTERDAY_YEAR%': yesterday.year,
    '%YESTERDAY_MONTH%': '%02d' % yesterday.month,
    '%YESTERDAY_DAY%': '%02d' % yesterday.day,
    '%TWO_DAYS_AGO_YEAR%': two_days_ago.year,
    '%TWO_DAYS_AGO_MONTH%': '%02d' % two_days_ago.month,
    '%TWO_DAYS_AGO_DAY%': '%02d' % two_days_ago.day,
    '%TIMESTAMP%': int(time.mktime(now.timetuple())),
    '%USER%': self.owner,
    '%OWNER%': self.owner
}
```
    * В задаче можно указать свои собственные подстановки, их необходимо добавить в поле "custom placeholders" в формате "%PLACEHOLDER% – значение подстановки". Обязательное требование – placeholder должен начинаться и заканчиваться символом "%".

3. По нажатию на «Schedule» в конце формы запустится регулярный процесс, который будет выполнять запуск YQL-запросов по расписанию. За запусками можно следить в веб-интерфейсе Sandbox на вкладке «Generated tasks» или средствами YQL (см. команды SHOW OPERATIONS и HISTORY в [инструкции по консольному клиенту YQL](https://wiki.yandex-team.ru/yql/userguide/cli/#asinxronnoevypolnenie)).

## Nirvana {#nirvana}
Пошаговой инструкции пока нет, но в стандартном образе системы на [Nirvana](https://wiki.yandex-team.ru/JandeksPoisk/Nirvana/manual) установлены deb-пакеты с [консольным клиентом](../interfaces/cli.md) и [Python клиентской библиотекой](../interfaces/python.md) YQL, что позволяет создавать использующие их ["кубики"](https://wiki.yandex-team.ru/JandeksPoisk/Nirvana/vodstvo/Glossarijj/#t.n.kubik) в Job Processor.

Затем можно настроить регулярный запуск кубиков:

1. Через [Hitman](https://hitman.yandex-team.ru), [документация](https://wiki.yandex-team.ru/hitman/nirvana/)
2. Либо через [FML](https://fml.yandex-team.ru), [документация](https://wiki.yandex-team.ru/JandeksPoisk/Nirvana/manual/#addregular).

Также в Hitman есть отдельная ограниченная поддержка запуска YQL операций, [документация](https://wiki.yandex-team.ru/hitman/nirvana/yql).

## Тестирование {#test}
Есть вероятность, что очередной релиз YQL может сломать регулярно запускаемый процесс, который, возможно, является частью production-процесса. Ниже перечислены меры, которые можно предпринять, чтобы минимизировать связанные с этим риски.

### Локальные регрессионные тесты {#local-regression-tests}
В Аркадии есть возможность писать тесты на YQL-запросы с канонизацией результата и использованием в роли входа небольших таблиц c разделителями. Изначально эта возможность была реализована для тестирования самих С++ UDF, но можно использовать эту инфраструктуру для тестирования не UDF, а самого запроса, если использовать стандартные UDF или не использовать их вовсе. [Инструкция](../udf/cpp.md#arkadijjnyeregressionnyeavtotestycherezyamake-t).

Общая схема работы тестов с канонизацией результата на С++ UDF:

* пишется запрос с использованием UDF;
* рядом кладется файл, содержимое которого будет использовано в качестве входной таблицы;
* запрос запускается над этой таблицей и результат фиксируется рядом в репозитории;
* если затем какой-то другой коммит в репозиторий приведет к тому, что результат будет отличаться от зафиксированного или запрос вовсе начинет падать, — тест будет помечен как сломанный и всем причастным рассылаются письма.

### Тесты на реальных кластерах {#tests-on-real-clusters}
В рамках системы continuous integration (перед релизом YQL и не только) запускается набор запросов на реальных кластерах с использованием на входе таблиц относительно большого объема.
Рекомендуется создать свою директорию в Аркадии [вот здесь](https://a.yandex-team.ru/arc/trunk/arcadia/yql/queries) по аналогии c существующими, либо где-то в своей части Аркадии, а затем написать на [yql@](https://ml.yandex-team.ru/lists/yql) с просьбой добавить её в список регулярно запускаемых.

Из возможных вариантов расположения файлов:

1. Запросы могут лежать в текстовых файлах сразу в корне директории (как в examples). В этом случае имя файла используется в роли имени теста. В запросах нельзя использовать функциональность по прикладыванию файлов к запросу.
2. В корне директории могут лежать поддиректории, имена которых используется в роли имени теста. Внутри должен располагаться файл run.sql, а все остальные файлы прикладываются к запросу. Если у имени прикладываемого файла есть суффикс `.url`, то он прикладывается в режиме URL, то есть выполняется попытка использовать содержимое как адрес для скачивания.

Из возможных критериев успеха:

1. Непустой результат.
2. Совпадение с заранее сохраненным результатом (канонизация результата).
3. Канонизация результата после постобработки функцией на Python (можно выкинуть что-то моргающее).

<blockquote>Чтобы тесты с канонизацией результата работали, результат запроса должен быть полностью детерменированным между повторными запусками. Если это не так, то при запуске на каждый коммит в репозиторий тесты очень часто меняют свой статус с зеленого на красный и обратно, что по-русски называют «морганием», а по-английски — flaky test. В некоторых случаях от этого можно избавиться постобработкой результата: например, если в запросе какой-то приближенный алгоритм возвращает то 1.23456, то 1.23789, то можно округлять до одного знака после запятой и считать успехом, что получилось 1.2.</blockquote>

Все тесты на реальных кластерах НЕ участвуют в автосборке и письма не приходят, но их красный цвет в большинстве случаев является блокером к релизу YQL. Время выполнения теста должно быть в пределах пары часов.

Если у вас есть предложения по улучшению описанных выше механизмов тестирования или добавлению новых — тоже смело пишите на [yql@](https://ml.yandex-team.ru/lists/yql).
