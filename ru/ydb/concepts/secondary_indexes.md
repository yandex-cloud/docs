# Вторичные индексы

Этот раздел посвящен поддержке вторичных индексов в YDB.

В YDB автоматически создается индекс по первичному ключу, поэтому выборки с условием по первичному ключу всегда выполняются эффективно, затрагивая только требуемые строки. Выборка с условием наложенным на одну или несколько неключевых колонок как правило приводит к полному сканированию таблицы. Для того, чтобы такие выборки были эффективным нужно использовать вторичные индексы.

В текущей версии реализован глобальный вторичный индекс. Каждый индекс представляет собой скрытую таблицу, которая обновляется транзакционно при изменении основной таблицы. Когда пользователь присылает SQL-запрос на вставку/модификацию/удаление данных, база данных прозрачно для пользователя формирует команды на модификацию индексной таблицы на стадии компиляции запроса. Вторичных индексов у таблицы может быть несколько, и индекс может включать несколько колонок (при этом важен порядок указания колонок в индексе). А так же одна колонка может состоять в нескольких индексах, и даже быть одновременно частью первичного ключа и вторичного индекса.


##### Особености и ограничения
- Все модифицирующие транзакции над таблицей с индексом стали координируемыми. Для одношардовой таблицы без индекса есть возможность выполнить транзакцию (как читающую, так и слепую запись) в обход координатора, и таким образом ощутимо сократить задержки. Для записи в таблицу с индексом это не возможно, из-за необходимости обеспечивать согласованность данных — это неизбежная плата за возможность производить быстрое чтение без фулскана.
- UPSERTы в таблицу со вторичным индексом перестали быть слепыми. Из-за этого возникает ограничение на один UPSERT в транзакции над таблицей.
- Нет возможности создать индекс по существующим данным. Сейчас индекс должен быть создан при создании таблицы.
- Нет возможности удалить индекс не удаляя таблицу.


Более подробно примеры рассмотренны в разделе [Рекомендации - вторичные индексы](../best_practices/secondary_indexes.md).
