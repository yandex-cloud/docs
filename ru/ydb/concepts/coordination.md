---
sourcePath: overlay/concepts/coordination.md
---
# Сервис координации

Coordination Service позволяет координировать работу распределённых сервисов, предоставляя единую точку синхронизации. В настоящее время публично доступны распределённые семафоры (локи), которые кроме основной своей функции позволяют также покрыть следующие сценарии:

* Публикация очень небольших конфигурационных данных, с возможностью получать оповещения об их изменении
* Публикация очень небольших данных в очереди локов, давая service discovery, с возможностью получать оповещения об изменении списка владельцев
* Read/Write локи над заранее неизвестными сущностями (object-level locking)

## Основные понятия

Вся работа с Coordination Service производится в рамках Coordination Node (аналог таблицы), который необходимо предварительно создать:

```c++
#include <kikimr/public/sdk/cpp/client/ydb_coordination.h>

using namespace NYdb;
using namespace NYdb::NCoordination;

void CreateMyNode(TDriver& driver) {
    TClient client(driver);

    auto status = client
        .CreateNode("/path/to/mynode")
        .ExtractValueSync();
    Y_VERIFY(status.IsSuccess());
}
```

Разные Coordination Node никак не взаимодействуют друг с другом и полностью изолированы. При создании можно опционально указать `TNodeSettings` со следующими настройками:

* `SelfCheckPeriod` - периодичность с которой сервис производит проверки собственной живости (по умолчанию 1 секунда), не рекомендуется менять за исключением особых случаев:
  * Чем больше указанное значение, тем меньше нагрузка на сервер, но тем дольше возможная задержка между сменой лидера и тем, насколько оперативно об этом узнает сам сервис
  * Чем меньше указанное значение, тем больше нагрузка на сервер и большая оперативность в детектировании проблем, но возможна генерация false positive когда сервис ошибочно детектирует проблемы
* `SessionGracePeriod` - период, в течение которого новый лидер принудительно не закрывает имеющиеся открытые сессии, продлевая им жизнь (по умолчанию 10 секунд)
  * Чем меньше значение, тем меньше возможное окно, когда сессии от клиентов, которых уже не существует (и которые не успели сообщить о собственной пропаже во время смены лидера) будут держать захваченные семафоры и не давать захватить их другим клиентам
  * Чем меньше значение, тем больше вероятность false positive, когда живой лидер может самоубиться для перестраховки, т.к. не будет уверен что этот период ещё не закончился на возможном новом лидере
  * Должен быть строго больше, чем `SelfCheckPeriod`
* `ReadConsistencyMode` - по умолчанию `RELAXED`, но позволяет установить `STRICT` режим чтения, когда все чтения проходят через консенсус и гарантируют возврат самого свежего значения. Это делает все чтения существенно дороже, но зато избавляет от малейшей вероятности получить stale read в случае смены лидера.
* `AttachConsistencyMode` - по умолчанию `STRICT`, но позволяет установить `RELAXED` режим восстановления сессии в случае сбоев. Может потребоваться при очень большом кол-ве клиентов, позволяя восстанавливать сессию без прохождения через консенсус, что не влияет на общую корректность, но может усугублять stale read во время смены лидера, а также expire сессий в случае проблем.

Для работы с конкретным Coordination Node необходимо установить сессию:

```c++
TSession CreateMySession(TDriver& driver) {
    TClient client(driver);

    return client
        .StartSession("/path/to/mynode")
        .ExtractValueSync()
        .ExtractResult();
}
```

Установленная сессия в фоне поддерживает и автоматически переустанавливает связь с сервисом. Перед установлением сессии можно опционально указать `TSessionSettings` со следующими настройками:

* `Description` - текстовое описацие сессии, отображается во внутренних интерфейсах и может быть полезно при диагностике проблем
* `OnStateChanged` - вызывается на важных изменениях в процессе жизни сессии, передавая соответствующее состояние:
  * `ATTACHED` - сессия подключена и работает в нормальном режиме
  * `DETACHED` - сессия временно потеряла связь с сервисом, но ещё может быть восстановлена
  * `EXPIRED` - сессия потеряла связь с сервисом и не может быть восстановлена
* `OnStopped` - вызывается когда сессия прекращает попытки восстановить связь с сервисом, может быть полезна для установления нового соединения
* `Timeout` - максимальный таймаут, в течение которого сессия может быть восстановлена после потери связи с сервисом

Через объект сессии можно создавать новые семафоры и обновлять приаттаченные к ним данные:

```c++
void CreateUpdateMySemaphore(TSession session) {
    session
        .CreateSemaphore("my-semaphore", 5, "my-data")
        .ExtractValueSync()
        .ExtractResult();
    session
        .UpdateSemaphore("my-semaphore", "updated-data")
        .ExtractValueSync()
        .ExtractResult();
}
```

В приаттаченных к семафору данных можно хранить небольшую конфигурацию, и читать через вывозы `DescribeSemaphore`. При этом стоит отметить, что вызов `UpdateSemaphore` можно делать не владея семафором, т.е. если нужно гарантировать, что только один клиент обновляет эти данные - нужно сначала обеспечить взаимную блокировку, например через семафоры.

Семафоры можно захватывать, создавая критические секции:

```c++
void AcquireReleaseMySemaphore(TSession session) {
    // Гарантируется, что после успешного вызова только мы владеем семафором (пока жива наша сессия), т.к. мы захватываем 5 токенов из 5 (максимума, указанного при создании семафора)
    session
        .AcquireSemaphore(
            "my-semaphore",
            TAcquireSemaphoreSettings().Count(5))
        .ExtractValueSync()
        .ExtractResult();

    // Если мы владеем семафором, то повторным вызовом AcquireSemaphore мы можем понизить кол-во токенов, получая аналог shared lock'а
    session
        .AcquireSemaphore(
            "my-semaphore",
            TAcquireSemaphoreSettings().Count(1))
        .ExtractValueSync()
        .ExtractResult();

    // Вызовом ReleaseSemaphore можно отпустить ранее успешно захваченный семафор
    session
        .ReleaseSemaphore("my-semaphore")
        .ExtractValueSync()
        .ExtractResult();
}
```

Как можно видеть из примера вызовы `AcquireSemaphore` и `ReleaseSemaphore` по своей сути идемпотентны, т.е. `AcquireSemaphore` не является рекурсивным. Успешный `AcquireSemaphore` будет держать семафор так долго, как долго жива сессия. Например, гарантируется, что после успешного захвата семафора последующие вызовы в рамках сессии либо завершатся ошибкой (если сервер был не доступен в течение `Timeout` времени), либо будут успешно выполнены с захваченным семафором.

Захват семафора настраивается через `TAcquireSemaphoreSettings`:

* `Data` - можно к операции `AcquireSemaphore` приаттачить данные, которые можно прочитать через `DescribeSemaphore`, таким образом можно обеспечить service discovery (например сервисы в `Data` могут публиковать свой endpoint)
* `OnAccepted` - вызывается, когда операция встаёт в очередь (например если семафор невозможно было захватить сразу)
  * Не будет вызвано, если семафор закватывается сразу
  * Важно учитывать, что вызов может произойти параллельно с результатом `TFuture`
* `Count` - кол-во токенов, которые нужно захватить
* `Timeout` - максимальное время, в течение которого операция может пролежать в очереди на сервере
  * Операция вернёт `false`, если за время `Timeout` после добавления в очередь не удалось захватить семафор
  * При `Timeout` установленном в 0 операция по смыслу работает как `TryAcquire`, т.е. семафор будет либо захвачен атомарно и операция вернёт `true`, либо операция вернёт `false` без использования очередей
* `Ephemeral` - если `true` то имя является эфемерным семафором, такие семафоры автоматически создаются при первом `Acquire` и автоматически удаляются с последним `Release` - удобно если в качестве имени семафора используется какой-то заранее неизвестный object-id (например эксклюзивные блокировки над какими-то произвольными внешними объектами)
* `Shared()` - альяс для выставления `Count = 1`, захват семафора в shared режиме
* `Exclusive()` - альяс для выставления `Count = max`, захват семафора в exclusive режиме (для семафоров созданных с лимитом `Max<ui64>()`)

Наконец по семафорам можно получить данные через выхов `DescribeSemaphore`, опционально настраивая через `TDescribeSemaphoreSettings`:

* `OnChanged` - вызывается один раз после изменения данных на сервере (с параметром `bool`, если `true` - то вызов произошёл из-за каких-то изменений, если `false` - то это spurious вызов и необходимо повторить `DescribeSemaphore` для восстановления подписки)
* `WatchData` - вызывать `OnChanged` в случае изменения данных семафора
* `WatchOwners` - вызывать `OnChanged` в случае изменения владельцев семафора
* `IncludeOwners` - вернуть список владельцев в результатах
* `IncludeWaiters` - вернуть список ожидающих в результатах

Описание результатов:

* `Name` - имя семафора
* `Data` - данные семафора (могут меняться через `UpdateSemaphore`)
* `Count` - кол-во захваченных токенов на момент вызова
* `Limit` - максимальное кол-во токенов указанное при создании семафора
* `Owners` - список владельцев семафора
* `Waiters` - список ожидающих в очереди на семафоре
* `Ephemeral` - является ли семафор эфемерным

Описание полей `Owners`/`Waiters`:

* `OrderId` - порядковый номер операции захвата на семафоре (может использоваться для идентификации, например если `OrderId` изменился, значит сессия сделала `ReleaseSemaphore` и новый `AcquireSemaphore`)
* `SessionId` - идентификатор сессии, которая делала данный `AcquireSemaphore`
* `Timeout` - таймаут, с которым вызывался `AcquireSemaphore` для операций в очереди
* `Count` - кол-во токенов в `AcquireSemaphore`
* `Data` - данные, которые были указаны в `AcquireSemaphore`

## Важные особенности

Операции `AcquireSemaphore` и `ReleaseSemaphore` работают идемпотентно. Если на семафоре был вызван `AcquireSemaphore`, то повторные вызовы `AcquireSemaphore` лишь изменяют параметры захвата. Например, если вызвать `AcquireSemaphore` с `count=10` операция может быть добавлена в очередь. До или после успешного захвата можно вызывать `AcquireSemaphore` повторно с указанием `count=9`, таким образом уменьшив кол-во захваченных единиц, при этом новая операция заменит собой старую (которая завершится с кодом ABORTED, если операция ещё не была завершена успешно). Несмотря на замену одной операции `AcquireSemaphore` на другую позиция в очереди при этом не меняется.

Операции `AcquireSemaphore` и `ReleaseSemaphore` возвращают `bool`, по которому можно понять, изменила ли операция состояние семафора. Например, `AcquireSemaphore` может вернуть `false`, если семафор не удалось захватить в течение `Timeout` времени, т.к. он был захвачен кем-то другим. Операция `ReleaseSemaphore` может вернуть `false`, если семафор не захвачен в рамках текущей сессии.

Операцию `AcquireSemaphore`, которая стоит в очереди, можно завершить досрочно, вызвав `ReleaseSemaphore`. Независимо от кол-ва вызовов `AcquireSemaphore` для конкретного семафора в рамках одной сессии освобождение происходит одним вызовом `ReleaseSemaphore`, т.е. операции `AcquireSemaphore` и `ReleaseSemaphore` нельзя использовать в качестве аналога `Acquire`/`Release` на рекурсивном мьютексе.

Операция `DescribeSemaphore` с установленными флагами `WatchData` или `WatchOwners` создаёт подписку на изменение семафора. Любая более старая подписка на тот же семафор в рамках сессии отменяется, вызывая `OnChanged(false)`. Рекомендуется игнорировать `OnChanged` от предыдущих вызовов `DescribeSemaphore`, если делается новый замещающий вызов, например запоминая какой-либо текущий id вызова.

Важно учитывать, что вызов `OnChanged(false)` может происходить не только из-за отмены новым `DescribeSemaphore`, но и по самым разным причинам, например при временном разрыве соединения между grpc клиентом и сервером, при временном разрыве соединения между grpc сервером и текущим лидером сервиса, при изменении лидера сервиса, т.е. при малейшем подозрении, что нотификация могла быть каким-то образом потеряна. Код работы с coordination сервисом, для восстановления подписки, должен сделать новый вызов `DescribeSemaphore`, правильно обрабатывая ситуация, что результат нового вызова может оказаться другим (например, если нотификация действительно была потеряна).

## Основные сценарии

### Leader Election

В этом сценарии несколько воркеров хотят выбрать между собой лидера, при этом воркеры хотят в каждый момент времени знать текущего лидера.

* Создаётся семафор (например с именем `my-service-leader`) с `limit=1`
* Все воркеры делают `AcquireSemaphore` с `Count=1`, в `Data` указывая свой endpoint
* Только у одного воркера вызов завершится быстро, остальные встанут в очередь, тот у кого вызов завершился успешно - является текущим лидером
* Все воркеры делают `DescribeSemaphore` с `WatchOwners=true` и `IncludeOwners=true`, в результате вызова в `Owners` будет максимум один элемент, из `Data` узнаём endpoint текущего лидера
* В случае смены лидера вызывается `OnChanged` - в этом случае воркеры делают аналогичный вызов `DescribeSemaphore` и узнают нового лидера

### Service Discovery

В этом сценарии вокеры динамически поднимаются и публикуют свой endpoint, другие клиенты хотят получать этот список и реагировать на изменение списка.

* Создаётся семафор (например с именем `my-service-endpoints`) с `limit=Max<ui64>()`
* Все воркеры делают `AcquireSemaphore` с `Count=1`, в `Data` указывая свой endpoint
* Так как лимит семафора очень большой, все `AcquireSemaphore` должны завершиться быстро
* На этом публикация закончена и воркерам нужно только реагировать на останов сессии, публикуя себя заново через новую сессию

Клиенты, которые хотят получить список endpoint'ов:

* Делают `DescribeSemaphore` с `IncludeOwner=true` и опционально с `WatchOwners=true`, в результате вызова в `Owners` в поле `Data` будут endpoint'ы зарегистрированных воркеров
* В случае изменения списка endpoint'ов будет вызван `OnChanged` - в этом случае клиенты должны сделать аналогичный `DescribeSemaphore` и получить обновлённый список

### Конфигурация

В этом сценарии публикуется небольшая конфигурация воркеров, которые оперативно реагируют на её изменени

* Создаётся семафор (например с именем `my-service-config`)
* Через `UpdateSemaphore` публикуется обновлённые конфиги

Воркеры при этом:

* Делают `DescribeSemaphore` с `WatchData=true`, в результате вызова в `Data` будет текущая версия конфига
* В случае изменения конфига будет вызван `OnChanged` - в этом случае воркеры должны сделать аналогичный `DescribeSemaphore` и получить обновлённый конфиг
