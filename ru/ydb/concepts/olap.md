---
sourcePath: overlay/concepts/olap.md
---
Все подходы к выполнению аналитических запросов в БД KiKiMR сводятся к тому, чтобы взять снэпшот необходимых данных, и запустить асинхронную обработку не блокируя модификацию исходных таблиц. На данных момент существует два способа достичь такого поведения:

1. _CopyTable_. Данная операция выполняет копирование таблицы при помощи механизма [Copy-on-Write](https://en.wikipedia.org/wiki/Copy-on-write). При этом создается новая таблица, которая содержит консистентный снепшот данных исходной таблицы. Новая таблица может быть использована для разных целей, например, для бэкапа в сторонние системы, в том числе в [YT](/yt/). Бэкап в YT получается построчным, то есть результирующая таблица содержит исходные данные в формате YT и может быть использована для аналитики. Несмотря на то, что CopyTable копирует только метаданные, ее выполнение может занимать единицы секунд, на это время другие транзакции к исходной таблице будут заблокированы.

2. _ReadTable_. Данная операция позволяет консистентно прочитать таблицу. В ходе выполнения ReadTable фиксируется некоторое консистентное состояние, которое и читается пользователем. Чтение данных пользователем может быть блокирующее (все последующие записи встают в очередь) и неблокирующее. Наибольший интерес в подавляющем большинстве случаев представляет неблокирующее чтение, записи при этом продолжают выполняться, пользователю же доступен неменяющийся стейт. ReadTable является более дешевой операцией с точки зрения накладных расходов по сравнению с CopyTable, поэтому является предпочтительной. Также стоит отметить, что в отличие от CopyTable, результатом которой является изменяемая таблица, ReadTable "снимает" немодифицируемое состояние. Ограничения: ReadTable является более сложной операцией и в настоящее время реализована не в полном объеме.

Обе операции могут быть использованы для подключения сторонних систем выполнения запросов, которые будут использовать KiKiMR как хранилище данных.


### OLAP vs OLTP {#olap-vs-oltp}
В зависимости от пользовательских сценариев паттерны нагрузки на базу данных могут существенно отличаться. Принято выделять два паттерна -- [OLTP](https://en.wikipedia.org/wiki/Online_transaction_processing) и [OLAP](https://en.wikipedia.org/wiki/Online_analytical_processing). OLTP характеризуется большим потоком относительно легких транзакций таких как, например, покупка билетов. В ходе такой транзакции меняются несколько таблиц, например, количество свободных мест уменьшается, и добавляется запись о том, что человек с определенным именем совершил покупку. Каждая OLTP-транзакция обычно "трогает" относительно мало данных (используя ключи и/или индексы), но одновременно может работать много таких транзакций, в том числе конкурирующих между собой.
OLAP-транзакции характеризуются тем, что выполняют аналитику над большими данными, что, в свою очередь, выражается в full scan таблиц(ы). OLAP-транзакции зачастую выполняют сортировку и группировку данных. Типичным способом выполнения аналитики над большими данными в распределенной системе является парадигма [MapReduce](https://en.wikipedia.org/wiki/MapReduce).

YDB как платформа позволяет потенциально поддержать оба паттерна нагрузки. Однако в настоящее время YDB является скорее OLTP базой данных. Отличительной чертой YDB является реализация высокопроизводительного механизма выполнения распределенных транзакций на основе детерминистических транзакций (подробнее можно почитать [здесь](http://cs.yale.edu/homes/thomson/publications/calvin-sigmod12.pdf)). YDB была изначально спроектирована и построена с прицелом на распределенные транзакции, поэтому именно OLTP сценарий позволяет системе "раскрыться".

#### Ограничения OLTP сценария {#oltp-script-restrictions}
На самом деле разница между OLTP и OLAP условна. Например, full scan таблицы из 10 строк это OLAP? А запрос затрагивающий 0.1% петабайтной базы это OLTP? Формально YDB при выполнении запроса руководствуется другими критериями: участвующие в запросе данные должны быть загружены в память целиком, тогда запрос может быть выполнен с уровнем изоляции serializable. Если же оценка загружаемых данных превысит заданный порог, то запрос будет отвергнут, транзакция не будет выполнена и состояние базы не поменяется.

#### Текущие возможности для аналитики {#current-analytics-capabilities}
Все подходы к выполнению аналитических запросов в YDB сводятся к тому, чтобы взять снэпшот необходимых данных, и запустить асинхронную обработку не блокируя модификацию исходных таблиц. На данных момент существует два способа достичь такого поведения:

1. _CopyTable_. Данная операция выполняет копирование таблицы при помощи механизма [Copy-on-Write](https://en.wikipedia.org/wiki/Copy-on-write). При этом создается новая таблица, которая содержит консистентный снепшот данных исходной таблицы. Новая таблица может быть использована для разных целей, например, для бэкапа в сторонние системы, в том числе в [YT](https://wiki.yandex-team.ru/yt/). Бэкап в YT получается построчным, то есть результирующая таблица содержит исходные данные в формате YT и может быть использована для аналитики. Несмотря на то, что CopyTable копирует только метаданные, ее выполнение может занимать единицы секунд, на это время другие транзакции к исходной таблице будут заблокированы.
2. _ReadTable_. Данная операция позволяет консистентно прочитать таблицу. В ходе выполнения ReadTable фиксируется некоторое консистентное состояние, которое и читается пользователем. Чтение данных пользователем может быть блокирующее (все последующие записи встают в очередь) и неблокирующее. Наибольший интерес в подавляющем большинстве случаев представляет неблокирующее чтение, записи при этом продолжают выполняться, пользователю же доступен неменяющийся стейт. ReadTable является более дешевой операцией с точки зрения накладных расходов по сравнению с CopyTable, поэтому является предпочтительной. Также стоит отметить, что в отличие от CopyTable, результатом которой является изменяемая таблица, ReadTable "снимает" немодифицируемое состояние. Ограничения: ReadTable является более сложной операцией и в настоящее время реализована не в полном объеме.

Обе операции могут быть использованы для подключения сторонних систем выполнения запросов, которые будут использовать YDB как хранилище данных.
