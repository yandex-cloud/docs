---
sourcePath: overlay/concepts/out_of_order.md
---
# Порядок выполнения транзакций

Транзакции в YDB могут быть сложными и протяжёнными во времени, разбиваясь внутри на несколько атомарных операций над шардами. По умолчанию транзакции в YDB выполняются в режиме *Serializable*, что достигается через заранее определённый глобальный порядок выполнения атомарных операций в этой транзакции над шардами с использованием координаторов. Атомарные операции в YDB могут зависеть от данных на диске и на других шардах, и их последовательное выполнение может негативно сказываться на производительности. Для уменьшения latency и увеличения пропускной способности YDB может менять реальный порядок выполнения отдельных операций, в тех случаях, когда можно гарантировать, что видимые пользователям эффекты успешно закоммиченных транзакций будут соответствовать режиму *Serializable*.

Далее мы рассмотрим особенности работы, связанные с оптимизацией порядка выполнения операций.

## Особенности выполнения одношардовых транзакций

Транзакции, которые затрагивают ровно один шард (пример: чтение и запись по одному ключу) выполняются без использования координаторов, т.к. для их выполнения в режиме *Serializable* не требуется координация между несколькими шардами, и транзакция может быть выполнена в любой точке глобального порядка. Это позволяет избежать отдельной фазы подготовки к выполнению соответствующей операции, а также задержек на ожидании очередного цикла координации, давая минимально возможные latency.

Однако, сейчас в YDB возможна аномалия, когда с точки зрения пользователя транзакции как бы путешествуют во времени.

Например, есть 2 таблицы:

```yql
    CREATE TABLE t1 (k1 Uint64, v1 Uint64, PRIMARY KEY (k1));
    CREATE TABLE t2 (k2 Uint64, v2 Uint64, PRIMARY KEY (k2));
```

И в полёте есть коммит следующей транзакции:

```yql
    UPSERT INTO t1 (k1, v1) VALUES (1, 100);
    UPSERT INTO t2 (k2, v2) VALUES (2, 200);
```

Клиент, выполнив SELECT из таблицы t1:

```yql
    SELECT v1 FROM t1 WHERE k1 = 1;
```

Может получить значение 100.

Однако следующий SELECT из таблицы t2:

```yql
    SELECT v2 FROM t2 WHERE k2 = 2;
```

Может получить NULL.

С точки зрения клиента чтение из таблицы t2 как бы совершило "путешествие во времени" и выполнилось до чтения из таблицы t1, хотя клиент точно знает, что чтение из t1 закоммитилось до начала чтения из t2.

Такая ситуация возможна, если выполняются независимые одношардовые транзакции над разными шардами (таблицами), при условии параллельной распределённой транзакции, которая также затрагивает эти шарды.

Почему так происходит:

* Запись в таблицы t1 и t2 уже была запланирована
* План выполнения записи в таблицу t1 дошёл до шарда и выполнился
* Соответственно чтение по ключу из таблицы t1 (без координации) увидело изменения
* План выполнения записи в таблицу t2 не успел дойти до шарда
* Соответственно чтение по ключу из таблицы t2 (без координации) не увидело изменения

Подобный порядок выполнения является корректным в режиме *Serializable* и следует учитывать эту особенность при написании логики приложения.

Пример сценария, в котором это нужно учитывать:

* Приложение использует пару таблиц вида main/detail
* Приложение знает, что в main/detail запись попадает одновременно
* Приложение проверяет наличие записи в таблице main и находит объект
* Приложение читает дополнительные поля из таблицы detail без обращения к таблице main и не находит объект

В случае, если нужны дополнительные гарантии на порядок выполнения, рекомендуется в транзакциях чтения из detail таблицы выполнять также чтения из main таблицы (даже если эти данные непосредственно не нужны), в виде JOIN или отдельно стоящего проверочного SELECT.

## Особенности выполнения многошардовых транзакций

В режиме *Serializable* YDB сначала выполняет все читающие операции над шардами, с установкой optimistic локов на прочитанные диапазоны строк, буфферизирует эффекты (если есть), а на коммите YDB выполняет операцию коммита над всеми участвующими в транзакции шардами, которая проверяет и удаляет локи, и в случае успеха применяет накопленные эффекты.

Операции, которые затрагивают несколько шардов и проверяют локи являются особенно сложными, т.к. результат проверки локов (readset'ы) нужно отправить всем участникам, где требуется применение эффектов, и нельзя завершить выполнение операции на каком либо из участников, пока не будут собраны все нужные для выполнения readset'ы.

Так как порядок операций заранее определён на координаторах, в простейшей реализации шард не может перейти к следующей операции, пока не выполнит предыдущую, а она в свою очередь может быть заблокирована на ожидании readset'ов. Это может привести к длительным простоям всех участвующих шардов и снизить пропускную способность, добавляя зависимость от latency.

Для решения этой проблемы шарды могут менять порядок выполнения операций на некотором небольшом окне, если операции не конфликтуют по ключам. Например, если в очереди есть коммит с записью по ключу 1 и операция с чтением по ключу 2, то чтение по ключу 2 может выполниться до записи по ключу 1, пока запись по ключу 1 ожидает readset'ов. Однако, если далее в очереди находится операция, которая читает по ключу 1, то она сможет выполниться только после завершения коммита с записью по ключу 1.

Начиная с 20-4 шарды могут менять в том числе порядок коммитов с проверкой локов. Если YQL транзакция выполняла чтение из шарда по ключу 1, а затем выполняет коммит с записью по ключу 2, то такой коммит выглядит как чтение по ключу 1 и запись по ключу 2, пропуская операции, которые не имеют конфликтов по этим ключам. Эта оптимизация работает не всегда, например в редких случаях, когда проверка локов не может определить исходные ключи (лок не существует) и не может однозначно определить факт сломанного лока (информации о локе не осталось в памяти, например после рестарта), в этом случае с точки зрения конфликтов операция конфликтует с любыми пишущими операциями.

С точки зрения порядка выполнения наиболее сложными являются многошардовые операции, которые потенциально читают весь шард, но для которых заранее неизвестен диапазон необходимых данных. Наиболее яркий пример - это запрос вида `SELECT * FROM table ORDER BY key LIMIT 10` при условии, что очень много ключей в таблице удалены, но не успели физически удалиться на компакшенах. Пример такой таблицы - очередь, отсортированная по таймстемпам, в которой часто обновляются и удаляются строки таким образом, что очень много строк со старыми таймстемпами удалены. Такая операция может последовательно делать много небольших чтений и надолго заблокировать пишущие операции в этом шарде.

В некоторых случаях операции могут образовывать длинные цепочки, для которых невозможно оптимизировать порядок выполнения, например чередования широких чтений и распределённых коммитов с точечными записями. В этом случае пропускная способность может падать на порядки несмотря на свободный cpu, попадая в зависимость от latency чтений и коммуникации с соседними шардами. Для максимальной пропускной способности следует по возможности избегать потенциально широких чтений над таблицами.
