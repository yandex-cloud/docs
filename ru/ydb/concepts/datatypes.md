---
title: Типы данных Yandex Database (YDB)
description: 'В Yandex Database (YDB) используются типы данных YQL. Некоторые из типов YQL поддерживаются с ограничениями — они могут использоваться только в вычислениях, но не могут быть типом столбца или использоваться в первичном ключе. Все столбцы, включая ключевые, могут содержать специальное значение NULL. В таблицах приведены возможные варианты использования типов данных YQL в YDB.'
---

# Типы данных {{ ydb-name }}

В {{ ydb-short-name }} используются типы данных {% if audience != "external" %} [YQL](https://yql.yandex-team.ru/docs/ydb/) {% else %} [YQL](../yql/reference/overview.md) {% endif %}. Некоторые из типов YQL поддерживаются с ограничениями — они применяются только в вычислениях и не могут быть типом столбца или частью первичного ключа. Все столбцы, включая ключевые, могут содержать специальное значение `NULL`.

{% note warning %}

Несмотря на возможность сохранять значения `NULL` в части полей составного первичного ключа, рекомендуется не хранить `NULL` в первичном ключе.

{% endnote %}

## Числовые типы {#numeric}

{% include [datatypes-primitive-number](../_includes/datatypes_primitive_number.md) %}

## Строковые типы {#string}

{% include [datatypes-primitive-string](../_includes/datatypes_primitive_string.md) %}

В отличие от типа данных `Json`, который хранит исходное текстовое представление, переданное пользователем, `JsonDocument` использует бинарное индексированное представление. Важное отличие с точки зрения семантики состоит в том, что `JsonDocument` не сохраняет форматирование, порядок ключей в объектах и их дубликаты.

За счет индексированного представления `JsonDocument` позволяет обходить документную модель с использованием `JsonPath` без необходимости парсинга всего содержимого. Это позволяет эффективно выполнять операции из {% if audience != "external" %}[JSON API](https://yql.yandex-team.ru/docs/yt/builtins/json/){% else %}[JSON API](../yql/reference/builtins/json.md){% endif %}, уменьшая задержки и стоимость пользовательских запросов. Выполнение запросов над `JsonDocument` может быть до нескольких раз эффективнее в зависимости от типа нагрузки.

Из-за добавленной избыточности `JsonDocument` менее эффективен в хранении. Дополнительные накладные расходы на хранение зависят от конкретного содержимого и в среднем составляют 20–30% от исходного объема. Сохранение данных в формате `JsonDocument` требует дополнительной конвертации из текстового представления, что делает его запись менее эффективной. Тем не менее, для большинства read-intensive сценариев, подразумевающих обработку данных из JSON, этот тип данных является предпочтительным и рекомендуется к использованию.

{% note warning %}

Для хранения чисел (JSON Number) в `JsonDocument`, а также для арифметических операций над ними в {% if audience != "external" %}[JSON API](https://yql.yandex-team.ru/docs/yt/builtins/json/){% else %}[JSON API](../yql/reference/builtins/json.md){% endif %} используется тип [Double](https://en.wikipedia.org/wiki/Double-precision_floating-point_format). Возможна потеря точности при использовании нестандартных представлений чисел в исходном JSON-документе.

{% endnote %}

## Дата и время {#datetime}

{% include [datatypes-primitive-datetime](../_includes/datatypes_primitive_datetime.md) %}

## Опциональные типы {#optional}

{% include [datatypes-optional](../_includes/datatypes-optional.md) %}

Опциональные типы данных — это один из видов [контейнеров](#containers), которые могут быть произвольным образом вложены друг в друга или в другие контейнеры.

При поиске в словаре (`Dict(k,v)`) со значением типа `Optional<T>` результатом поиска будет `Optional<Optional<T>>`.

Пример запроса:

```sql
$dict = {"a":1, "b":null};
$found = $dict["b"];
select if($found is not null, unwrap($found), -1);
```

Результат:

```text
# column0
0 null
```

## Контейнеры {#containers}

{% include [datatypes-containers](../_includes/datatypes-containers.md) %}

При необходимости контейнеры можно вкладывать друг в друга в произвольных комбинациях. Например, `List<Tuple<Int32, Int32>>` — список, содержащий в качестве элементов кортежи.

[Опциональные значения](#optional) в некоторых контекстах также могут рассматриваться как один из видов контейнеров (`Optional<Type>`), который ведёт себя как список длины `0` или `1`.

Для представления множеств следует использовать словарь с значениями типа `Void` — `Dict<T, Void>`.

Для обращения к элементам контейнера используется [точка или фигурные скобки](../yql/reference/syntax/expressions.md#items-access), в зависимости от его типа.

## Специальные типы данных {#special}

{% include [datatypes-special](../_includes/datatypes-special.md) %}

## Представление данных {{ ydb-short-name }} в формате JSON {#type-json}

### Bool {#bool}

Логическое значение.

* Тип в JSON — `bool`.
* Пример значения {{ ydb-short-name }} — `true`.
* Пример значения JSON — `true`.

### Int8, Int16, Int32, Int64 {#int}

Целочисленные знаковые типы.

* Тип в JSON — `number`.
* Пример значения {{ ydb-short-name }} — `123456`, `-123456`.
* Пример значения JSON — `123456`, `-123456`.

### Uint8, Uint16, Uint32, Uint64 {#uint}

Целочисленные беззнаковые типы.

* Тип в JSON — `number`.
* Пример значения {{ ydb-short-name }} — `123456`.
* Пример значения JSON — `123456`.

### Float {#float}

Вещественное 4-байтное число.

* Тип в JSON — `number`.
* Пример значения {{ ydb-short-name }} — `0.12345679`.
* Пример значения JSON — `0.12345679`.

### Double {#double}

Вещественное 8-байтное число.

* Тип в JSON — `number`.
* Пример значения {{ ydb-short-name }} — `0.12345678901234568`.
* Пример значения JSON — `0.12345678901234568`.

### Decimal {#decimal}

Число с фиксированной точностью. Поддерживается только Decimal(22, 9).

* Тип в JSON — `string`.
* Пример значения {{ ydb-short-name }} — `-320.789`.
* Пример значения JSON — `"-320.789"`.

### String{% if audience != "external" %}, Yson{% endif %} {#string}

Бинарные строки. Алгоритм кодирования в зависимости от значения байта:

* [0-31] — `\u00XX` (6 символов, обозначающих код символа юникода);
* [32-126] — as is. Это читаемые однобайтовые символы, не требующие эскейпинга;
* [127-255] — `\u00XX`.

При декодировании происходит обратный процесс. Коды символов в `\u00XX` более 255 не допускаются.

* Тип в JSON — `string`.
* Пример значения {{ ydb-short-name }} — последовательность из 4 байт:
  * 5 `0x05` - управляющий символ;
  * 10 `0x0a` - перенос строки `\n`;
  * 107 `0x6b` - символ `k`;
  * 255 `0xff` - символ юникода `ÿ`.
* Пример значения JSON — `"\u0005\nk\u00FF"`.

### Utf8, Json, Uuid {#utf}

Строковые типы в utf-8. Такие строки представляются в JSON строками с escaping'ом JSON-символов: `\\`, `\"`, `\n`, `\r`, `\t`, `\f`.

* Тип в JSON — `string`.
* Пример значения {{ ydb-short-name }} — код на С++:

  ```c++
  "Escaped characters: "
  "\\ \" \f \b \t \r\n"
  "Non-escaped characters: "
  "/ ' < > & []() ".
  ```

* Пример значения JSON — `"Escaped characters: \\ \" \f \b \t \r\nNon-escaped characters: / ' < > & []() "`.

### Date {#date}

Дата. Uint64, количество дней unix time.

* Тип в JSON — `string`.
* Пример значения {{ ydb-short-name }} — `18367`.
* Пример значения JSON — `"2020-04-15"`.

### Datetime {#datetime}

Дата и время. Uint64, количество секунд unix time.

* Тип в JSON — `string`.
* Пример значения {{ ydb-short-name }} — `1586966302`.
* Пример значения JSON — `"2020-04-15T15:58:22Z"`.

### Timestamp {#timestamp}

Дата и время. Uint64, количество микросекунд unix time.

* Тип в JSON — `string`.
* Пример значения {{ ydb-short-name }} — `1586966302504185`.
* Пример значения JSON — `"2020-04-15T15:58:22.504185Z"`.

### Interval {#interval}

Временной интервал. Int64, точность до микросекунд, допустимы значения интервалов - не более 24 часов.

* Тип в JSON — `number`.
* Пример значения {{ ydb-short-name }} — `123456`, `-123456`.
* Пример значения JSON — `123456`, `-123456`.

### Optional {#optional}

Означает, что значение может быть `null`. Если значение `null`, то в JSON также будет `null`. Если значение не `null`, то в JSON значение запишется так же, как если бы тип был не `Optional`.

* Тип в JSON — отсутствует.
* Пример значения {{ ydb-short-name }} — `null`.
* Пример значения JSON — `null`.

### List {#list}

Список. Упорядоченный набор значений заданного типа.

* Тип в JSON — `array`.
* Пример значения {{ ydb-short-name }}:
  * тип — `List<Int32>`;
  * значение — `1, 10, 100`.
* Пример значения JSON — `[1,10,100]`.

### Stream {#stream}

Поток. Однопроходной итератор по значениям одного типа.

* Тип в JSON — `array`.
* Пример значения {{ ydb-short-name }}:
  * тип — `Stream<Int32>`;
  * значение — `1, 10, 100`.
* Пример значения JSON — `[1,10,100]`.

### Struct {#struct}

Структура. Неупорядоченный набор значений с заданными именами и типом.

* Тип в JSON — `object`.
* Пример значения {{ ydb-short-name }}:
  * тип — `Struct<'Id':Uint32,'Name':String,'Value':Int32,'Description':Utf8?>`;
  * значение — `"Id":1,"Name":"Anna","Value":-100,"Description":null`.
* Пример значения JSON — `{"Id":1,"Name":"Anna","Value":-100,"Description":null}`.

### Tuple {#tuple}

Кортеж. Упорядоченный набор значений заданных типов.

* Тип в JSON — `array`.
* Пример значения {{ ydb-short-name }}:
  * тип — `Tuple<Int32??,Int64???,String??,Utf8???>`;
  * значение — `10,-1,null,"Some string"`.
* Пример значения JSON — `[10,-1,null,"Some string"]`.

### Dict {#dict}

Словарь. Неупорядоченный набор пар ключ-значение. И для ключа, и для значения задан тип. В json записывается в массив массивов, состоящих из двух элементов.

* Тип в JSON — `array`.
* Пример значения {{ ydb-short-name }}:
  * тип — `Dict<Int64,String>`;
  * значение — `1:"Value1",2:"Value2"`.
* Пример значения JSON — `[[1,"Value1"],[2,"Value2"]]`.
