# YQL

## Общие вопросы {#common}

#### Как выбрать из таблицы строчки по заданному списку ключей? {#explicit-keys}

Выборка строчек таблицы по заданному списку значений первичного ключа (или префикса ключа) таблицы выполняется с помощью оператора IN:

```sql
DECLARE $keys AS List<UInt64>;

SELECT * FROM some_table
WHERE Key1 IN $keys;
```

В случае если выборка делается по составному ключу, параметр запроса должен иметь тип списка таплов:

```sql
DECLARE $keys AS List<Tuple<UInt64, String>>;

SELECT * FROM some_table
WHERE (Key1, Key2) IN $keys;
```

Для эффективного выполнения выборки важно, чтобы типы значений в параметрах совпадали с типами ключевых колонок в таблице.

#### Осуществляется ли поиск по индексу для условий, содержащих оператор LIKE? {#like-index}

Оператор LIKE может быть использован для поиска по индексу таблицы только в случае если он задает префикс строки:

```sql
SELECT * FROM string_key_table
WHERE Key LIKE "some_prefix%";
```

#### Почему в результате запроса выводится только 1000 строк? {#result-rows-limit}

1000 строк — ограничение на размер одного результата для YQL запроса. В случае если результат запроса был обрезан, он будет помечен флагом `Truncated`. Чтобы получить большее количество строк из таблицы, можно воспользоваться [постраничным выводом](../best_practices/paging.md) или операцией `ReadTable`.

#### Что делать, если при запросе я получаю ошибку <q>Datashard: Reply size limit exceeded</q>? {#reply-size-exceeded}

Данная ошибка означает, что при выполнении запроса с одного из участвующих в нем даташардов была попытка вернуть более 50 Мб данных, что превышает допустимый лимит.

Рекомендации:
* Общая рекомендация — уменьшить объем данных, обрабатываемых в транзакции.
* Если выполняется операция Join, стоит убедиться, что она выполняется способом [Index lookup Join](#index-lookup-join).
* Если осуществляется простая выборка, стоит убедиться, что она делается по ключам, или добавить `LIMIT` в запрос.

#### Что делать, если при запросе я получаю ошибку <q>Datashard program size limit exceeded</q>? {#program-size-exceeded}

Данная ошибка означает, что размер программы (в сумме со значениями параметров) для одного из даташардов первысил лимит в 50 МБ. Чаще всего это означает попытку записать в таблицы базы более 50 Мб данных в одной транзакции. В качестве записей учитываются все модифицирующие операции в транзакции, такие как `UPSERT`, `REPLACE`, `INSERT`, `UPDATE`.

Необходимо уменьшить суммарных объем записей в одной транзакции. В общем случае не рекомендуется объединять в единую транзакцию запросы, которые логически не требуют транзакционности. В случае добавления/обновления данных батчами, рекомендуется уменьшить размер одного батча до значений, не превышающих нескольких мегабайт.

#### Как обновить только те значения, ключей которых нет в таблице? {#update-non-existent}

Можно использовать операцию LEFT JOIN, чтобы пометить отсутствующие в таблице ключи, после чего обновить их значения:

```sql
DECLARE $values AS List<Struct<Key: UInt64, Value: String>>;

UPSERT INTO kv_table
SELECT v.Key AS Key, v.Value AS Value
FROM AS_TABLE($values) AS v
LEFT JOIN kv_table AS t
ON v.Key = t.Key
WHERE t.Key IS NULL;
```

## Операции Join {#joins}

#### Есть ли особенности в работе операции Join? {#join-operations}

Операция Join в {{ ydb-short-name }} выполняется одним из двух способов:
* Common Join
* Index Lookup Join

##### Common Join {#common-join}

Содержимое обеих таблиц (левая и правая части Join) отправляется на выполняющий запрос узел, где операция выполняется над данными целиком. Это универсальный способ выполнения операции Join, который применяется в случае, когда более оптимальные способы неприменимы. Для больших таблиц такой способ или работает медленно, или в общем случае не работает из-за превышения лимитов на пересылку данных.

##### Index lookup Join {#index-lookup-join}

Для строчек из левой части операции Join осуществляется поиск (lookup) соответствующих значений в правой части. Данный способ применяется, когда правая часть является таблицей и ключ операции Join является префиксом ее первичного ключа или ключа вторичного индекса. При использовании данного способа из правой таблицы делаются ограниченные выборки, вместо полного чтения, что позволяет использовать его при работе с большими таблицами.

{% note info %}

Для большинства OLTP запросов рекомендуется использовать Index Lookup Join с небольшим размером левой части. Такие операции читают мало данных и могут быть выполнены эффективно.

{% endnote %}

#### Как сделать Join с данными из параметров запроса? {#constant-table-join}

Данные из параметров запроса можно использовать как константную таблицу. Для этого нужно использовать модификатор `AS_TABLE` с параметром, имеющим тип списка структур:

```sql
DECLARE $data AS List<Struct<Key1: UInt64, Key2: String>>;

SELECT * FROM AS_TABLE($data) AS d
INNER JOIN some_table AS t
ON t.Key1 = d.Key1 AND t.Key2 = d.Key2;
```

Явного ограничения на количество записей в константной таблице нет, но нужно иметь в виду стандартное ограничение на общий размер параметров запроса (50 МБ).

## Транзакции {#transactions}

#### Насколько эффективно выполнение нескольких запросов в транзакции? {#transaction-queries}

При последовательном выполнении нескольких запросов, суммарный latency для транзакции может быть больше, чем при выполнении тех же операций в рамках одного запроса. В первую очередь это обусловлено дополнительными сетевыми задержками на выполнение каждого из запросов. Поэтому в случае, когда для транзакции не требуется интерактивность, рекомендуется формулировать все операции в одном YQL запросе.

#### Является ли отдельный запрос атомарным? {#atomic-query}

В общем случае YQL-запросы могут выполняться в несколько последовательных фаз. Например, запрос с операцией Join может быть выполнен в две фазы, читающие данные левой и правой таблицы соответственно. Этот аспект является важным при выполнении запроса в транзакции с низким уровнем изоляции (`online_read_only`), так как в этом случае данные между фазами выполнения могут быть изменены другими транзакциями.