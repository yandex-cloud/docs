# Общие вопросы

#### Что такое {{ ydb-short-name }}? {#what-is-ydb}

{{ ydb-short-name }} — это распределенная отказоустойчивая NewSQL СУБД. YDB обеспечивает высокую доступность и масштабируемость, и, в то же время, строгую консистентность и поддержку ACID-транзакций. Для запросов используется диалект SQL (YQL).

{{ ydb-short-name }} — это полностью управляемая база данных, для создания инстанса базы данных используется сервис управления базами данных {{ ydb-short-name }}.

#### Какие возможности предоставляет {{ ydb-short-name }}? {#ydb-features}

{{ ydb-short-name }} обеспечивает высокую доступность и сохранность данных благодаря синхронной репликации в трех зонах доступности. Также {{ ydb-short-name }} следит за равномерным распределением нагрузки на доступные аппаратные ресуры. Это значит, что не нужно заказывать ресурсы, Yandex Database автоматически выделяет и освобождает ресурсы, исходя из пользовательской нагрузки.

#### Какая модель консистентности используется в YDB? {#ydb-consistency}

Для чтения данных {{ ydb-short-name }} использует модель строгой консистентности (непротиворечивости) данных.

#### Как проектировать первичный ключ? {#create-pk}

Чтобы правильно спроектировать первичный ключ стоит придерживаться следующих правил.

* Необходимо избегать ситуаций, когда основная часть нагрузки приходится на одну партицию таблицы. При равномерной нагрузке проще достигается высокая общая производительность.

  Как следствие этого правила, не стоит в качестве первичного ключа таблицы использовать монотонно возрастающую последовательность, например, timestamp.

* Чем меньше партиций таблиц будет задействованно во время исполнения запроса — тем быстрее он будет исполнен. Чтобы достичь большей производительности стоит руководствоваться правилом: один запрос — одна партиция.

* Необходимо избегать ситуаций, при которых какая-то малая часть БД нагружена существенно больше, чем остальные части БД.

Подробнее читайте в разделе [{#T}](../best_practices/schema_design.md).

#### Как равномерно распределить нагрузку по партициям таблицы? {#balance-shard-load}

Для равномерного распределения нагрузки по партициям таблиц и увеличения общей производительности БД, можно использовать следующие техники.

* Для избежания использования монотонно возрастающих значений первичного ключа можно:
  * изменить порядок следования его компонентов;
  * использовать хеш от значений ключевых колонок в качестве первичного ключа.

* Необходимо уменьшать количество партиций таблиц, задействованных в одном запросе.

Подробнее читайте в разделе [{#T}](../best_practices/schema_design.md#balance-shard-load).

#### Можно ли использовать NULL в ключевой колонке? {#null}

В {{ ydb-short-name }} все колонки, включая ключевые, могут содержать значение `NULL`, однако использовать `NULL` в качестве значений в ключевых колонках не рекомендуется.

 По стандарту языка SQL (ISO/IEC 9075), значение `NULL` нельзя сравнивать с другими значениями, вследствие чего, использование лаконичных конструкций SQL с простыми операторами сравнения может приводить, например, к тому что, строки, содержащие значение NULL, могут быть пропущены при фильтрации.

#### Существует ли оптимальный размер строки базы данных? {#string-size}

Для достижения высокой производительности не рекомендуется записывать в БД строки размером более 8 МБ и ключевые колонки размером более 2 КБ.

Подробнее существующие ограничения описаны в разделе [{#T}](../api/limits.md).

#### Как работают вторичные индексы в {{ ydb-short-name }}? {#secondary_indexes}

Вторичные индексы в {{ ydb-short-name }} — глобальные и могут быть неуникальными.
 
Подробнее читайте в разделе [{#T}](../concepts/secondary_indexes.md).

#### Как осуществляется постраничный вывод? {#paging}

Для организации постраничного вывода рекомендуется последовательно выбирать данные, отсортированные по первичному ключу, ограничивая количество строк ключевым словом `LIMIT`. Использование ключевого слова `OFFSET` для решения этой задачи крайне не желательно.

Подробнее читайте в разделе [{#T}](../best_practices/paging.md).

#### Как эффективно загружать в {{ ydb-short-name }} большие объёмы данных? {#batch_upload}

Для увеличения скорости загрузки больших объёмов данных необходимо следовать следующим рекомендациям:

* При создании таблицы стоит явно указать необходимое количество партиций или их границы. Это поможет эффективно использовать пропускную способность системы сразу после начала загрузки данных, поскольку поможет избежать ненужных перепартиционирований таблицы.

* Не стоит вставлять данные отдельными транзакциями для каждой строки. Более эффективно производить вставки по несколько строк (батчами). В этом случае накладные расходы на сам механизм транзакций будут меньше.

* В дополнение к предыдущему пункту — в каждой транзакции (батче) вставляйте строки из уже отсортированного по первичному ключу набора данных, чтобы минимизировать количество партиций, затрагиваемых транзакцией.

* Следует избегать последовательной записи данных в порядке возрастания или убывания значения первичного ключа, чтобы равномерно распределить нагрузку на все партиции таблицы.

Подробнее читайте в разделе [{#T}](../best_practices/batch_upload.md).

#### Как удалять устаревшие данные? {#ttl}

Для эффективного удаления устаревших данных рекомендуется использовать [{#T}](../concepts/ttl.md).