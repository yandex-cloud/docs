### Внешние ссылки на основные понятия

* [https://en.wikipedia.org/wiki/Consistency_model Strict Consistency](https://en.wikipedia.org/wiki/Consistency_model Strict Consistency)
* [https://en.wikipedia.org/wiki/Isolation_%28database_systems%29#Serializable Serializable isolation](https://en.wikipedia.org/wiki/Isolation_%28database_systems%29#Serializable Serializable isolation)
* [https://en.wikipedia.org/wiki/Actor_model Actor model](https://en.wikipedia.org/wiki/Actor_model Actor model)
* [https://en.wikipedia.org/wiki/State_machine_replication Replicated state machine](https://en.wikipedia.org/wiki/State_machine_replication Replicated state machine)

### Tablet
**Tablet (таблетка)** - так в системе называется RSM - replicated state machine. Таблетка представляет собой набор данных, за который отвечает эта таблетка, и конечный автомат, через который состояние таблетки (данные) меняется. Таблетка является базовым строительным блоком системы. Таблетка является отказоустойчивой сущностью -- данные таблетки хранятся в распределенном BlobStorage, который переживает отказ дисков и нод. Данные в таблетке меняются консистентным образом -- инфраструктура системы обеспечивает наличие не более одной сущности (мастера), через которую проводятся изменения данных таблетки. За обработку команд отвечает некоторый вышеуказанный конечный автомат. С технической точки зрения реализацию таблетки проще всего описать как RSM over shared log - состояние полностью описывается упорядоченным логом команд, хранящимся в распределенном хранилище. Во время выполнения "конечный автомат" таблетки обслуживают три актора: <span style"color:red;">

1. актора с пользовательским кодом;
2. экзекьютера - предоставляющего абстракцию локальной базы;
3. общетаблеточная часть, обеспечивающая консистентность лога и восстановление при сбоях</span>.
Обычно, в системе запущено множество (тысячи, десятки тысяч+) таблеток, выполняющих различную функцию.
Таблетки идентифицируются при помощи **TabeltID** -- 64-х битного числа, назначаемого при создании таблетки.

#### Tablet Master
  **Tablet Master** - текущий активный лидер таблетки, именно он принимает команды, упорядочивает их и подтверждает внешнему миру. В каждый момент времени существует не более одного мастера.
#### Tablet Candidate
  **Tablet Candidate** - если таблетка осталась без мастера, то кандидат -- это один их участников выборов, желающий стать мастером. В случае успеха выборов кандидат становится мастером таблетки.
#### Tablet Slave
  **Tablet Slave** или **Hot standby** - копия мастера, проигрывающая принятый мастером лог команд (с некоторым отставанием). Tаблетка может иметь 0 или более слейвов. Слейвы решают по большей степени две задачи: (1) в случае смерти мастера слейвы являются предпочтительными кандидатами в мастера, т.к. могут перейти в мастера гораздо быстрее (меньше лога проигрывать); (2) слейвы могут брать на себя некоторую нагрузку мастера на чтение (отвечая на запросы чтения с некоторым отставанием).
#### Tablet Generation
  **Tablet Generation** - число, идентифицирующее реинкарнацию мастера таблетки. Меняется только при выборе нового мастера и всегда растет.
#### Tablet Local Database
  **Tablet Local Database** или **локальная база** -- способ хранения набора данных, за который отвечает таблетка. Очень грубо, состояние локальной базы представлено набором таблиц очень похожих на реляционные таблицы. Модификация состояния локальной базы производится локальными транзакциями, генерируемыми пользовательским актором таблетки.

### Виды таблеток
#### Scheme Shard
  **Scheme Shard** - таблетка хранящая часть глобальной схемы (схему всего хранилища). Обычно, достаточно одной таблетки для хранения схемы, но если схема большая, то может потребоваться иерархия Scheme Shards.
#### KV Tablet
  **KV Tablet** - таблетка реализующая простое отображение key->value, где key и value -- это строки. Также имеет ряд специфических возможностей (например, блокировки).
#### PQ Tablet
  **PQ Tablet** - таблетка реализующая понятие персистентной очереди. Состоит из партиций, которые крайне похожи на партиции Kafka.
#### Data Shard
  **DataShard** - элемент хранения части данных глобальной таблицы (или просто таблицы) хранилища.
#### Coordinator
  **Coordinator** - таблетка, управляющая транзакциями и обеспечивающая глобальную упорядоченность транзакций. Для каждой транзакции выбирается строго один координатор (выбирается хешированием для конкретного TxProxy).
#### Mediator
  **Mediator** - таблетка, применяющая транзакции на даташарды и обеспечивающая “движение” глобального времени. Распространяет план транзакций по участникам (типично - Data Shards). С каждой таблеткой ассоциирован ровно один медиатор.
#### TxProxy
  **TxProxy** - <span style"color:red;">клиентский интерфейс взаимодействия с Kikimr.</span>
#### BlobStorage Controller
  **BlobStorage Controller** - системная таблетка, которая хранит информацию о конфигурации BlobStorage. Запущена в единственном экземпляре.
#### Hive
  **Hive** - системная таблетка, позволяющая создавать, запускать и управлять другими таблетками. В системе есть ряд системных служебных таблеток, которые должны быть подняты для нормального функционирования системы. Такие таблетки поднимается при помощи **Bootstrapper**. Остальные таблетки создаются и поднимаются при помощи Hive. Например, если мы создаем (глобальную) таблицу в системе, для которой нужно создать и запустить несколько Data Shards, то их созданием и запуском занимается Hive.

   Hive позволяет минимизировать конфликты кандидатов в мастера таблетки при запуске. Он также занимается балансировкой нагрузки на кластер -- выбирает на какой ноде лучше запустить данную таблетку. При создании таблеток Hive взаимодействует с **BlobStorage Controller** для назначения **Blobstorage групп** каналам таблеток. Непосредственно запуск таблеток на нодах осуществляет через запущенный на каждой ноде сервис Local.

### Infrastructure
#### Local
  **Local** - сервис, запущенный на каждой ноде. Непосредственно управляет таблетками на своей ноде, взаимодействует с Hive. Регистрируется в Hive и получает команды на запуск таблеток.
#### Bootstrapper
  **Bootstrapper** - базовый механизм запуска таблеток, применяется для служебных таблеток (например для Hive, BlobStorage Controller, корневого Scheme Shard).
#### TabletPipe
  **TabletPipe** - виртуальное соединение, которое можно установить с таблеткой. Включает в себя resolve мастера таблетки по TabletID. Рекомендуемый способ работы с таблеткой.
#### StateStorage
  **StateStorage** - распределенный сервис, который хранит информацию о таблетках, а именно: информацию о текущем мастере таблетки или его отсутсвии, о слейвах таблетки, информацию о поколении и шаге таблетки (generation:step). Информация в StateStorage волатильна, т.е. не durable (персистентно данные сохраняются только в BlobStorage). Информация в StateStorage хранится отказоустойчиво, т.е. на нескольких репликах. StateStorage используется как Name Service для резолва таблеток, т.е. получение ActorID по TabletID. Также StateStorage используется в процессе поднятия мастера таблетки.
#### Compaction
  **Compaction** - внутренний процесс перестройки данных хранимых в виде [LSM Tree](https://en.wikipedia.org/wiki/Log-structured_merge-tree). Данные в VDiskе и Локальной базе таблетки организованы в виде LSM Tree. Поэтому различают **VDisk compaction** и **Tablet compaction**. Данный процесс, обычно, достаточно ресурсоемкий, поэтому много усилий прилагается для того, чтобы минимизировать накладные расходы с ним связанные (разбить данные иначе, изменить логику старта compaction и т.д.).
#### MessageBus Proxy
  **MessageBus proxy** - базовая клиентская прокси системы для пользовательских запросов. Клиентские запросы попадают в систему через MsgBus, далее используются внутренние механизмы выполнения этих запросов и передачи сообщений. Предоставляет интерфейс в терминах request-response.
#### Interconnect
  **Interconnect** - сетевой программный слой а также внутренняя сеть кластера. Внутри системы акторы взаимодействуют друг с другом через Interconnect.
### Blob Storage
**Blob Storage** - это распределенное отказоустойчивое хранилище данных, обеспечивающее хранение бинарных записей, называемых LogoBlob, адресуемых по специального вида идентификаторам, называемым LogoBlobID. BS разделяется на множество BS-групп, каждая из которых является независимым хранилищем.
Blob Storage хранит иммутабельные данные, т.е. изменять их нельзя. Интерфейс Blob Storage является весьма специфичным, он удобен только для использования таблетками, которые хранят в Blob Storage свои данные и лог изменений. Данные в Blob Storage удаляются при помощи специальных команд-барьеров. Из-за специфики своего интерфейса (нет мутаций) Blob Storage можно реализовать без обеспечения **распределенного консенсуса**, более того BlobStorage является как раз тем кирпичиком, при помощи которого распределенный консенсус и реализуется (это делает таблетка).
#### LogoBlob
  **LogoBlob** или **логоблоб** - Строка двоичных иммутабельных данных, снабженая уникальным идентификатором, имеющим специальную структуру, хранимая в blob storage. Размер блоба ограничен на уровне VDiskов и выше по стеку. На данный момент максимальный размер блоба, который готовы обрабатывать VDiskи составляет 10 Mb.
#### LogoblobID
  **LogoblobID** или **логоблобид** - идентификатор блоба в Blob Storage.
#### Erasure Сoding
  **Erasure coding** - способ кодирования данных, при котором данные дополняются избыточностью и разбиваются на несколько фрагментов, обеспечивающий возможность восстановления исходных данных при потере одного или нескольких фрагментов. Широко используется в системе в противовес популярной репликации с 3-мя репликами. Например, наиболее популярная схема 4+2 обеспечивает такую же надежность как 3 реплики, при этом избыточность составляет 1.5 против 3-х.
#### PDisk
  **PDisk** или (**Physical Disk**) - компонент управляющий физическим диском (устройством). Иначе - подсистема, реализующая разновидность файловой системы поверх блочных устройств (или файлов). PDisk обеспечивает надежное хранение данных (erasure кодирование групп секторов для восстановления данных при единичных bad-секторах, контроль целостности), прозрачное шифрование всех данных на диске, транзакционность операций с диском (подтверждение записи строго после fsync). PDisk содержит планировщик, который обеспечивает разделение полосы пропускания блочного устройства между несколькими клиентами (VDisk-ами). PDisk разделяет блочное устройство на чанки (размером порядка 128 мегабайт), каждым чанком единовременно может владеть не более 1 VDisk-а.  Также PDisk поддерживает recovery-log, общий для служебных записей PDiskа и всех VDiskов.
#### Yard
  **Yard** - историческое название интерфейса к PDiskу. Позволяет VDisk-ам читать и писать данные в чанки и лог, резервировать чанки, удалять чанки, а также транзакционно получать и возвращать владение чанками. В некотором приближении можно считать Yard синонимом PDiskа.
#### VDisk
  **VDisk** или **Virtual Disk** - компонент, который обеспечивает хранения логоблобов BS-группы на PDiskе. VDisk хранит свои данные на PDiskе. Одному VDiskу соответствует один PDisk, но к одному PDiskу, обычно, привязано несколько VDiskов. В отличие от PDiskа, который скрывает за собой чанки и лог, VDisk предоставляет интерфейс на уровне LogoBlob и LogoBlobID типа: записать LogoBlob, прочитать данные по LogoBlobID, удалить набор LogoBlob по специальной команде. VDisk входит в BS-группу. Сам VDisk локален, но множество VDiskов входящих в BS-группу обеспечивают надежное хранение данных. VDiskи в группе синхронизируют данные между собой и реплицируют данные в случае потери. Очень грубо, набор VDiskов в BS-группе образуют распределенный RAID.
#### VDisk Skeleton
  **Skeleton** - актор, обеспечивающий интерфейс к VDiskу (сам VDisk состоит из множества акторов). С некоторой погрешностью Skeleton можно считать синонимом VDiskа.
#### BlobStorage Group {#blobstoragegroup}
  **BlobStorage Group** -- группа VDiskов на разных машинах, предназначенная для отказоустойчивого хранения данных (LogoBlob). Очень грубо -- распределенный RAID.
  BS-группы бывают:
  1. Статическими. Сконфигурированная при помощи конфигурационного файла группа во время первоначального разворачивания кластера. Групп предназначена строго для хранения данных системных таблеток (BlobStorage Controller, Hive). Конфигурация этой группы не изменяется на протяжении всего времени службы кластера.
  2. Динамическими. Группа, управлением конфигурацией которой осуществляет BlobStorage Controller. Динамические группы -- самый массовый сегмент BS-групп. Предназначены для хранения основного объема данных.

#### BlobStorage Proxy
  **Blob Storage Proxy** или "DS (Distributed Storage) Proxy"-- играет роль "библиотеки" для выполнения операций с Blob Storage. Пользователем DS Proxy являются таблетки, которые пишут в/читают из Blob Storage. DS Proxy скрывает от пользователя распределенную натуру Blob Storage, задача DS Proxy сделать запись на кворум VDiskов, при необходимости делая повторы, контролируя потом записей/чтения, чтобы не перегрузить VDiskи.
  Технически DS Proxy реализована как акторный сервис, запускаемый **Warden** на каждой ноде для каждой BS-группы, обрабатывающий все запросы к группе (запись, чтение и удаление логоблобов, блокировка группы). При записи данных DS Proxy осуществляет erasure-кодирование данных разделяя логоблобы на partы, которые затем рассылаются на соответствующие VDiskи. При чтении DS Proxy осуществляет обратный процесс, получая partы от VDiskов и восстанавливая логоблобы из них.
#### Blob Storage Node Warden {#blobstoragenodewarden}
  **Blob Storage Node Warden** (BS_NODE, BSNodeController) - <span style"color:red;">cервис на каждой ноде кластера, запускающий все необходимое для работы статических групп Blob Storage, а также обрабатывающий "не доставленные" сообщения к BS_PROXY (запуская BS_PROXY и получая конфигурацию групп от BS_CONTROLLER). Запускает акторы BSProxy, Vdisk и Pdisk</span>.

  **Ring** (кольцо) - группа blob storage представляет собой набор VDisk-ов, объединенных в одно или более одинаковых колец - реплик в различных доменах. VDisk-и кольца логически разделены на Fail domain-ы. На данный момент поддерживаются группы с 1 кольцом, в планах поддержка нескольких колец.
  **Fail domain** - набор VDisk-ов в кольце, вероятность совместного отказа которых существенно выше, чем для VDisk-ов из различных fail-domain-ов (например, диски одной ЭВМ или диски в одной стойке). При записи каждого логоблоба его части записываются на диски в разных fail domain-ах. Суммарное количество VDisk-ов во всех фейл-доменах кольца не должно превышать 32.
  **Availability domain** - локализованная независимая сущность внутри kikimr. Условно - ДЦ или межДЦ инсталляция.
  **BS Group** - набор VDisk-ов, объединенных в кольца и fail-domain-ы и снабженный уникальным идентификатором. Для осуществления доступа к данным, хранимым группой, служит blob storage proxy. В группе на протяжении ее жизни может использоваться только один вид erasure.

  **Channel** - логический мост между логикой таблетки и Blob стораджем. Основной характеристикой канала является метод хранения данных (репликация или вид erasure кодирования)

### Transactions
  **Transactions** -- в системе реализована схема выполнения [Deterministic Transactions](http://cs-www.cs.yale.edu/homes/dna/papers/transactions-wodet11.pdf). Транзакции реализуются поверх слоя таблеток (обычно, хранящих данные, например Data Shards). Дело в том, что реализация Локальной базы вместе с инфраструктурой таблеток позволяют выполнять Локальные транзакции с уровнем serializable. Однако для транзакционного изменения данных, хранящихся  разных таблеток необходим другой механизм, коим и являются deterministic transactions. Уровень изоляции реализованный в системе -- serializable.

  **Prepare stage** - фаза, на которой регистрируется тело транзакции на всех шардах.
  **Execute stage** - фаза, на которой происходит выполнение запланированной транзакции и формирование ответа. В некоторых случаях (например, readonly тразнакции с одного шарда) вместо prepare и execute проводится немедленное выполнение транзакции и формирование ответа.
  **Dirty operations** - в случае readonly транзакций - похож на read uncommitted в базах данных - можно прочитать данные, которые еще не были закоммичены на диск. В случае write транзакций - сформировать ответ сразу после планирования, а не дожидаясь коммита выполнения транзакции на диск.
  **RW set** - набор шардов, которые будут участвовать в выполнении распределенной транзакции. Состоит из объединения read-set - шардов, на которых будет проводится только чтение данных и write-set - шардов, в которых будут проводится модификации.
</span>
  **Transaction proxy** (TX_PROXY) - внутренняя сущность, распределяющая транзакцию по шардам. Так же назначает уникальный txid транзакции.
  **Proxy** - точка входа транзакций в кластер, запущенно известное количество в каждом из ДЦ. Не является полноценной таблеткой.
  **Proxy Aggregator** - агрегирует поток транзакций с нескольких проксей одного ДЦ, всё еще не является полноценной таблеткой.
  **Transaction Aggregator** - дуальная часть proxy aggregator-а, получает сформированные списки транзакций для пропихивания их на Transaction Executor.
  **Transaction body ID** - уникальная чиселка, назначаемая каждой транзакции проксей при её приеме.
  **Transaction order ID** - уникальная чиселка, назначаемая каждой транзакции при её планировании.
</span>



### Data Model and User Interface
#### Global Scheme
  **Global Scheme** или **Глобальная схема** - схема данных хранящихся в системе. Система представляет собой набор таблиц и некоторых других сущностей, например топиков PQ (персистентных очередей). Метаданные об этих сущностях и представляют собой глобальную схему. Термин используется в противовес **Local Scheme** или **Локальной схеме**, который используется для обозначения схемы данных внутри таблетки. Пользователь системы никогда не видит локальную схему, он работает только с глобальной схемой.
#### MiniKQL
  **MiniKQL** (Mini KiKiMR Query Language) - язык, позволяющий выразить одну deterministic транзакцию KiKiMR. Представляет собой строго функциональный, строго типизированный язык. Концептуально, язык описывает граф чтения из базы, проведения вычислений над прочитанными данными, и запись результатов в базу и/или в специальный документ представляющий результат запроса (показывается пользователю). Транзакция MiniKQL должна явно задавать свой read set (читаемые данные) и предполагает детерминированность выбора веток выполнения (например нет random).
  MiniKQL является низкоуровневым языком. Для конечных пользователей предполагается развивать **YQL**, запросы которого выполняются при помощи одной или несколько транзакций MiniKQL.
#### YQL
  **YQL** - высокоуровневый язык для работы с данными в системах хранения данных таких, как YaMR, YT, KiKiMR. Язык имеет несколько синтаксисов, самым популярных из которых (по очевидным причинам) является надмножество SQL. В случае KiKiMR выполнение YQL-запросов реализуется через выполнение одной или нескольких **MiniKQL**-транзакций.
#### KiKiMR Driver
**KiKiMR Driver** или **Бинарник KiKiMR** -- так называется бинарник KiKiMR. KiKiMR Driver является общим бинарником как для сервера KiKiMR, так и для клиента, т.е. содержит ряд клиентских утилит для просмотра содержимого базы, манипуляции с данными, административных действий.
