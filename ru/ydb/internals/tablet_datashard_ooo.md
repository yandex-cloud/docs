---
sourcePath: overlay/internals/tablet_datashard_ooo.md
---
### Решаемая задача 
Базовая модель выполнения транзакций последовательна: транзакции должны выполняться в порядке, полученном с координатора. Если при этом предыдущая транзакция ожидает данных, последующая блокируются, т.к. должна увидеть все эффекты выполняющейся транзакции. Такая модель обладает невысокой производительностью. Для решения этой проблемы реализовано выполнение пользовательских транзакций out-of-order. Если транзакции не видят эффекты друг друга, они могут выполняться в произвольном порядке. Например: две читающие транзакции; две транзакции не пересекающиеся по ключам.
Важно понимать, что сам механизм out-of-order не бесплатен. Его смысл - догрузить незагруженную систему, нивелируя неоднородность транзакций. Если причина задержек транзакций - общая деградация системы, эффект от реордера  может быть отрицательным.

### Реализация 
Out-of-order включается на конкретной таблице настройками PartitionConfig.PipelineConfig. В системе может быть микс из таблиц с включенным реордером транзакций и без него. Механизм включен по умолчанию с версии 18.6. Начиная с этой версии таблицы создаются с включенным out-of-order. Для включения реордера на более старых таблицах нужно сделать AlterTable с соответствующими параметрами. Для выключения реордера на новых таблицах надо явно указать параметры в CreateTable.

Out-of-order выполнен в конвеерной архитектуре. Транзакции, получившие план с координатора, выстриваются в очередь (на ленту конвеера). Обработчик конвеера вместо одной транзакции видит окно из N транзакций (N настраиваемое, по умолчанию 8). На каждую активацию, он пытается выполнить 1 транзакцию из окна. Если может выполнить первую транзакцию - начинает выполнять ее. Если у первой транзакции нет хватает данных для выполения - переходит ко второй. Запустив очередную транзакцию обработчик снова активирует себя, пока окно обработки не заполнится. Завершение транзакций происходит по отношению к обработчику асинхроннно. Получив завершение транзакции она удаляется из окна обработки.

#### Включение 
AlterTable для включения out-of-order с окном 8.
```
ModifyScheme {
    WorkingDir: "/Root/path"
    OperationType: ESchemeOpAlterTable
    AlterTable {
        Name: "TableName"
        PartitionConfig {
            PipelineConfig {
                EnableOutOfOrder: true
                NumActiveTx: 8
            }
        }
    }
}
```
#### Особенности реализации 
Реализацию усложняет ряд моментов:

* помимо планируемых транзакций (имеют порядок с координатора) в системе существуют мгновенные
* для проверки ключей нужно помнить не только активные, но и завершенные вне очереди транзакции
* для многошаговых транзакций нужно учитывать не только ключи непосредственной транзакции, но и локи, поставленные предыдущими "шагами"
* обработчику транзакций может быть неизвестна часть ключей транзакции (dynamic keys в MiniKQL)
* для обеспечения durability нужно блокировать out-of-order части транзакций на старте таблетки

Проверка конфликта транзакций сейчас происходит в варианте каждый с каждым. То есть вторая транзакция в окне при активации проверит конфликт с первой. Третья - с первой и второй и т.д. Этот подход приемлем для небольших окон обработки. При желании сильно увеличть окно обработки нужно придумывать алгоритм с лучшей O-сложностью. При этом большие окна опасны тем, что система может быстрее войти в перегруженное состояние.

Проверка конфликтов требует сравнение ключей транзакций. Это создает нагрузку на CPU. Для транзакций с большим числом ключей это может приводить к деградации. Такие транзакции будут выполняться in order. Это оправдано в том числе и потому, что вероятность конфликта с такой транзакций велика.

NOTE: Для многоключевых транзакций возможна оптимизация - формирование одиночных range-овых ключей покрываюих много точечных. Можно разменивать качество реордера на CPU. Сейчас не реализовано.

#### Детали реализации 
Out-of-order реодерит планируемые транзакции, которые выполняются в контексте TxProgressTransaction и активируются очередью PlanQueue. Формально очередь - это отправка шардом сообщения самому себе на пробуждение и старт транзакции TxProgressTransaction. Добавление события пробуждения в очередь PlanQueue просиходит либо по приходу PlanStep-а c координатора, либо по приходу ReadSet-ов от соседних шардов, либо из предыдущей TxProgressTransaction.

Транзакция в разные моменты времени в шарде может быть представлена разным набором данных. Обычный цикл выглядит так:
Step:TxId -> TValidatedDataTx -> TActiveTransaction -> TTransactionRest.

За хранение транзакций отвечают два класса Pipeline и TransQueue. TransQueue - это обертка над локальной базой шарда, из нее можно достать Step:TxId и текст транзакции. TValidatedDataTx, TActiveTransaction и TTransactionRest - это активные формы транзакции, которые представлены в Pipeline.

TActiveTransaction - транзакция в фазе выполнения или готовая к выполнению

TValidatedDataTx - текст транзакции, флаги + извлеченные ключи. Нужна для сравнения ключей транзакций

TTransactionRest - остаток от транзакции, выполненной вне очереди. Хранит отложенные активности транзакции, которые должны выполниться in-order

Основной механизм out-of-order-а реализован в функции Pipeline.GetNextActiveTx() которой TxProgressTransaction запрашивает очередную TActiveTransaction на выполнение.
В рамках этой функции Pipeline принимает решение:

1. подгрузить дополнительную транзакцию из TransQueue
2. выдать на выполение одну из известных транзакций
3. не выдать ни одной транзакции на выполнение

В первом случае подгрузив новую транзакцию Pipeline извлечет для нее ключи и проверит на конфликты другими активными транзакциями. Сверка ключей произойдет 1 раз, дальше Pipeline оперирует конфликтами. Как только для транзакции исчезли конфликты, она может быть выдана на выполение (п.2).

Помимо выбора следующей транзакции реализован механизм блокировки конвеера. При блокировке конвееру запрещено доставать новые транзакции из TransQueue. Если на DataShard прилетает immediate транзакция, которая не может выполниться (из-за конфликта по ключам), она добавляется в очередь DelayedTxs и блокирует конвеер. При блокировке Datashard сначала выполнит все известные ему транзакции (очистит Pipeline), потом выполнить все отложенные immediate транзакции из DelayedTxs, после чего перейдет в нормальный режим.

#### Конфликты транзакций 
Конфликты транзакций проверяются попарно. Читающие транзакции друг с другом не конфликтуют. Варианты конфликтов:

1. Транзакция пишет в ключ другой транзакции.
2. Транзакция пишет в лок другой транзакции.
По второму кейсу реализация не полная. Детали тут [ --Поддержать out-of-order транзакций с lock-ами-- ](https://st.yandex-team.ru/KIKIMR-3589)