---
sourcePath: overlay/internals/dynamicconfiguration.md
---
## Цель
Мы хотим постепенно отходить от статического конфигурирования кластера и хранения конфигов в файлах в сторону централизованного хранения конфигов и динамического конфигурирования. В качестве координатора конфигурирования кластера будет выступать сервис CMS (на данный момент его таблетка Console), который возьмет на себя следующие функции:

* хранение текущих конфигов кластера
* предоставление интерфейса для получения конфигов
* предоставление интерфейса для модификации конфигов
* сохранение согласованности конфигов
* доставка обновленных версий конфигов соответствующим сервисам и таблеткам

## Интерфейс
Сервис конфигурирования имплементирован в таблетке Console, интерфейс которой описан в [console.h](https://a.yandex-team.ru/arc/trunk/arcadia/kikimr/core/cms/console/console.h). Соответсвующие protobuf сообщения описаны в [console_config.proto](https://a.yandex-team.ru/arc/trunk/arcadia/kikimr/core/protos/console_config.proto). Внешний интерфейс к Console описан в [TConsoleRequest](https://a.yandex-team.ru/search?search=TConsoleRequest%20,msgbus.proto,,arcadia,,200) (данное собощение можно отправить в Console через CLI).

## Элементы конфига
Для запуска YDB на ноде нам нужен конфиг, описанный сообщением [TAppConfig](https://a.yandex-team.ru/search?search=message%20TAppConfig%20%7B,kikimr%2Fcore%2Fprotos%2Fconfig.proto,,arcadia,,200). Как правило, каждое поле TAppConfig описывает конфиг какого-то сервиса YDB. В CMS конфиг хранится как набор элементов [TConfigItem](https://a.yandex-team.ru/search?search=message%20TConfigItem%20%7B,console_config.proto,,arcadia,,200). Каждый элемент конфига содержит:
* **ID** - уникальный идентификатор + generation, используется для адресации элемента в командах модификации конфигов
* **Kind** - по сути это номер поля в сообщении TAppConfig, который определяет данный элемент
* **Config** - собственно сам конфиг сервиса указанного типа (либо пустой TAppConfig, либо с одним определенным полем в соответсвии с типом конфига)
* **UsageScope** - определяет, для каких нод кластера данный элемент применяется (см. [Области применения конфигов](#config-scope)
* **MergeStrategy** - определяет, как этот элемент объединяется с другими элементами того же типа
* **Order** - определяет порядок применения элементов одного типа и одной области применения
* **Cookie** - произвольная пользовательская строка, может быть использована для информационных целей. Поддерживается удаление элементов по Cookie

## Области применения конфигов {#config-scope}
Разные ноды кластера могут иметь разные конфиги. В таком случае у нас может быть множество конфигов одного и того же сервиса с разной областью применения. Области применения определяются одним или несколькими атрибутами ноды. Используемые атрибуты:

* номер ноды
* имя хоста
* имя тенанта
* тип ноды (всегда задается статически для всех нод при старте флагом --node-type; CMS не назначает тип ноды и не может его модифицировать; примером использования типа ноды может быть разделение по типу хоста - железная машина, большая виртуалка, маленькая виртуалка)

Области применения конфигов могут пересекаться. В этом случае используемый для ноды конфиг получается объединением всех подходящих конфигов. Если для одной ноды находится множество элементов конфига одинакового типа, то их объединение происходит следющим образом
1. Выбираем все подходящие элементы
2. Упорядочиваем элементы от менее приоритетных к более приоритетным. Приоритет зависит от области применения элемента (см. ниже). Если область применения двух элементов одинаковая, то их порядок определяется полем Order (элемент с меньшим значением Order считается менее приоритетным; Console запрещяет модификации конфигов, которые могут породить элементы с одинаковым приоритетом)
3. Берем конфиг из первого элемента, а потом последовательно добавляем к нему конфиги из следующих элементов в соответсвии с их MergeStrategy (см. [EMergeStrategy](https://a.yandex-team.ru/search?search=enum%20EMergeStrategy,console_config.proto,,arcadia,,200))

Области применения конфига определяют приоритет в зависимости от ограничейний, которые они накладывают. Более узкие области применения обладают большим приоритетом. Далее перечислены области применения в порядке уменьшения приоритета:

* **_Одна или несколько нод_** - задается перечислением номеров нод
* **_Один или несколько хостов_** - задается перечислением имен хостов
* **_Ноды заданного типа, принадлежащие определенному тенанту_** - задается именем тенанта и типом ноды
* **_Ноды определенного тенанта_** - задается именем тенанта
* **_Ноды заданного типа_** - задается типом ноды
* **_Ноды домена_** - наибольшая область применения конфига, так как Console работает в рамках одного домена

Не для всех элементов конфига можно использовать любую область применения. Например, для настроек логирования разумно использовать любую область применения, а вот настройки CMS должны быть только доменные. Возможные области применения для клонфигов определяются конфигом Console (см. [TUsageScopeRestrictions](https://a.yandex-team.ru/search?search=message%20TUsageScopeRestrictions,console_config.proto,,arcadia,,200)).

## Стартовый конфиг ноды
При старте ноды делается gRPC вызов в кластер для получения конфигов ноды из CMS. Для динамических нод получение конфигов из CMS является обязательным, для статических нод - опциональным (так как CMS может быть не доступен). Если какие-либо конфиги не были получены из CMS, то они могут быть прочитаны из файлов (т.е. конфиги из CMS являются более приоритетными)

## Динамическое применение новых конфигов
Для применения новых конфигов без рестарта в Console поддерживается механизм подписок на конфиги. Подписаться на конфиг может сервис или таблетка. Доставкой конфигов со стороны Сonsole занимается [TConfigsProvider](https://a.yandex-team.ru/search?search=class%20TConfigsProvider,,,arcadia,,200), который обнаруживает необходимость доставки нового конфига подписчику и создает акторы доставщики [TTabletConfigSender](https://a.yandex-team.ru/search?search=class%20TTabletConfigSender,,,arcadia,,200) и [TServiceConfigSender](https://a.yandex-team.ru/search?search=class%20TServiceConfigSender,,,arcadia,,200). Конфиг считается доставленным только после получения подтверждения об обработке конфига. Если доставка идет до таблетки, то считается, что таблетка сохранила конфиг у себя и его не надо будет доставлять повторно после рестарта таблетки. Сервис после рестарта пошлет повторный запрос на подписку и получит актуальный конфиг

Таблеткам стоит подписываться на конфиги напрямую в Console. Акторам и сервисам лучше оформлять подписку через [TConfigsDispatcher](https://a.yandex-team.ru/search?search=class%20TConfigsDispatcher%20,,,arcadia,,200), интерфейс которого описан в [configs_dispatcher.h](https://a.yandex-team.ru/arc/trunk/arcadia/kikimr/core/cms/console/configs_dispatcher.h). Configs Dispatcher может быть использован для простого получения конфига из Console. Также он может работать в качестве кеша конфигов (отвечает на get запросы конфигов, храня при этом их копию и подписываясь на их изменения). Также он может быть использован как прокси актор для подписки на конфиги в Console. Использование Configs Dispatcher для подписок на конфиги предпочтительно по нескольким причинам:
* Configs Dispatcher обладает более простым интерфейсом. Получение конфигов и подписки делаются только по типам конфигов, все остальные параметры Configs Dispatcher определяет сам
* Configs Dispatcher автоматически модифицирует все подписки при смене тенанта на ноде
* Configs Dispatcher позволяет многим акторам получать обновления конфигов, пользуясь только одной подпиской в Console. Это позволяет разгрузить Console от обработки большого количества подписок, а также уменьшает сетевой трафик с Console

## Модификация конфигов
CMS предоставляет интерфейс для добавления, удаления и модификации конфигов. Все возможные действия делаются через [TConfigureRequest](https://a.yandex-team.ru/search?search=message%20TConfigureRequest,,,arcadia,,200), который может содержать в себе множество действий по модификации конфигов. Все изменения применяются транзакционно. Поддерживается режим DryRun, для проверки валидности предлагаемых изменений. Также можно запросить в ответе старый и новый конфиги (если есть конфиги для тенантов или типов нод, то в ответе будут конфиги для всех возможных пар <тенант>-<тип ноды>), чтобы посмотреть фактические изменения

При добавлении новых конфигов не обязательно добавлять по одному элементу, можно загружать множество элементов в одном TAppConfig с опцией EnableAutoSplit. В этом случае по каждому не пустому полю в переданном конфиге будет создан новый элемент конфига

Перед применением модификации конфигов новые конфиги проверяются на валидность. Для этого используются валидаторы, интерфейс которых описан в [validator.h](https://a.yandex-team.ru/arc/trunk/arcadia/kikimr/core/cms/console/validators/validator.h). Валидаторы регистрируются с помощью метода RegisterValidator. При необходимости можно включать/выключать отдельные валидаторы через CMS WEB UI

Некоторые конфиги можно модифицировать напрямую через CMS WEB UI. На данный момент поддерживается несколько конфигов, которые могут применяться динамически и которые имеет смысл применять к определенным тенантам. Также поддержаны конфиги таблеток CMS и NodeBroker, которые мы не подаем через файлы
