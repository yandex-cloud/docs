Точкой входа транзакций в систему является одна из группы системных таблеток, называемых прокси транзакций (**TxProxy**). В отличие от прочих - как правило прокси транзакций закреплена за конкретной нодой кластера.

См. [Пайплайн выполнения транзакций](tx_processing_graph.md)

### Выполняемые роли 
  * Назначить уникальный TxId, которым будет адресоваться транзакция. Выбирается как составной ui64 из числа-идентификатора данной прокси (ui16, т.е. в кластере разрешено иметь не более 64к прокси (должно хватить всем)) и инкрементирующегося счётчика. Счётчик сохраняется в локальной базе, диапазон выделяется большими чанками по мере необходимости.
  * Провести запрос через стадии его обработки.

### Категории обрабатываемых запросов 
#### Операции со схемой 
Модифицирующие операции со схемой должны проходить через **TxProxy**, навигационные могут выполняться непосредственно над **[SchemeShard-ом](tablet_schemeshard.md)**, т.к. не требуют TxId.
    * Выбирается **Schemeshard**, обслуживающий часть схемы, к которой относится запрос
    * Запрос, с назначенным TxId пересылается на найденный **SchemeShard**.
    * После ответа **SchemeShard**-а отвечаем пользователю со статусом операции

Большая часть операций со схемой не происходит мгновенна и ответ пользователю происходит при приёме операции на выполнение, а не ждёт окончательного завершения выполнения.

#### MiniKQL транзакции над таблицами 
TxProxy обрабатывает уже скомпилированные программы и параметры. Компилятор не используется.

* Подставляются параметры, разбирается программа, выясняются затронутые ключи, формируются read-write наборы в терминах таблиц и диапазонов ключей в них.
* При пустом множестве затронутых таблиц (транзакция сугубо вычислительная) - транзакция выполняется, результат отсылается пользователю.
* Иначе формируется запрос в локальный кеш схемы.
    * Проверяются существование таблиц, типизация.
    * Формируется ACL затронутых путей и проверяется доступ пользователя, запросившего выполнение транзакции.
    * Выясняются списки **[Data Shard'ов](tablet_datashard.md)**, затронутых диапазонами ключей в таблицах.

* Полученные списки **Data Shard'ов** позволяются сформировать read-write наборы уже в терминах затронутых **Data Shard'ов**. Для каждого из **Data Shard'ов** формируется фрагмент программы, соответствующий этому **Data Shard'у**.
* Фрагменты программы рассылаются на Data Shard'ы.
* Если программа выполнима без участия **[Coordinator'а](tablet_coordinator.md)** (одношардовая, не требует назначения stepid) - то полученный результат отсылается пользователю.
* Если программу необходимо пропустить через **Coordinator** (многошардовая или требует назначения stepid) - то объединяем полученные с **Data Shard'ов** временные окошки для планирования.
* И если объединённое окно не пустое - выбираем **Coordinator**, через который будем пропускать транзакцию и отсылаем запрос на планирование транзакции.
* Дожидаемся результата и отвечаем пользователю.

Важно: **TxProxy** не ретраит выполнение, при ошибке на любом шаге - пользователю будет возвращена ошибка с детализацией что и где не получилось.

### Кеш схемы 
Т.к. схема динамическая, шардирование таблиц тоже динамическое - невозможно имея только запрос произвести проверку типов, авторизацию, определить затронутые шарды. Необходимо опрашивать **[SchemeShard'ы](tablet_schemeshard.md)**, чтобы не делать это на каждый запрос - результаты опроса схемы кешируются локально. Кеш не строгий, принудительная инвалидация при изменениях не производится. Обновление закешированного производится по времени хранения, либо при ошибке обработки запроса.