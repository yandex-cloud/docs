---
sourcePath: overlay/internals/tx_deterministic.md
---
### Deterministic Transactions
В качестве базовой модели выполнения распределённых транзакций в KiKiMR выбрана модель Determenistic Transactions.

Сводится она к тому, что порядок выполнения транзакций сериализуется (что эфемерно связывает с моментом начала выполнения каждой транзакцией конкретное глобальное состояние базы) и транзакция атомарно модифицирует глобальное состояние. В общем случае сделать это эффективно в распределённой среде невозможно. Но если представить транзакцию как self-contained операцию, на фиксированных входных данных (глобальном состоянии базы) детерминированно порождающую команду модификации - то появляются варианты.

В качестве базового рассматриваем класс транзакций, для которых возможно по телу транзакции вычислить набор читаемых ключей и набор записываемых ключей (read-write sets). Некоторые полезные классы так представить нельзя - например большинство операций над таблицами со вторичными ключами и запросы с косвенными чтениями - но не беда - для таких "неудобных" транзакций можно применить блокировки (предпочтительно оптимистичные, иногда можно и пессимистичный) или реализовать протокол оптимистичного коммита. Можно показать что даже в худшем случае конечная производительность системы будет не хуже чем при явной реализации 2PC, а во многих полезных случаях позволяет получить качественного роста пропускной способности системы не жертвуя консистентностью данных или изоляцией транзакций.

Транзакции описываем на MiniKQL - это позволяет извлекать read-write sets, анализировать граф выполнения для ограничения пересылки данных, встраивать достаточно сложную логику в тело транзакции, сохраняя детерминированность выполнения.

### Логика выполнения 
Само выполнение транзакции логически состоит из нескольких шагов:

  * формируем набор ключей, которые будем читать и набор ключей, в которые потенциально будем писать.
  * назначаем транзакции уникальную позицию на шкале времени.
  * таблетка в хронологическом порядке выполняет все транзакции, затрагивающие обслуживаемые ею ключи.
    * если затрагивает - выполняет чтение всех обслуживаемых ключей, входящих в read-набор.
    * если необходимо - рассылает прочитанное заинтересованным таблеткам из числи обслуживающих write-набор (заинтересованность вычисляется при анализе графа выполнения MiniKQL запроса).
    * если необходимо - дожидается получения read-наборов с других таблеток, необходимых для выполнения операций над ключами write-набора.
    * если затрагивает - выполняет необходимый фрагмент MiniKQL запроса и применяет модификации.

Интересным следствием является что если в транзакции нет кросс-зависимостей между ключами (модификация ключа **A** зависит от результата чтения ключа **B**, и одновременно модификация ключа **B** зависит от чтения ключа **A**) - то выполнение транзакции на каждой отдельной таблетке (как читающих, так и пишущих) не блокируется и возможна потоковая обработка с сохранением глобальной консистентности. Всё что для этого необходимо - это обеспечить достаточной поток готовых для выполнения транзакций.

С точки зрения инфраструктуры - запланированная транзакция не может не выполниться и любое выполнение является успешным. Логически в теле транзакции могут быть условия, выбирающие один из вариантов выполнения. В том числе отмена (полная либо частичная) применения модификаций.