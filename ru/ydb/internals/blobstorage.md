# Введение

BlobStorage (или Distributed Storage) —— это часть YDB, которая отвечает за надёжное хранение данных.


## Блобы

Данные хранятся в виде пар *ключ-значение*, которые называются *блобами*, где ключ —— идентификатор блоба —— имеет
определённую фиксированную структуру, ориентированную на *таблетки*, которые являются потребителем BlobStorage,
а значение —— бинарный блок сырых данных, имеющий размер от одного байта до некоторого фиксированного предела, который
в настоящий момент составляет 10 мегабайт. Блобы неизменяемые, то есть, значение, единожды записанное под определённым
ключом, не может быть изменено, а может быть только удалено.

Блобы пишутся таблетками. Таблетка передаёт в BlobStorage команды на запись блобов, предоставляя идентификатор блоба и
его значение. Удаление блобов производится посредством *барьерной* сборки мусора, в рамках которой BlobStorage информируется
о диапазонах идентификаторов блобов, которые больше не нужны. Возможно точечное исключение отдельных блобов по их ключу
из барьерной сборки мусора (то есть такие блобы не будут удаляться, хотя их идентификаторы будут попадать в интервал
идентификаторов, подлежащих удалению).

Помимо команд записи и сборки мусора используется команда для чтения целых блобов или их частей, а также ряд вспомогательных
команд, которые обеспечивают таблеточную машинерию, о которых будет написано далее.

## Идентификатор блоба

Каждый блоб идентифицируется в коде типом TLogoBlobID, который по сути является кортежем, состоящим из следующих числовых полей:

| № п/п | Название     | Разрядность | Описание                                                                           |
|-------|--------------|-------------|------------------------------------------------------------------------------------|
| 1     | `TabletId`   | 64          | идентификатор таблетки, которой принадлежит данный блоб                            |
| 2     | `Channel`    | 8           | номер канала таблетки, в рамках которого хранится блоб                             |
| 3     | `Generation` | 32          | поколение таблетки, в рамках которого был записан блоб                             |
| 4     | `Step`       | 32          | шаг внутри поколения, когда был записан блоб                                       |
| 5     | `Cookie`     | 32          | непрозрачное поле, заполняемое таблеткой                                           |
| 6     | `BlobSize`   | 28          | размер блоба (поскольку блобы иммутабельные, он известен при записи и не меняется) |
| 7     | `PartId`     | 4           | номер фрагмента блоба (при распределённом хранении)                                |

Идентификаторы блобов *упорядочены*. Сравнение производится в лексикографическом порядке согласно таблице выше. Порядок
полей в конструкторе TLogoBlobID несколько отличается от перечисленного в таблице; кроме этого, строковое представление
идентификатора также имеет другой порядок полей:

```
[TabletId:Generation:Step:Channel:Cookie:BlobSize:PartId]
```

Назначение всех полей непрозрачно для BlobStorage, однако некоторые поля могут использоваться в других структурах. Например,
`TabletId`, `Channel`, `Generation` и `Step` используются в барьерной сборке мусора, о которой будет рассказано далее.

Запись блобов идемпотентна, каждый блоб может быть записан несколько раз, но данные для каждой копии должны быть теми же,
что были записаны ранее. Не может быть двух блобов, которые совпадают в `TabletId`, `Channel`, `Generation`, `Step`, `Cookie`,
но различаются в `BlobSize`. При записи блоба `PartId` должен быть выставлен в `0`. Идентификатор фрагмента используется
внутри BlobStorage для служебных целей.


## Группы

Данные хранятся в *группах*. Группа -- это распределённый набор логических элементов хранения, которые функционируют
независимо друг от друга и не допускают коррелированного отказа. Каждая установка YDB состоит из множества групп.

На практике группа представляет собой несколько фрагментов физических дисков, установленных на разных машинах, в
некоторых случаях, расположенных в разных ДЦ.

Каждая группа имеет свой числовой 32-битный идентификатор.

Группы бывают статическими и динамическими. Статические группы описаны в конфигурационных файлах YDB (bs.txt) и их
описание должно совпадать на всех машинах, которые их могут использовать. Внутри статических групп хранятся данные для
т.н. системных таблеток, которые позволяют обеспечить запуск динамических групп и пользовательских таблеток поверх тех
групп. Динамические группы управляются системной таблеткой BS_CONTROLLER.

С точки зрения клиента статические и динамические группы ничем не различаются. Вопрос лишь в их администрировании.

Взаимодействие с BlobStorage производится посредством DS_PROXY. DS_PROXY -- сущность, используемая для манипулирования
данными в группе, запускаемая на конкретном узле системы -- обеспечивает взаимодействие с одной конкретной группой.

На каждом узле может быть запущено несколько DS_PROXY, в зависимости от того, с каким количеством групп должен
взаимодействовать тот или иной узел.

Каждая таблетка может хранить свои данные в нескольких группах. Для этого вводится соответствие между `TabletId:Channel`
и группой, в которую идёт запись. При каждом перезапуске таблетки запись может начинаться в другие группы, не в те,
что были в предыдущем поколении. Поэтому для выполнения чтений для каждой канала таблетке передаётся *история групп*
этого канала, в которой перечислены диапазоны поколений и соответствующие им номера групп.

Иными словами, каждой тройке `TabletId:Channel:Generation` можно поставить в соответствие номер группы, в которой хранятся
данные указанной таблетки в указанном поколении для указанного канала.


## Барьеры

Для удаления блобов используется механизм барьерной сборки мусора, который позволяет формировать интервалы идентификаторов
блобов, которые больше не нужны. Механизм барьеров ставит в соответствие каждой паре `TabletId:Channel` свою пару
`CollectGeneration:CollectStep`, называемую барьером, которая предписывает удалять все блобы с совпадающим `TabletId:Channel`
и `Generation:Step <= CollectGeneration:CollectStep`.

Таким образом, например, если для `TabletId:Channel = 1:25` указан `CollectGeneration:CollectStep = 10:1`, то блоб с
`Generation:Step = 9:1` попадает под сборку мусора, а блоб с `Generation:Step = 10:2` —— нет.

Для сохранения возможности передвижения барьера без удаления некоторых блобов предусмотрена возможность выставлять т.н.
Keep/DoNotKeep-флаги. Каждому блобу, помимо идентификатора и данных, ставятся в соответствие два флажка: Keep и DoNotKeep.
При выполнении барьерной сборки мусора выполняется дополнительная проверка: если блоб попадает в интервал сборки мусора,
но у него стоит Keep-флаг и не стоит DoNotKeep-флаг, то этот блоб не удаляется. Если же DoNotKeep-флаг стоит и блоб
попадает в интервал сборки мусора, то он удаляется.

Правильный сценарий использования Keep/DoNotKeep-флагов следующий:

1. Таблетка записывает блоб с идентификатором X.
2. Когда возникает необходимость удалить данные, кроме блоба X, таблетка отправляет команду установки Keep-флага на блоб X.
3. После этого таблетка передвигает барьер за блоб X.
4. Когда блоб X становится не нужен, таблетка отправляет команду на установку флажка DoNotKeep на блоб X.

Помимо обычных барьеров есть механизм жёстких барьеров (hard barrier), который хранит данные в аналогичном формате (то
есть для каждой пары `TabletId:Channel` указывается свой `CollectGeneration:CollectStep`), но при проверке механизмом
жёстких барьеров не учитываются флажки Keep и DoNotKeep.

Механизм жёстких барьеров используется для удаления таблеток целиком. Существует два сценария использования жёстких
барьеров:

1. Удаление таблетки целиком. В этом сценарии в каждой группе, в которую производила запись таблетка, передаётся
   жёсткий барьер с указанием `CollectGeneration:CollectStep = Max:Max`.
2. Удаление старых данных на случай утечек и других непредвиденных обстоятельств. Для этого, когда точно известно,
   что данные в определённом диапазоне Generation больше не нужны, выставляется барьер в `(Generation - 1):Max`.

## Блокировки

Механизм блокировок позволяет решить проблему гонки запускаемых таблеток в распределённой системе в случае частичного
отказа, партиционирования и других прелестей.

Каждой таблетке, идентифицируемой `TabletId`, в соответствие ставится `BlockedGeneration`. Если приходит команда на изменение,
у которой `Generation <= BlockedGeneration`, то в ответ на эту команду генерируется ошибка BLOCKED. Здесь стоит отметить,
что во всех командах, которые изменяют состояние групп, так или иначе есть Generation таблетки, которая выполняет операцию.

Таблетка, получив BLOCKED, понимает, что где запущен более свежий экземпляр и ей менять базу нельзя, после чего она спокойно
самоликвидируется за ненадобностью.

Соответственно, каждая таблетка перед запуском выдаёт команду на блокировку, указывая своё поколение. Если команда
проходит успешно, то таблетка запускается дальше.


## Команды

Все команды отправляются в BlobStorage через DS_PROXY, который запускается локально автоматически при получении
первой команды в определённую группу. Команды могут отправляться параллельно (то есть следующую комануд можно отправлять,
не дожидаясь ответа на предыдущую), если порядок выполнения команд не важен. В случае, когда порядок должен быть
фиксированный (например, запись блоба, а затем установка на него Keep-флага и барьера, поглощающего этот блоб),
команды должны выполняться последовательно.

Результат выполнения команд, как правило, может быть следующим:

1. OK —— команда выполнена успешно.
2. ERROR —— некорректная команда или временная ошибка (например, нет кворума по числу работающих узлов хранилища).
3. ALREADY —— такая команда уже приходила и уже выполнена.
4. BLOCKED ­—— команда отправлена от устаревшей таблетки (поколение уже заблокировано).
5. RACE —— в процессе выполнения команды группа поменяла состав, нужно повторно отправить команду


В процессе выполнения команд они рассылаются на VDisk'и, которые составляют группу. Каждый VDisk отвечает на свою команду
определённым кодом возврата, среди которых можно выделить ERROR, RACE и BLOCKED. ERROR отвечается обычно в тех случаях, когда
диск недоступен или неработоспособен. Это состояние может быть как проходящим, так и нет, но кворум ответов будет собираться
в момент выполнения команды верхнего уровня DS_PROXY. Если ERROR'ов будет достаточно для определения превышения модели отказа
группы, то результатом выполнения всей команды станет тоже ERROR, хотя, стоит отметить, что фактически команда может выполниться
(например, при выставлении блокировки достаточно, чтобы она доехала хотя бы до одного VDisk'а, а дальше они через внутренний
механизм синхронизации растиражируют её на все группы; однако, чтобы убедиться, что команда прошла, DS_PROXY будет ждать кворума
от всех дисков группы, не дожидаясь N последних).

Если от VDisk'а приходит ответ RACE, то это значит, что в процессе выполнения команды сменилось поколение группы, что значит, что
изменился её состав -- часть VDisk'ов могла переехать с одних узлов и дисков на другие. В этом случае выполнение команды прерывается
безусловно и на всю команду верхнего уровня будет вырабатываться ответ RACE. В этом случае клиенту достаточно просто повторно
отправить ту же команду на группу.

Если от VDisk'а приходит ответ BLOCKED, это значит, что отправленная команда сгенерирована таблеткой, которая уже неактуальна и
наличествует более свежее поколение этой таблетки. Получив BLOCKED, таблетка должна покончить с собой, приняв пилюлю с ядом, т.к.
существует её более свежая версия.


### TEvPut

Команда записи блоба, которой на вход подаётся идентификатор записываемого блоба и его содержимое.

Длина записываемого блоба должна соответствовать BlobSize в поле идентификатора. Кроме этого, не допускается запись
блоба, идентификатор которого попадает под сборку мусора с момента записи.

Блоб можно считать записанным после получения ответа OK от DS_PROXY. Однако стоит помнить, что блоб может быть записан фактически,
но ответ может быть отличен от OK.


### TEvCollectGarbage

Команда записи барьера. На вход получается список блобов, которым нужно выставить Keep-флаг, такой же по формату список,
но для DoNotKeep флага, а также `TabletId:Channel`, `Generation:PerGenerationCounter` и `CollectGeneration:CollectStep`.

Особое внимание стоит уделить `Generation:PerGenerationCounter` —— это пара, образуемая текущим поколением запущенной
таблетки, а также счётчиком внутри этого поколения, который должен быть уникальным для каждой команды и монотонно расти.
Команда идемпотентная, то есть может повторяться для одинакового набора параметров.

При выполнении гарантируется, что Keep и DoNotKeep-флаги применятся раньше барьера.

Фактическая сборка мусора выполняется асинхронно и зависит, как правило, от потока данных, идущих на группу. Чем выше
поток, тем чаще выполняется сборка мусора.


### TEvBlock

Команда выставляет блокировку для запущенной таблетки. На вход подаётся `TabletId` и `Generation` запущенной таблетки,
для блокировки выставляется `BlockedGeneration = Generation - 1`.


### TEvDiscover

Данная команда является частью специализированной машинерии для логики таблетки и позволяет получить перечень блобов
в нулевом канале таблетки, в котором хранится её журнал изменений. Возвращается заблокированное поколение указанной
таблетки, а также список гарантированно записанных блобов в нулевом канале указанной таблетки, возможно, с их содержимым
(в зависимости от указанных параметров).


### TEvRange

Данная команда также используется при первоначальном запуске таблеток и возвращает список блобов, принадлежащий одной таблетке,
имеющих идентификаторы из указанного диапазона.


### TEvGet

Команда используется для чтения блобов с указанными идентификаторами. Чтение может выполняться как полностью (тогда возвращается
весь блоб), так и частично, тогда возвращается только часть блоба. При использовании частичного чтения оптимизируется доступ к
хранилищу, поэтому при необходимости прочитать только фрагмент блоба стоит использовать этот режим.


## VDisk

VDisk —— это строительный блок группы, который обеспечивает ей отказоустойчивость. Записываемые в группу данные распределяются на несколько
VDisk'ов так, что допускается отказ одного или несколько дисков, в зависимости от модели отказа группы. VDisk запускается поверх PDisk'а и
имеет идентификатор вида [82000000:1:0:0:0], где первое поле содержит идентификатор группы, записанный в шестнадцатеричном формате, второе поле ——
поколение группы, в рамках которого запущен VDisk, а остальные три указывают координаты VDisk'а в группе. Координаты включают в себя Fail Realm,
номер Fail Domain'а внутри Fail Realm'а и номер VDisk'а внутри Fail Domain'а. Группа имеет форму прямоугольного параллелепипеда вида X×Y×Z, где
X —— общее число Fail Realm'ов, Y —— число Fail Domain'ов внутри каждого из Fail Realm'ов и Z —— число VDisk'ов в каждом Fail Domain'е.

Параметры X, Y и Z зависят от способа кодирования данных в группе. Фактически используются следующие варианты кодирования:

1. none: 1×1×1
2. block-4-2: однодатацентровое кодирование, 1×8×1
3. mirror-3-dc: мультидатацентровое кодирование, 3×3×1

Считается, что для однодатацентровых вариантов вероятность одновременного отказа двух доменов ничтожно мала; для трёхдатацентрового варианта кодирования
считается, что существует вероятность отказа ДЦ целиком, но вероятность одновременного отказа двух ДЦ ничтожно мала.

