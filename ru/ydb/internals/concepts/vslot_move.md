## Перевоз VDisk

Перевоз VDisk'ов с PDisk'а имеет смысл делать в следующих случаях:

 * для балансировки нагрузки (например, при расширении кластера); но для этого случая есть отдельные инструменты
 * если PDisk сломался и не вернётся в строй в ближайшее время (для этого будет автоматика, но сейчас это можно делать руками)

Важно при перевозе учитывать, что данные на том VDisk'е, который перевозится, будут безвозвратно потеряны. Поэтому, в частности, нельзя делать перевоз, если группа не является рабочей. Для block-4-2 нужно учитывать, что после уничтожения данных на исходном диске должно остаться 6 работающих и полностью реплицированных VDisk'ов в группе. Если какие-то ноды из группы отключены (но данные на них не потеряны), то данные в результате перевоза не потеряются, но группа не сможет работать и данные не будут реплицироваться до тех пор, пока не будет восстановлена модель отказа для группы. Для mirror-3-dc модель отказа подразумевает, что может выйти из строя до одного датацентра целиком, а также одна стойка из другого датацентра.

Посмотреть состав группы можно во вьюере во вкладках Storage или Nodes. Работающие VDisk'и имеют зелёный цвет. Реплицирующиеся -- синий.

В случае, если сломался PDisk целиком, то нужно увезти с него все слоты, которые поверх него созданы. Их можно увидеть во вьюере. Для этого нужно для каждого VDisk'а выполнить команду перевоза. Важно учитывать, что обычно на одном наборе PDisk'ов находится один и тот же набор групп (то есть несколько групп под собой имеют одинаковый набор PDisk'ов). При перевозе всех VDisk'ов с PDisk'а следует сохранять эту тенденцию, если она была изначально.

Кроме этого, стоит учитывать, что на каждом PDisk'е число слотов может быть ограничено. Если не задано иное, BS_CONTROLLER по умолчанию считает максимумом 16 слотов (VDisk'ов) на PDisk.

Для перевоза нужно использовать команду ReassignGroupDisk:

```
message TPDiskId {
    uint32 NodeId = 1;
    uint32 PDiskId = 2;
}

message TReassignGroupDisk {
    uint32 GroupId = 1;
    uint32 GroupGeneration = 2;
    uint32 FailRealmIdx = 3;
    uint32 FailDomainIdx = 4;
    uint32 VDiskIdx = 5;
    TPDiskId TargetPDiskId = 6; // optional; when not specified, selected automatically
}
```

Первые пять полей в TReassignGroupDisk -- это фактически VDiskId в том порядке, в котором он записывается в системе. TargetPDiskId -- это идентификатор PDisk'а, на котороый нужно перевезти данные. GroupGeneration нужно указывать актуальный, этот механизм является, в частности, защитой от гонок при параллельном перевозе данных в группе.

Порядок операций для перевоза вручную выглядит так:

1. Посмотреть, что группа находится в рабочем состоянии и что перевоз её не сломает. Запомнить её Generation.
2. Выполнить команду

```
$ kikimr -s <host> admin bs config invoke --proto "Command { ReassignGroupDisk { GroupId: XXX GroupGeneration: YYY FailRealmIdx: A FailDomainIdx: B VDiskIdx: C TargetPDiskId { NodeId: N PDiskId: P } } }"
```

В результате должно быть сообщение вида:

```
Status {
    Success: true
}
Success: true
```

Внешний Success -- это успешность всей транзакции, а внутренний -- конкретно операции ReassignGroupDisk. Операция выполняется многоступенчато, поэтому сама команда может быть успешна, а применение конфигурации -- нет.

Если операция не удалась, то в ErrorDescription будет написана причина.

Если сама операция выполнилась успешно, стоит понаблюдать за тем, как идёт репликация. Это можно увидеть по графикам в Solomon (ReplUnreplicatedVDisks показывает, на скольких дисках репликация ещё не завершилась; ReplVGetBytesReceived показывает сетевой траффик репликации в байтах в секунду). Нереплицированный диск во вьюере имеет синий цвет.
