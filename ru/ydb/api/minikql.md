### Основные положения

Этот документ описывает дизайн языка **miniKQL** (от **KikiMR** Query Language), позволяющий задать набор операций, которые можно выполнить в одну транзакцию **KikiMR**.
Этот язык также является базовым для более сложных языков, например, для аналитического движка.

В **KikiMR** есть два режима работы транзакций:
  * **online** транзакции, в процессе которых можно использовать операции чтения и записи, и для которых будет создан уникальный идентификатор выполнения, состоящий из пары чисел Step:TransactionID.
  * **head** транзакции мгновенного чтения/записи (если такая операция возможна). Для этого типа транзакций Step не задается. Порядок транзакции относительно других определяется в момент ее выполнения.
  * **snapshot** транзакции, в процессе которых можно использовать только операции чтения, и которые требуют идентификатор snapshot-а. Таким идентификатором является либо пара Step:TransactionID некоторой предыдущей online транзакции, либо "метка времени", совместимая с политикой хранения снапшотов. В последнем случае Step является "меткой времени", а TransactionID равен нулю. Для snapshot транзакций не создается отдельной пары Step:TransactionID в процессе выполнения.

Язык **miniKQL** является декларативным языком, все операции в нем строго типизированы и порождают иммутабельные значения.
Концептуально, он описывает граф чтения базы **KikiMR**, проведения вычислений над ними, и запись результатов в выходной документ и/или базу.

Из требования выполнения за одну транзакцию **KiKiMR** следует
  * необходимость доказуемой возможности выполнения транзакции за один раунд чтения.
  * детерминированность выбора веток выполнения.

Смотрите так же:
* [MiniKQL AST](minikql_ast.md)

[Описание S-expressions синтаксиса YQL - Типы](https://yql.yandex-team.ru/docs/ydb/s_expressions/)
### Модель данных

#### Функции

В языке есть определенный набор встроенных функций. А также можно создавать новые чистые пользовательские функции, в том числе путем их подключения как UDF.
Функция задается именем, прототипом и опциональным телом (не нужен для UDF). В прототипе описывается типы всех входных аргументов, а также тип результата. Тип **Void** запрещен в качестве результата чистой функции. В точке вызова указывается имя функции, причем будет произведен поиск подходящих функций по прототипу на этапе компиляции.

Для функций вида **Map**, **Fold**, **IfPresent**, **If** некоторыми входными аргументами являются функции. Пользовательские функции также могут использовать в качестве входных аргументов или результата другие функции, как встроенные, так и пользовательские. Таким образом тип **Function** - первого класса.

Внутри пользовательских функций не допускается производить работу с базой или документом.
Как для каждого аргумента, так и для результата функции может быть указано требование, чтобы значение было доступно без выполнения транзакции.
Такие аргументы или функции называются статическими.

#### Ограничения, общая структура программы и параметры

На объекты в программе могут быть наложены следующие ограничения, каждое из которых включает предыдущее:

  1. **immediate** значение должно быть непосредственно при формирования графа. 
  2. **static** значение должно быть доступно или непосредственно, или как результат статической функции. 
  3. **dynamic** значение может быть получено при выполнении транзакции - например, путем чтения из базы.

Построение программы на языке miniKQL производится в два шага - 

  1. Построение графа программы. (**Prepare**). Одна из вершина графа является корнем программы, и ее тип должен быть **List of Void**.
  2. Заполнение результатов во всех статических функциях, содержащихся в графе программы. (**Bind**)

При использовании стандартной функции **Parameter** в граф будет вставлена статическая функция, содержащая тип и имя параметра.
На шаге **Bind** должны быть переданы все значения параметров.
Таким образом, на месте любого не **immediate** аргумента можно подставить параметр.

### Операции, работающие с табличной базой

#### Чтение строки **SelectRow**(table,key,fields,[target])

Входные аргументы:
table : Atom - имя таблицы
key : Tuple literal of Tuple literal of (columnName: Atom, columnValue: *) - ключ состоит из последовательности пар имя столбца - значение.
Должны быть заданы все ключевые колонки таблицы в том порядке, в котором они объявлены в таблице.
fields: Tuple literal of columnName: Atom - список колонок, значение которых нужно прочитать. Могут быть и ключевыми и неключевыми.
target: Atom - опциональный режим чтения. online - чтение констистентное, head - чтение неконсистентное (аналог read committed), slave - чтение со slave таблетки. По умолчанию - online.
target: Atom - опциональный режим чтения. online - чтение констистентное, head - чтение неконсистентное (аналог read committed), slave - чтение со slave таблетки. По умолчанию - online.

Результат:
Optional of RowType, где RowType = Struct Of field: Type of column

Если строка найдена по ключу, возвращает заполненный Optional с заданными значениями, которые всегда имеют тип Optional of Data.
Если строка не найдена, возвращает пустой Optional.

#### Чтение диапазона строк **SelectRange**(table,range,fields,options,[target])
table : Atom - имя таблицы
range: Tuple literal of Tuple literal of (columnName: Atom, FromColumnValue: * ToColumnValue: *) - диапазон состоит из последовательности троек имя столбца - начальное значение - конечное значение.
Если нужно в значении представить Infinity, то оно задается как литеральный Void. Все последующие элементы также должны быть Void.
fields: Tuple literal of columnName: Atom - список колонок, значение которых нужно прочитать. Могут быть и ключевыми и неключевыми.
options: Tuple literal of option
Варианты option:
Atom=ItemsLimit Value: Literal of Ui64 - задать ограничение в количестве возвращенных строк
Atom=BytesLimit Value: Literal of Ui64 - задать ограничение в количестве возвращенных байт (примерное)
target: Atom - опциональный режим чтения. online - чтение констистентное, head - чтение неконсистентное, slave - чтение со slave таблетки. По умолчанию - online.

Результат:
Struct of (List: List of RowType, Truncated: Bool), где RowType = Struct Of field: Type of column

Возвращает список строк для заданных в fields колонок. Если сработал лимит ItemsLimit или BytesLimit, а в выдаче еще могли бы быть данные, устанавливается Truncated в true.

#### Обновление строки **UpdateRow**(table,key,update)

Входные аргументы:
table : Atom - имя таблицы
key : Tuple literal of Tuple literal of (columnName: Atom, columnValue: *) - ключ состоит из последовательности пар имя столбца - значение.
Должны быть заданы все ключевые колонки таблицы в том порядке, в котором они объявлены в таблице.
update: Tuple literal of UpdateCommand
Варианты UpdateCommand:
Tuple literal of (ColumnName:Atom) - стереть значение в неключевой колонке с именем ColumnName
Tuple literal of (ColumnName:Atom, Value:*) - установить значение в неключевой колонке с именем ColumnName на переданное значение. Тип данных должен совпадать с типом колонки и быть либо Data, либо Optional Of Data.
--Tuple literal of (ColumnName:Atom, InplaceOp: Atom, Value:*) - произвести свертку значение в неключевой колонке с именем ColumnName с переданным значением. Тип данных должен совпадать с типом колонки и быть Data. Поддерживаемые InplaceOp: Min, Max, Sum, IfNotExistOrEmpty.--

Все имена колонок в разных UpdateCommand должны быть уникальны.

Результат:
Void

Обновляет/создает строку по ключу.

#### Стирание строки **EraseRow**(table,key)

Входные аргументы:
table : Atom - имя таблицы
key : Tuple literal of Tuple literal of (columnName: Atom, columnValue: *) - ключ состоит из последовательности пар имя столбца - значение.
Должны быть заданы все ключевые колонки таблицы в том порядке, в котором они объявлены в таблице.

Результат:
Void

Удаляет строку по ключу.

### Встроенные функции

((https://wiki.yandex-team.ru/yql/s-expressions/#funkcii Описание S-expressions синтаксиса YQL - Функции))

#### Работа с параметрами

  * **Parameter**(name, type)->**T** Объявить параметр с заданным именем. 

name: **immediate** имя параметра
type: Type of T **immediate** тип параметра

Результатом функции является **static** значение с типом **T**, которое надо будет заполнить на фазе **Bind**.

#### Специальные функции

  * **SetResult**(name, value). Задает именованный параметр как результат запроса.

  * **Abort**(). Изменить код результата транзакции с Complete на Aborted. Удобно для того, чтобы признак отката транзакции не записывать в документ. Не блокирует другие сайд-эффекты, такие как запись в базу/документ. Допускается исполнение несколько раз.

  * **StepTxId**(). Возвращает пару Step+TxId. Step - монотонно растущее время. TxId - уникальный идентификатор транзакции. Если транзакция выполняется без участия координатора, то Step равен 0.

  * **AcquireLocks**(UInt64). Запрашивает установку оптимистичных локов на группу транзакций. Принимает LockTxId, равный первой TxId в группе транзакций. Если параметр равен нулю - начинает новую группу транзакций. Возвращает список установленных локов (групп из 4 чисел) на даташардах. При попытке вызова функции на модифицирующей транзакции возвращает ошибку.

  * **Diagnostics**(). Возвращает помимо результатов диагностическую информацию о транзакции. Формат выдачи не фиксирован, может меняться от версии к версии.

### Извлечение результата

Результат запроса задается оператором return. В нем также должны быть перечисленны сайд-эффекты, иначе они могут быть исключены из выполнения оптимизатором (например, результаты функции UpdateRow()). Тип результата определяется программой.
Разбор результата можно осуществлять по именам, либо по индексам. Клиент получив дерево типов может отмапить имена в индексы. Для одного prepared query гарантируется, что при выполнении с разными параметрами будет одно и тоже дерево типов результата. Т.е. одинаковые индексы в рамках одной prepared queue будут соответствовать одинаковым колонкам.