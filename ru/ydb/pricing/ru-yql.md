# Правила оценки стоимости YQL-запросов к {{ ydb-short-name }}

При выполнении YQL-запроса используются ресурсы на стороне сервера. Информация о потребленных ресурсах доступна в статистике исполнения запроса.

Для определения стоимости запроса через {{ ydb-short-name }} API вычисляются стоимость использования CPU и стоимость ввода-вывода данных. Из вычисленных значений выбирается максимальное.
* Стоимость использования CPU.

  Суммируется время CPU, затраченное на компиляцию запроса, а также время использования CPU на всех этапах выполнения запроса. Сумма делится на продолжительность одного окна 1,5 мс, округляется в меньшую сторону и переводится в RU по тарифу из таблицы ниже.

  Закешированные запросы повторно не компилируются. Чтобы воспользоваться кешированием, применяйте в запросах `bind variables`, а также включите флаг сохранения плана исполнения запроса в кеше.
* Стоимость ввода-вывода данных.

  Рассчитываются следующие значения:
  * Количество операций чтения с диска. Сравнивается число прочитанных записей и блоков данных, выбирается наибольшее из них. Число блоков вычисляется делением суммы прочитанных байт на размер блока 4 КБ, с округлением вверх.
  * Количество операций записи на диск. Сравнивается число записанных записей и блоков данных, выбирается наибольшее и них. Число блоков вычисляется делением суммы записанных байт на размер блока 1 КБ, с округлением вверх.

  Учитывается ввод-вывод данных в таблицы и индексы. При удалении записей учитывается только их количество.

  Количества операций чтения и записи переводятся в RU по тарифу из таблицы ниже, полученные стоимости складываются.

{% note warning %}

Некоторые преобразования над записями требуют их чтения или удаления перед изменением, это может повлиять на стоимость запроса.

{% endnote %}

Стоимость единиц выполнения запроса в RU:

Оцениваемый параметр | Стоимость
:--- | :---:
Одно окно использования CPU | 1 RU
Одна операция чтения | 1 RU
Одна операция записи | 2 RU

Не тарифицируется следующие операции:
* Создание, изменение и удаление схем таблиц.
* Получение описания и списка таблиц.
* Создание и удаление директорий.

{% cut "Пример расчета стоимости запроса" %}

Статистика запроса:

```text
query_phases {
  ...
  table_access {
    ...
    reads {
      rows: 2
      bytes: 16
    }
    ...
  }
  cpu_time_us: 475
  ...
}
query_phases {
  ...
  table_access {
    ...
    updates {
      rows: 2
      bytes: 2456
    }
    ...
  }
  cpu_time_us: 514
  ...
}
compilation {
  ...
  cpu_time_us: 4062
}
process_cpu_time_us: 870
```

Где:
* `query_phases[].cpu_time_us` — время CPU на выполнение запроса в мкс.
* `compilation.cpu_time_us` — время CPU на компиляцию запроса в мкс.
* `process_cpu_time_us` — время CPU на управление взаимодействием в мкс.
* `query_phases[].reads.rows` — число прочитанных записей данных.
* `query_phases[].reads.bytes` — число прочитанных байт данных.
* `query_phases[].updates.rows` — число записанных записей данных.
* `query_phases[].updates.bytes` — число записанных байт данных.

Чтобы получить стоимость использования CPU, сумма времени CPU запроса делится на 1,5 мс, `( 475 + 514 + 4062 + 870 ) / 1500 = 3,95`. Результат округляется в меньшую сторону и переводится в RU:

```text
3 × 1 RU = 3 RU
```

Чтобы получить стоимости ввода-вывода данных:
* Вычисляется количество операций чтения с диска в записях и блоках, из них выбирается максимальное:
  * Прочитаны 2 записи, количество операций равно 2.
  * Прочитаны 16 байт, `16 / ( 4 × 1024 ) = 0,004`, результат округляется в большую сторону, количество операций равно 1.

  Количество операций чтения равно 2.
* Вычисляется количество операций записи на диск в записях и блоках, из них выбирается максимальное:
  * Записаны 2 записи, количество операций равно 2.
  * Записаны 2456 байта, `2456 / 1024 = 2,398`, результат округляется в большую сторону, количество операций равно 3.

  Количество операций записи равно 3.

Стоимость ввода-вывода:

```text
2 × 1 RU + 3 × 2 RU = 8 RU
```

Стоимость выполнения запроса равна 8 RU.

{% endcut %}