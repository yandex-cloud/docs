# Анализ производительности и оптимизация

В данном сценарии вы узнаете:

- как использовать [инструменты мониторинга](../operations/monitoring.md) {{ MG }} для диагностики производительности кластера {{ mmg-name }};
- как устранять обнаруженные проблемы.

Снижение производительности кластера {{ mmg-name }} чаще всего происходит по одной из следующих причин:

- [высокая утилизация CPU и дискового I/O](#cpu-io-deficit),
- [неэффективное выполнение запросов в {{ MG }}](#inefficient-queries),
- [блокировки](#locks),
- [недостаток дискового пространства](#disk-deficit).

Ниже приводятся советы по диагностике и решению этих проблем.

## Перед началом работы {#before-start}

1. Установите на внешнем хосте, имеющем сетевой доступ к хосту {{ MG }} (см. [{#T}](../operations/connect.md)), [утилиты](../operations/monitoring.md#use-monitoring-tools) получения данных о производительности {{ MG }} `mongostat` и `mongotop`.
1. Определите, для каких баз данных нужно выполнить поиск проблем.
1. Создайте [пользователя {{ MG }}](../operations/cluster-users.md#adduser) с ролью [`mdbMonitor`](../concepts/users-and-roles.md#mdbMonitor) для этих баз. Это необходимо для использования утилит `mongostat` и `mongotop`.

## Диагностика дефицита ресурсов {#cpu-io-deficit}

Если какой-то из ресурсов CPU и дискового I/O «вышел на плато» — постоянно росший до этого момента график остановился на одном уровне — скорее всего, соответствующий ресурс стал дефицитным и это привело к падению производительности. Чаще всего это происходит потому, что использование ресурса достигло [лимита](../concepts/limits.md).

В большинстве случаев высокая утилизация CPU и высокие Disk IO связаны с неоптимальными индексами или большой нагрузкой на хосты.

Начните диагностику с выяснения характера нагрузки и определения проблемных коллекций. Воспользуйтесь встроенными [утилитами мониторинга {{ MG }}](../operations/monitoring.md#use-monitoring-tools). Далее проанализируйте производительность конкретных запросов с помощью [логов](../operations/monitoring.md#explore-logs) или [данных профилировщика](../operations/monitoring.md#explore-profiler).

Обратите внимание на следующие операции:
  - Запросы, не использующие индексы (`planSummary: COLLSCAN`). Такие запросы могут увеличивать как потребление I/O (чтений с диска будет больше), так и CPU (данные сжаты по умолчанию, для них требуется декомпрессия). Если необходимый индекс есть, но БД его не использует, можно форсировать использование индекса с помощью [hint](https://docs.mongodb.com/manual/reference/operator/meta/hint/index.html).
  - Запросы с большими значениями параметра `docsExamined` (количества просканированных документов). Это может означать, что текущие индексы неэффективны или требуются дополнительные.

В момент падения производительности проблему можно диагностировать в реальном времени с помощью [списка текущих запросов](../operations/monitoring.md#list-running-queries):
  - Долгие операции, например, исполняющиеся более секунды:
    ```
    db.currentOp({"active": true, "secs_running": {"$gt": 1}})`
    ```
  - Операции по созданию индексов:
    ```
    db.currentOp({ $or: [{ op: "command", "query.createIndexes": { $exists: true } }, { op: "none", ns: /\.system\.indexes\b/ }] })
    ```

См. также примеры в [документации {{ MG }}](https://docs.mongodb.com/manual/reference/method/db.currentOp/#examples).

## Устранение проблем с дефицитом ресурсов {#solving-deficit} 

[Попробуйте оптимизировать](#optimize) найденные запросы. Если нагрузка все еще высокая или оптимизировать нечего, остается только [поднять класс хостов](../operations/update.md#change-resource-preset).

## Диагностика неэффективного выполнения запросов {#inefficient-queries}

Чтобы выявить проблемные запросы в {{ MG }}:
   - Изучите [логи](../operations/monitoring.md#explore-logs). Особое внимание стоит обратить на:
      - для операций чтения — на поле `responseLength` (в логах отображается как `reslen`);
      - для операций записи — на количество затронутых документов (поля `nModified`, `keysInserted`, `keysDeleted`).
   - Изучите данные [профилировщика](../operations/monitoring.md#explore-profiler). Выведите долго выполняемые запросы (регулируется настройкой `slowOpThreshold`).

## Устранение проблем с неэффективными запросами {#optimize}

Каждый отдельный запрос можно проанализировать с точки зрения его плана (query plan). Подробнее об этом можно прочитать в официальной документации {{ MG }}:

- [Руководство по анализу запросов](https://docs.mongodb.com/manual/tutorial/analyze-query-plan/).
- [Справка по функции `db.collection.explain`](https://docs.mongodb.com/manual/reference/method/db.collection.explain/#db.collection.explain).

Для ускорения выборок стоит применять [индексы](https://docs.mongodb.com/manual/indexes).

{% note warning %}

Каждый новый индекс замедляет запись. Большое количество индексов может негативно влиять на производительность при записи.

{% endnote %}

Возможной оптимизацией операций чтения может быть использование частичного извлечения ([projection](https://docs.mongodb.com/manual/tutorial/project-fields-from-query-results/)). Во многих случаях доставать документ целиком не нужно, достаточно нескольких его полей.

Если не удается ни оптимизировать найденные запросы, ни отказаться от них, можно [поднять класс хостов](../operations/update.md#change-resource-preset).

## Диагностика наличия блокировок (locks) {#localize-locking-issues}

Причиной низкой производительности запросов могут быть блокировки (locks).

{{ MG }} не предоставляет подробной информации по блокировкам. В частности, есть только косвенные способы узнать, чем заблокирован конкретный запрос:

- Большие или растущие значения `db.serverStatus().metrics.operation.writeConflicts` могут говорить о высоком write contention на каких-то документах.

- В момент падения производительности стоит внимательно изучить [список текущих запросов](../operations/monitoring.md#list-running-queries):
  - Найти операции, которые удерживают эксклюзивные блокировки, например:
    ```
    db.currentOp({'$or': [{'locks.Global': 'W'}, {'locks.Database': 'W'}, {'locks.Collection': 'W'} ]}).inprog
    ```
  - Найти операции, ожидающие блокировок (в поле `timeAcquiringMicros` будет видно время ожидания):
    ```
    db.currentOp({'waitingForLock': true}).inprog
    
    db.currentOp({'waitingForLock': true, 'secs_running' : { '$gt' : 1 }}).inprog
    ```

- В [логах](../operations/monitoring.md#explore-logs) и [профилировщике](../operations/monitoring.md#explore-profiler) стоит обратить внимание на следующее:
  - операции, долго ожидавшие получения блокировок, будут иметь большие значения `timeAcquiringMicros`;
  - операции, которые конкурировали за одни и те же документы, будут иметь большие значения `writeConflicts`.

Обратитесь к официальной документации {{ MG }} за информацией о том, какие блокировки выполняют стандартные [клиентские](https://docs.mongodb.com/manual/faq/concurrency/#what-locks-are-taken-by-some-common-client-operations ) и [административные](https://docs.mongodb.com/manual/faq/concurrency/#which-administrative-commands-lock-the-database) команды.

## Устранение проблем с блокировками {#solve-locks}

Найденные блокировки указывают на неоптимизированные запросы. Попробуйте [оптимизировать проблемные запросы](#optimize).

## Диагностика недостатка дискового пространства {#disk-deficit}

Если кластер демонстрирует низкую производительность в сочетании с малым объемом свободного дискового пространства, возможно, для одного или нескольких хостов кластера [активировался режим read-only](../concepts/disk-space.md). 

## Устранение проблем с дисковым пространством {#solve-disk-deficit}

Рекомендации по устранению проблем приведены в разделе [{#T}](../concepts/disk-space.md#read-only-monitor).
