# Типы данных

{{ datalens-short-name }} работает с различными источниками данных, в которых типы данных полей могут отличаться.

Для более эффективной работы с данными, {{ datalens-short-name }} конвертирует типы данных полей источника в собственные типы.
Это оптимизирует работу с данными. Подробнее в разделе [{#T}](#types-lookup-table).

Вы можете изменять тип данных у полей в интерфейсе датасета и в визарде.

{% note warning %}

При загрузке CSV-файла в качестве источника данных, {{ datalens-short-name }} пытается автоматически определить тип данных полей.  
Если определить тип данных не удалось, DataLens задает полю тип `Строка`.

Вы можете самостоятельно изменить тип данных в интерфейсе датасета или в визарде.

{% endnote %}

## Геоточка {#geopoint}

Точка координат, которая состоит из значений широты и долготы. В {{ datalens-short-name }} задается с помощью функции [GEOPOINT](../function-ref/GEOPOINT.md).

Функция принимает на вход типы данных `Строка`, `Геоточка`, или два значения с типом `Дробное число` или `Строка`.
Если на вход подается одна строка, в ней должен содержаться список из двух чисел в JSON-синтаксисе.

Если в источнике данные записаны в формате следующей строки `"[55.75222,37.61556]"`, вы можете изменить тип данных поля в интерфейсе датасета и в визарде без использования формулы.

#### Пример записи {#geopoint-example}

```sql
GEOPOINT("[55.7912,37.6872]")
GEOPOINT("[55.8538,37.6312]")
```

## Геополигон {#geopolygon}

Несколько точек координат, которые описывают полигон на карте. В {{ datalens-short-name }} задается с помощью функции [GEOPOLYGON](../function-ref/GEOPOLYGON.md).
Для заливки полигона используется алгоритм [Even-Odd](https://en.wikipedia.org/wiki/Even–odd_rule). Это позволяет создавать полигоны с вырезами.

Функция принимает на вход строку вида `"[[[v1,v1], [v2,v2]], ..., [[vN-1,vN-1], [vN,vN]]]"`. Если в источнике данные записаны в таком формате, вы можете изменить тип данных поля в интерфейсе датасета и в визарде без использования формулы.

#### Пример записи {#geopolygon-example}

```sql
/* Полигон без выреза */
GEOPOLYGON("[[[55.79421,37.65046],[55.79594,37.6513],[55.79642,37.65133],[55.7969, 37.65114],[55.79783, 37.65098],[55.78871,37.75101]]]")

/* Полигоны с вырезом */
GEOPOLYGON("[[[55.75,37.52],[55.75,37.68],[55.65,37.60]],[[55.79,37.60],[55.76,37.57],[55.76,37.63]]]")
GEOPOLYGON("[[[55.75,37.50],[55.80,37.60],[55.75,37.70],[55.70,37.70],[55.70,37.50]],[[55.75,37.52],[55.75,37.68],[55.65,37.60]],[[55.79,37.60],[55.76,37.57],[55.76,37.63]]]")
```

## Дата {#date}

Дата без указанного времени. 

При использовании в формулах необходимо задавать дату с помощью знака решетки `#`. Например `DATETRUNC(#2018-07-12#, "year", 5)`.

Вы можете привести исходный тип данных в тип `Дата` с помощью функций [DATE](../function-ref/DATE.md) и [DATE_PARSE](../function-ref/DATE_PARSE.md).

#### Пример записи {#date-example}

```sql
#2018-01-18#
#2015-01-01#
DATETRUNC(#2018-07-12#, "year", 5)
DATEADD(#2018-01-12#, "day", 6)
```

## Дата и время {#datetime}

Дата с указанным временем.

При использовании в формулах необходимо задавать дату и время с помощью знака решетки `#`. Например `DATEADD(#2018-01-12 01:02:03#, "second", 6)`.

Вы можете привести исходный тип данных в тип `Дата и время` с помощью функций [DATETIME](../function-ref/DATETIME.md) и [DATETIME_PARSE](../function-ref/DATETIME_PARSE.md).

#### Пример записи {#datetime-example}

```sql
#2018-01-12 01:08:03#
#2018-05-01T#
DATEADD(#2018-01-12 01:02:03#, "second", 6)
DATETRUNC(#2018-07-12 11:07:13#, "month", 4)
```

## Дробное число {#float}

Вещественное число. В качестве разделителя используется символ точки.

Вы можете привести исходный тип данных в тип `Дробное число` с помощью функции [FLOAT](../function-ref/FLOAT.md).

{% note warning %}

При конвертации типа `decimal` в `Дробное число` возможна потеря точности.

{% endnote %}

#### Пример записи {#float-example}

```sql
1.47113
0.62024
FLOAT("34.567")
```

## Логический {#boolean}

Логический тип, который принимает только одно из двух значений — `TRUE` или `FALSE`.

Вы можете привести исходный тип данных в тип `Логический` с помощью функции [BOOL](../function-ref/BOOL.md).

#### Пример записи {#boolean-example}

```sql
FALSE
```

## Строка {#string}

Строка с текстом. Задается с помощью символов одиночных или двойных кавычек.
В случае использования одного вида кавычек, второй вид можно свободно использовать в этой строке без экранирования.
Например, `'Парные кавычки "пример" и одна " кавычка.'`

В строках вы можете использовать следующие символы:
- `\n` - перенос строки (LF);
- `\r` - возврат каретки (CR);
- `\t` - табуляция;
- `\"` - двойная кавычка;
- `\'` - одинарная кавычка;
- `\\` - обратная косая черта.

Вы можете привести исходный тип данных в тип `Строка` с помощью функции [STR](../function-ref/STR.md).

#### Пример записи {#string-example}

```sql
"Строка"
'Строка с "подстрокой"'
```

## Целое число {#integer}

Число, которое не содержит дробной части.

Вы можете привести исходный тип данных в тип `Целое число` с помощью функции [INT](../function-ref/INT.md).

#### Пример записи {#integer-example}

```sql
42
157
```

## Таблица соответствий типов данных {#types-lookup-table}

При создании датасета {{ datalens-short-name }} приводит данные из источника в свой тип для оптимизации.
Это позволяет {{ datalens-short-name }} унифицировать работу с данными из разных источников.

Ниже приведена таблица соответствий типов баз данных и внутренних типов {{ datalens-short-name }}.

DataLens | Материализованный<br/>датасет | ClickHouse | PostgreSQL | MySQL | MS SQL | 
----- | ----- | ----- | ----- | ----- | ----- | 
**Логический** | boolean | boolean | boolean | bit | bit |
**Дата**| date | date | date | date | date |
**Дата и время** | datetime | datetime | timestamp | datetime<br/>timestamp | datetime<br/>datetime2<br/>smalldatetime<br/>datetimeoffset |
**Дробное число** | float | float<br/>float32<br/>float64<br/>decimal<sup>*</sup> | real<br/>double precision<br/>numeric | float<br/>double<br/>numeric<br/>decimal<sup>*</sup> | float<br/>real<br/>numeric<br/>decimal<sup>*</sup>
**Целое число** | int64 | integer<br/>int8<br/>int16<br/>int32<br/>int64<br/>uint8<br/>uint16<br/>uint32<br/>uint64 | smallint<br/>integer<br/>bigint | tinyint<br/>smallint<br/>mediumint<br/>integer<br/>bigint | tinyint<br/>smallint<br/>integer<br/>bigint
**Строка** | string | string<br/>enum8<br/>enum16 | char<br/>varchar<br/>text<br/> | tinyblob<br/>blob<br/>binary<br/>varbinary<br/>char<br/>varchar<br/>tinytext<br/>text<br/>enum | char<br/>varchar</br>text<br/>nchar<br/>nvarchar<br/>ntext<br/>
**Геоточка** | Задается формулой в {{ datalens-short-name }} | Задается формулой в {{ datalens-short-name }} | Задается формулой в {{ datalens-short-name }} | Задается формулой в {{ datalens-short-name }} | Задается формулой в {{ datalens-short-name }} |
**Геополигон** | Задается формулой в {{ datalens-short-name }}  | Задается формулой в {{ datalens-short-name }} | Задается формулой в {{ datalens-short-name }} | Задается формулой в {{ datalens-short-name }} | Задается формулой в {{ datalens-short-name }} |

<sup>*</sup> Возможна потеря точности при конвертации данных.
