# Детально про сегменты и ключи сегментов

Проще всего понятие `сегментов` и `ключей сегментов` можно описать на простом, но реальном примере. 

Представьте, что вы делаете финансовое приложение, которое считает баланс пользователей. Каждый раз, когда пользователь пополняет счет, снимает деньги со счета или выполняет покупку, создается сообщение с идентификатором пользователя и денежной суммой. Приложению нужно решить: если баланс положительный, то покупку можно разрешить, если же баланс будет отрицательный, то покупать ничего нельзя, пока баланс не станет положительным.

Для решения этой задачи берем компонент "очередь задач", в эту очередь записываем все сообщения об изменениях счета, а нашим приложением из этой очереди обрабатываем события.

Так как мы разрабатываем финансовое приложение, то нам важен порядок обработки отдельных сообщений. Нельзя, чтобы сначала пришло событие покупки, а только потом событие пополнения счета, так как в этом случае мы можем отклонить покупку из-за нехватки средств. В очередях сообщений есть механизмы гарантии порядка обработки сообщений, но эти механизмы не могут обеспечить порядок сообщений внутри одной-единственной очереди на произвольных объемах данных. 

{{ yds-full-name }} решает эту задачу другим образом: вместо того, чтобы гарантировать порядок сообщений внутри одной очереди произвольного размера, {{ yds-full-name }} создает очередь из большого числа независимых `сегментов` небольшого размера, внутри каждого из которых порядок сообщений гарантирован. Таких сегментов внутри потока данных может быть неограниченное количество. Такой подход позволяет обеспечивать строгую последовательность чтения событий при неограниченном масштабировании.

За счет увеличения числа `сегментов` мы можем произвольно наращивать мощности потоков данных, но в какой-то момент перестанет хватать мощности единственного экземпляра нашего приложения, чтобы обрабатывать данные всех клиентов. Для решения задачи нехватки мощности, мы добавляем второй экземпляр приложения, который тоже читает данные из очереди. 

Так как из очереди читают теперь два экземпляра приложения, то может так получиться, что событие пополнения счета получает первый экземпляр приложения, а событие о списании - второй, что приводит к неправильной информации о балансе пользователя в каждом из экземпляров. Получается, что у нас нет единого места, где по каждому пользователю была бы известна информация о величине его средств. 

Для решения этой задачи можно сохранять данные в СУБД, можно обмениваться информацией между экземплярами приложения, можно строить распределенный кэш, но можно и проще - сделать так, чтобы вся информация о действиях со счетом одного пользователя приходила все время в один и тот же экземпляр приложения. Тогда каждое приложение будет знать актуальное число средств каждого из клиентов в каждый момент времени, а задачи синхронизации данных между экземплярами приложения не возникает. 

Информация, определяющая источник сообщения в терминах пользователя, называется `ключом сегмента` или `PartitionKey`. В нашем случае в качестве `ключа сегмента` может выступать идентификатор счета, чей баланс изменяется. Когда это событие записывается в {{ yds-full-name }}, {{ yds-full-name }} самостоятельно (с помощью функции хэширования) вычислит идентификатор сегмента и запишет в него поступающие данные. Таким образом все события с одним счетом будут попадать в один сегмент, а единственный, связанный с этим сегментом, экземпляр приложения будет их обрабатывать в строгом порядке. 