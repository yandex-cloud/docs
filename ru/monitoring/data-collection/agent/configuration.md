# Конфигурирование

Данный раздел описывает конфигурирование {{unified-agent-full-name}}.

## Файлы конфигурации { #files }

Конфигурирование {{unified-agent-short-name}} осуществляется при помощи файлов конфигурации, представляющих собой YAML-документы со следующими секциями:

- routes — описание [маршрутов доставок](concepts.md#routes);
- channels — описание [именованных каналов](concepts.md#channels);
- pipes — описание [именованных преобразований](concepts.md#pipes);
- storages — описание [хранилищ](concepts.md#storages);
- main_thread_pool — настройки системного пула потоков.

Также конфигурационный файл может содержать директиву `import` для [импорта других файлов конфигурации](#import).

Для использования файла конфигурации необходимо передать путь к нему в параметр командой строки `--config` при запуске агента:
```bash
/usr/bin/unified_agent --config /etc/yandex/unified_agent/config.yml
```
При использовании {{unified-agent-short-name}}, поставляемого в виде deb-пакета, базовый файл конфигурации `/etc/yandex/unified_agent/config.yml` автоматически устанавливается и передается в параметр `--config`.

Пользовательскую конфигурацию рекомендуется добавлять в отдельный файл в директории `/etc/yandex/unified_agent/conf.d`. Файлы из этой директории импортируются из базового файла конфигурации с помощью директивы `import` в алфавитном порядке. Механизм импорта описан в секции [{#T}](#import) данного раздела.

В разделе [{#T}](#examples) приведены различные примеры конфигураций, а также пример-справочник, содержащий полный список параметров конфигурации и их описание.

## Импорт конфигурационных файлов { #import }
При помощи директы `import` можно импортировать другие конфигурационные файлы. Значение директивы — строка или массив строк, каждая строка раскрывается при помощи функции ["glob"](http://man7.org/linux/man-pages/man7/glob.7.html). Файлы импортируются в порядке следования директив `import`, а внутри одной директивы - в лексикографическом порядке по именам файлов.

При импорте файлов конфигурации работают правила:

- следующие разделы будут взяты из последнего импортируемого файла:
  - `monitoring`;
  - `status`;
  - `main_thread_pool`;
- следующие разделы представляют собой список и новые элементы дописываются в конец списка, либо заменяются, если совпадает `name` элемента:
  - `channels`;
  - `storages`;
  - `pipes`;
  - `services`;
- раздел `routes` представляет собой список, который пополняется дописыванием новых элементов в конец;

Директива `import` может содержаться в импортируемых файлах, но в целях упрощения конфигурации использование `import` во вложенных файлах не рекомендуется. Если такая необходимость возникает, то в `import` рекомендуется указывать только абсолютные пути. Относительные пути работают от рабочей директории запуска агента.

При циклическом импорте конфигурации {{unified-agent-short-name}} завершится с ошибкой. Детали ошибки можно увидеть в логах агента. Максимальная глубина рекурсии — 100.

При ошибках в импортированном файле выводится полный путь к исходному импортированному файлу, содержащему ошибочный узел.

## Вывод и валидация итоговой конфигурации {#validation}

Для валидации конфигурации агента выполните команду:
```bash
unified_agent --config /etc/yandex/unified_agent/config.yml check-config
```

Если конфигурация валидна, агент выведет в `stdout` ее итоговый вариант после выполнения всех импортов и вернет нулевой код возврата.

В противном случае, агент выведет ошибки конфигурации в `stderr` и вернет ненулевой код возврата:

```bash
$ unified_agent --config console_to_lb.yml check-config
yaml-cpp: error at line 10, column 3: unrecognized field [statos_port]
```

## Директивы конфигурации { #configuration_sections }

Ниже описаны секции конфигурации и параметры различных компонентов {{unified-agent-short-name}}. Для необязательных параметров значения, приведенные в примерах, являются значениями по умолчанию.

### Секция storages { #storages_section }
Секция содержит список [хранилищ](concepts.md#storages).

Описание хранилища состоит из следующих элементов:

- `name` — имя хранилища, по которому на него можно сослаться из цепочки обработки;
- `plugin` — [плагин хранилища](#storages);
- `config` — конфигурация входа. Параметры конфигурации всех хранилищ перечислены в разделе ["Хранилища"](#storages).

Сослаться на хранилище из цепочки обработки можно при директивы `storage_ref`.

Директива `storage_ref` состоит из следующих элементов:

- `name` — имя хранилища, определенное в секции `storages`;
- `flow_control` — настройки [механизма создания сессий](#flow_control);

Пример секции `storages`:

```yaml
storages:
- name: main
  plugin: fs
  config:
    directory: ./data/storage/main
    max_partition_size: 500mb
- name: secondary
  plugin: fs
  config:
    directory: ./data/storage/secondary
    max_partition_size: 100mb
```

Пример цепочки обработки, использующей хранилище:

{% code '/logbroker/unified_agent/examples/all.yml' lines='[BEGIN storage_ref_example]-[END storage_ref_example]' lang='yaml' %}

### Секция routes { #routes }
Секция содержит список [маршрутов доставки](concepts.md#routes).

Маршрут доставки состоит из следующих элементов:

- `input` — [вход](concepts.md#inputs);
- `channel` — [канал](concepts.md#channels).

Вход состоит из следующих элементов:

- `plugin` — [плагин входа](#inputs);
- `config` — конфигурация входа. Параметры конфигурации всех входов перечислены в разделе ["Входы"](#inputs);
- `flow_control` — конфигурация механизма создания сессий входа.

Канал состоит из следующих элементов:

- `pipe` — цепочка обработки;
- один из элементов `output`, `channel_ref`, `case` или `fanout` — `output` содержит конфигурацию выхода, `channel_ref` — ссылку на именованный канал, `case` — разветвитель, направляющий входной поток в один или несколько дочерних каналов по условию, `fanout` — разветвитель, безусловно направляющий входной поток во все дочерние каналы.

Пример секции routes:

```yaml
routes:
  - input:
      plugin: someinput
    channel:
      pipe:
        - filter:
            plugin: somefilter
            config: ...
        - filter:
            plugin: somefilter
            config: ...
        - storage:
            storage_ref:
              name: mystorage
      output:
        plugin: someoutput
        config: ...

  - input:
      plugin: someinput
    channel:
      pipe:
        - filter:
            plugin: somefilter
            config: ...
      channel_ref:
        name: mychannel

  - input:
      plugin: someinput
    channel:
      pipe:
        - filter:
            plugin: somefilter
            config: ...
      fanout:
        - channel:
            ...
        - channel:
            ...
        - channel:
            ...



```

Пример использования элемента `case`:

{% code '/logbroker/unified_agent/examples/all.yml' lines='[BEGIN case_example]-[END case_example]' lang='yaml' %}

### Секция channels { #channels }
Секция содержит список именованных [каналов](concepts.md#channels). Перечисленные в этой секции каналы можно использовать в маршрутах доставки, обращаясь к ним по имени.

Пример секции channels:

{% code '/logbroker/unified_agent/examples/all.yml' lines='[BEGIN channels]-[END channels]' lang='yaml' %}

Пример маршрута доставки, использующий именованный канал:

{% code '/logbroker/unified_agent/examples/all.yml' lines='[BEGIN channel_ref_example]-[END channel_ref_example]' lang='yaml' %}


### Секция pipes { #pipes }
Секция содержит список именованных [цепочек обработки](concepts.md#pipes). Перечисленные в этой секции цепочки можно использовать в каналах, обращаясь к ним по имени.

Пример секции pipes:

{% code '/logbroker/unified_agent/examples/all.yml' lines='[BEGIN pipes]-[END pipes]' lang='yaml' %}

Пример маршрута доставки, использующий именованную цепочку обработки:

{% code '/logbroker/unified_agent/examples/all.yml' lines='[BEGIN pipe_ref_example]-[END pipe_ref_example]' lang='yaml' %}

### Секция main_thread_pool { #main_thread_pool }
Секция содержит конфигурацию потоков выполнения.

Описание параметров:

{% code '/logbroker/unified_agent/examples/all.yml' lines='[BEGIN main_thread_pool]-[END main_thread_pool]' lang='yaml' %}

### Секция agent_log { #agent_log }
Секция содержит настройки логов самого агента. Могут быть переопределены через параметры командной строки.

Описание параметров:

{% code '/logbroker/unified_agent/examples/all.yml' lines='[BEGIN agent_log]-[END agent_log]' lang='yaml' %}

### Секция system { #system }
Разные системные настройки.

Описание параметров:

{% code '/logbroker/unified_agent/examples/all.yml' lines='[BEGIN system]-[END system]' lang='yaml' %}

### Входы { #inputs }

#### agent_metrics { #agent_metrics_input }

backlog
bytes_lost
errors
messages_lost

#### prometheus_pull { #prometheus_pull_input }

Вход опрашивает заданный url с некоторой периодичностью и парсит из ответа метрики в формате Prometheus.

Описание параметров:

```yaml
- input:
    plugin: prometheus_pull
    config:
    # URL, на который будем ходить за данными.
    url: http://localhost:12345  # обязательный

    # Периодичность опроса источника данных.
    poll_period: 15s  # необязательный, по умолчанию 15 секунд

    # Неймсмпейс, в который нужно поместить метрики.
    # Если указан, будет добавлен префиксом к имени всех метрик.
    namespace: null  # необязательный, по умолчанию не задан

    # Число повторых попыток, если запрос завершился с ошибкой.
    retry_count: 0  # необязательный, по умолчанию 0

    # Задержка между повторными попытками.
    retry_delay: 1s  # необязательный, по умолчанию 1 секунда

    # Таймаут запроса, включая все повторые попытки.
    timeout: 5s  # необязательный, по умолчанию 5 секунд

    # Заголовки, которые нужно добавить к запросу.
    headers:  # необязательный, по умолчанию не задан
        h1: v1
        h2: v2

    # Имена заголовков http-ответа, которые нужно сохранить в метаданных сообщения.
    capture_response_headers: [content-type]  # необязательный, по умолчанию не задан

    # http-метод, который нужно использовать в запросе.
    # Возможные значения: GET, POST
    http_method: GET  # необязательный, по умолчанию GET
```

#### system_metrics { #system_metrics_input }

TODO: сослаться на внешние ресурсы, описать откуда берутся

Вход для сбора статистики использования системных ресурсов (cpu, память, диск и тп).

Описание параметров:

```yaml
- input:
    plugin: linux_metrics
    config:
    # Периодичность сбора статистики.
    poll_period: 15s  # необязательный, по умолчанию 15 секунд

    # Директория со смонтированным procfs, из которой будут браться счетчики.
    # Если агент запущен в docker-контейнере, то можно прокинуть хостовый /proc внутрь
    # контейнера с помощью параметра -v, и таким образом мониторить хостовую систему.
    proc_directory: "/proc"  # необязательный, по умолчанию "/proc"

    # Директория со смонтированным sysfs, из которой будут браться счетчики.
    # Если агент запущен в docker-контейнере, то можно прокинуть хостовый /sys внутрь
    # контейнера с помощью параметра -v, и таким образом мониторить хостовую систему.
    sys_directory: "/sys"  # необязательный, по умолчанию "/sys"

    # Список ресурсов, с которых нужно собирать статистику.
    # Ключ — одно из значений cpu, memory, network, storage, io, kernel.
    # Значение — степень детализации, одно из значений basic, advanced.
    resources:  # необязательный
        cpu: advanced  # необязательный, по умолчанию – basic

        memory: advanced  # необязательный, по умолчанию – basic

        network: advanced  # необязательный, по умолчанию – basic

        storage: advanced  # необязательный, по умолчанию – basic

        io: advanced  # необязательный, по умолчанию – basic

        kernel: advanced  # необязательный, по умолчанию – basic
```

### Фильтры { #filters }

#### assign { #assign_filter }

Фильтр для присвоения метаданных сессии или сообщений.

Значение метаданных формируется при помощи шаблона. Синтаксис шаблона: `{key:format|default}`. Экранирование фигурных скобок осуществляется при помощи `\`: `"\{\}"`.

Значение `key`:

- `_timestamp` - временная метка сообщения;
- `_payload` - тело сообщения;
- `key` - метаданные с ключем key

В разделе `message`, если ключ метаданных не найден на уровне сообщения, попробуем найти его в метаданных сессии. Если не найден на уровне сессии — подставим значение по умолчанию ({_host|default_host}), либо пустую строку, если значение по умолчанию не указано.

Так же в качестве значения `key` можно указывать макросы:
- `$host_name` - локальное имя машины
- `$short_host_name` - локальное имя машины (краткое — до первой точки)
- `$env('name')` - переменная окружения с именем `name`
- `$file('name')` - содержимое файла с именем `name`

Поддерживается подстановка аргумента макроса из метаданных.
Например, в случае `$file(name)` имя файла будет взято из метаданных с ключем name.

Значение `format`:

- строка форматирования в формате [strftime](http://man7.org/linux/man-pages/man3/strftime.3.html);
- может быть указана только для `_timestamp`.

Значение `default`:

- определяет значение по умолчанию, если нет меты с данным ключом или пустой `_payload`
- не может быть указан для `_timestamp`, так как `_timestamp` есть всегда
- поддерживается для макросов `$env` и `$file`. Применяется, если значение переменной
  окружения - пустая строка, или если указанный файл не найден.
- по умолчанию - пустая строка

Описание параметров:

```yaml
- filter:
    plugin: assign
    config:
        # Должен быть указан хотя бы один из разделов message или session.

        # Значения, которые нужно присвоить в метаданные сообщения.
        # Внутри message должен быть список одноэлементных map-ов,
        # ключ — имя метаданных, значение - шаблон форматирования.
        # Макросы в фигурных скобках в шаблоне могут содержать ключи метаданных ({_host}),
        # и встроенные функции ({$file('test-file')}).
        # Если ключ метаданных не найден на уровне сообщения, попробуем найти его
        # в метаданных сессии. Если не найден на уровне сессии — подставим значение по умолчанию
        # ({_host|default_host}), либо пустую строку, если значение по умолчанию не указано.
        # Ниже приведено несколько примеров таких шаблонов.
        message:  # необязательный, по умолчанию не задан
            # Пример результата: 'Nov 27 21:03:24 test-host test-app:test_payload'.
            # Метка времени форматируется в соответствии с форматом strftime (http://man7.org/linux/man-pages/man3/strftime.3.html).
            # В этом примере значение _app 'test-app:', с двоеточием на конце - типичный
            # результат разбора syslog-сообщения.
            - _payload: "{_timestamp:%b %d %H:%M:%S} {_host} {_app}{_payload}"

            # Подставить вместо $file значение из файла 'test-file'.
            # Если содержимое файла test-file равно test-content, то на выходе
            # получим 'prefix_test-content_suffix'.
            - m1: "prefix_{$file('test-file')}_suffix"

            # Подставить значение из файла, имя которого взять из метаданных с ключом test-file-name.
            - m2: "prefix_{$file(test-file-name)}_suffix"

            # Подставить значение из переменной окружения 'test-env'
            - m3: "prefix_{$env('test-env')}_suffix"

            # Подставить значение из переменной окружения, имя которой взять из метаданных с ключом test-env-name.
            - m4: "prefix_{$env(test-env-name)}_suffix"

            # Подставить имя хоста, на котором запущен агент.
            - m5: "$host_name"

            # Аналогично $host_name, только без домена — префикс до первой точки.
            # Например, если $host_name равен 'lbk-dev-02.search.yandex.net', то в $short_host_name
            # будет значение 'lbk-dev-02'.
            - m6: "$short_host_name"

        # Значения, которые нужно присвоить в метаданные сессии.
        session:  # необязательный, по умолчанию не задан
            # Аналогично message.
            - m1: v1
            - m2: v2
```

#### convert_metrics

Фильтр для преобразования метрик между разными форматами. Формат сообщений на входе берется из метаданных сессии с ключем `_metrics_format` (если он существует), либо из метаданных сообщения с тем же ключем (если он существует). Эти метаданные можно добавить с помощью фильтра `parse_metrics`.

Если формат входящего сообщения определить не удалось (`_metrics_format` не указан ни на уровне сессии, ни на уровне сообщения), то входящее сообщение отбрасывается и инкрементится счетчик `RejectedMessages` этого плагина.

Описание параметров:

```yaml
- filter:
    plugin: convert_metrics
    config:
        # Выходной формат, в который нужно преобразовать входящий набор метрик.
        # Должен быть указан ровно один из вложенных элементов.
        format:  # обязательный
        # Преобразовать в нативный json формат solomon-а (https://docs.yandex-team.ru/solomon/data-collection/dataformat/json).
        solomon_json:
            # Нужно ли склеивать метрики с одним и тем же набором меток.
            # Возможные значения: default (не склеивать), merge_metrics (склеивать).
            merging_mode: default  # необязательный, значение по умолчанию default (не склеивать)

            # Нужно ли форматировать json в human readable (с переносами строк и отступами).
            # Задает размер отступов, если 0 — форматировать не нужно.
            indentation: 0  # необязательный, по умолчанию форматирование выключено

        # Преобразовать в json формат Yandex Monitoring (https://cloud.yandex.ru/docs/monitoring/api-ref/MetricsData/write)
        json:
            # Нужно ли склеивать метрики с одним и тем же набором меток.
            # Возможные значения: default (не склеивать), merge_metrics (склеивать).
            merging_mode: default  # необязательный, значение по умолчанию default (не склеивать)

            # Нужно ли форматировать json в human readable (с переносами строк и отступами).
            # Задает размер отступов, если 0 — форматировать не нужно.
            indentation: 0  # необязательный, по умолчанию форматирование выключено

        # Преобразовать в формат spack (https://wiki.yandex-team.ru/solomon/api/dataformat/spackv1).
        spack:
            # Нужно ли склеивать метрики с одним и тем же набором меток.
            # Возможные значения: default (не склеивать), merge_metrics (склеивать).
            merging_mode: default  # необязательный, значение по умолчанию default (не склеивать)

            # Единицы измерения времени. Возможные значения seconds, millis.
            time_precision: seconds  # необязательный, значение по умолчанию seconds.

            # Нужно ли сжатие данных внутри одного spack-сообщения.
            # Возможные значения: identity (сжатие не применяется), zlib, lz4, zstd.
            compression: identity  # необязательный, значение по умолчанию identity.

        # Набор меток, которые дополнительно нужно добавить к выходному набору метрик.
        labels:  # необязательный, по умолчанию не указан
            l1: v1
            l2: v2

        # Значение времени по умолчанию, которое нужно добавить к выходному набору метрик.
        # Поддерживаются два варианта синтаксиса значений этих параметров — абсолютный и относительный.
        # В абсолютном формате ожидается значение времени в формате Iso8601, например
        # 2014-03-25 03:59:56.654563, 2012-11-23 11:12:13, 2012-11-23, 1990-03-15T15:10:12.
        # В относительном формате требуется указать смещение от одного из предопределенных
        # значений now (текущее время), today (начало текущих суток), yesterday (начало предыдущих суток),
        # tomorrow (начало следующих суток). Смещение состоит из произвольного числа
        # временных дельт, разделенных операторами + или -. Все возможные варианты синтаксиса
        # отдельной дельты можно посмотреть здесь https://a.yandex-team.ru/arc/trunk/arcadia/util/datetime/parser_ut.cpp?rev=7449965#L548.
        # Например, --since yesterday оставит сообщения за
        # вчера и сегодня, а --since now-5m --until now-5m+10s — за интервал в 10 секунд, который начался
        # пять минут назад. По умолчанию дельты отсчитываются от now, то есть вместо now-2m можно писать просто -2m.
        common_time: null  # необязательный, по умолчанию не задан
```

#### filter_metrics

Фильтр позволяет сократить набор передаваемых метрик на основе значений меток.

```yaml
- filter:
    plugin: filter_metrics
    config:
        # Условие на метрики, которые нужно оставить. Все остальные будут отфильтрованы.
        # Описание синтаксиса можно найти здесь https://docs.yandex-team.ru/solomon/concepts/querying#selectors
        match: "{sensor=gauge-*}"  # обязательный
```

#### match { #match_filter }

Фильтрация сообщений по метаданным — фильтр пропускает только те сообщения, которые содержат все перечисленные метаданные.

Описание параметров:

```yaml
- filter:
    plugin: match

    config:
        # Метаданные сессии в формате `ключ:значение`.
        session:  # необязательный
            a: b

        # Метаданные сообщения в формате `ключ:значение`.
        message:  # необязательный
            c: d
            e: f

        # В приведенной выше конфигурации фильтр будет пропускать только те
        # сообщения, у которых метаданные сессии содержат ключ "a" со значением "b",
        # а метаданные сообщения содержат ключ "c" со значением "d" и ключ "e" со
        # значением "f" (обязательно оба).
        #
        # При этом метаданные могут дополнительно содержать любые другие ключи.
```

#### parse_metrics { #parse_metrics_filter }

Фильтр парсит сообщения в одном из указанных в конфигурации форматов, и преобразует их в формат spack.
В метаданные сессии добавляется ключ `_metrics_format` со значением `spack`. В дальнейшем значение этого ключа будет использоваться для десериализации меток из тела сообщений.

{% note info %}

Данный фильтр следует использовать только вместе со входом `http_pull`. Не следует использовать фильтр `parse_metrics` вместе со входом `system_metrics` или `agent_metrics`.

{% endnote %}

Описание параметров:

```yaml
- filter:
    plugin: parse_metrics
    config:
        # Формат сообщений на входе.
        # Должно быть указано ровно одно из значений json, spack, prometheus или from_content_type.
        # Если указано конкретное значение формата (json, spack или prometheus), то все сообщения
        # должны иметь этот формат. Если указан from_content_type, то разные сообщения могут
        # иметь разный формат, определяемый метаданными сообщения.
        # Если формат входящего сообщения определить не удалось (например, если в метаданных
        # сообщения не найден ключ из элемента конфигурации from_content_type), или при
        # разборе сообщения возникла ошибка, то входящее сообщение отбрасывается, инкрементится
        # счетчик RejectedMessages этого плагина, а так же счетчики MessagesLost и BytesLost в health-счетчиках
        # агента. Так же в лог агента будет сделана соответствующая запись с уровнем ERROR.
        format:  # обязательный
            # Входящие сообщения имеют формат solomon_json.
            solomon_json: {}

            # Входящие сообщения имеют формат spack.
            spack: {}

            # Входящие сообщения имеют формат prometheus (https://github.com/prometheus/docs/blob/master/content/docs/instrumenting/exposition_formats.md).
            prometheus: {}

            # Формат входящих сообщений нужно определить на основе content-type по следующим правилам:
            #     application/json -> json
            #     application/x-solomon-spack -> spack
            #     text/plain -> prometheus
            from_content_type:
                # Имя ключа метаданных сообщения, из которого брать content-type.
                meta_key: content-type  # обязательный

        # Имя метки, значение которой следует считать именем метрики.
        # Используется в этом плагине, если требуется добавить к метрикам неймспейс.
        # Так же передается далее в метаданных сессии с ключем _metric_name_label, и используется,
        # например, при конвертации в формат json Yandex Monitoring.
        metric_name_label: sensor  # необязательный, по умолчанию sensor

        # Неймсмпейс, в который нужно поместить метрики.
        # Если указан, будет добавлен префиксом к имени всех метрик.
        namespace: null  # необязательный, по умолчанию не задан
```

#### transform_metrics

Фильтр позволяет изменить метку внутри потока метрик.

Описание параметров:
```yaml
- filter:
    plugin: transform_metric_label
    config:
        # Имя метки, которую нужно преобразовать.
        label: sensor  # обязательный

        # Добавить префикс к значению метки.
        add_value_prefix: ua  # необязательный

        # Переименовать метку.
        rename_to: name  # необязательный

        # Разделитель, который нужно использовать между добавляемым префиксом (add_value_prefix)
        # и текущим значением метки.
        delimiter: .  # необязательный, по умолчанию '.'
```


### Хранилища { #storages }

#### fs { #fs_storage }

Файловое хранилище. Сообщения сохраняются в партициях. Партиции — это директории, содержащие файлы-сегменты с данными сообщений, а также файлы с метаданными.

{% note warning "Использование вместе с опцией монтирования nobarrier" %}

В настоящий момент использование файлового хранилища вместе с опцией монтирования файловой системы `nobarrier` не рекомендуется — при потере питания не гарантируется сохранность данных и может потребоваться ручное вмешательство.

В будущих версиях необходимость ручного вмешательства будет минимизирована.

{% endnote %}

Описание параметров:

```yaml
storages:  # необязательный
  # [BEGIN fs_storage]
  # Хранилище на основе файловой системы.

  # Имя хранилища. По этому имени на хранилище можно сослаться из цепочек преобразований
  # при помощи storage_ref.
  # На одно хранилище можно сослаться только 1 раз.
- name: main  # обязательный
  # Имя плагина. Пока поддерживается только плагин fs для бинарного хранилища в файловой системе.
  plugin: fs  # обязательный

  config:
    # Директория с данными хранилища.
    # В ней создаются поддиректории для партиций.
    directory: ./data/storage  # обязательный

    # Максимальный размер партиции.
    # По умолчанию в хранище есть только одна партиция с именем default.
    # Новая партиция создается только если пользователь явно этого потребовал,
    # указав имя партиции в ключе _partition в метаданных сессии.
    # В основных сценариях партиция только одна, поэтому этот параметр
    # можно считать лимитом на размер всего хранища.
    max_partition_size: 10mb  # обязательный

    # Директория для хранения служебной информации хранилища.
    # По умолчанию - .state внутри directory
    state_directory: {directory} / .state  # необязательный, по умолчанию .state внутри directory

    # Максимальный размер сегмента (одного файлика) внутри партиции.
    # По умолчанию - десятая часть размера партиции
    max_segment_size: {max_partition_size} / 10  # необязательный, по умолчанию десятая часть от max_partition_size

    # Размер блока для записи.
    # Для снижения накладных расходов на системные вызовы перед
    # вызовом write сообщения группируются в блок. Вызов write осуществляется,
    # если размер блока превышает указанный.
    block_flush_size: 1mb  # необязательный, по умолчанию 1mb

    # Время жизни блока для записи.
    # Вызов write будет осуществляться, если с момента поступления первого сообщения
    # в блок прошло больше указанного времени.
    block_flush_period: 10ms  # необязательный, по умолчанию 10ms

    # Размер буфера для вызова syscall read.
    # По умолчанию совпадает с block_flush_size.
    read_buffer_size: {block_flush_size}  # необязательный, по умолчанию совпадает с block_flush_size

    # Время хранения информации о сессии.
    # После закрытия входящей сессии, через которое хранилище о ней
    # перестанет хранить информацию о ней - удалит соответствие
    # sessionId->last_seq_no и метаданные сессии.
    # Сессия удаляется только в том случае, если все данные по ней были записаны в выходы.
    session_retention_time: 1h  # необязательный, по умолчанию 1h

    # Время хранения данных партиции.
    # Партиция будет удалена через указанное время, если все ее данные записаны в выходы,
    # по ним получены подтверждения, и нет активных сессий, пишущих в эту партицию.
    partition_retention_time: 1h  # необязательный, по умолчанию: 1h

    # Частота выполнения проверки на время хранения session_retention_time и partition_retention_time.
    retention_check_period: 1m  # необязательный, по умолчанию 1m

    # Частота выполнения fsync.
    # Чем чаще случается fsync, тем меньший объем данных необходимо будет проверить при восстановлении после сбоя,
    # и тем быстрее произойдет запуск агента.
    checkpoint_period: 1s  # необязательный, по умолчанию не задан

    # Описывает условия, при которых сегменты с данными сохраняются после получения ack от выхода.
    # Когда ни одно условие не выполено, сегменты удаляются в порядке от старых к новым.
    # Под старым сегментом здесь понимается хвостовой, то есть противоположный от того,
    # в который запись идет на данный момент.
    #
    # Условия проверяются в момент получения ack от выхода, в момент поступления новых данных, а так же регулярно
    # с периодичностью retention_check_period.
    #
    # Поддерживаем два счетчика на уровне партиции — TrailingMessageAgeMs и TrailingSegmentAgeMs.
    # Первый определяется по timestamp первого сообщения самого старого сегмента,
    # второй - аналогично по следующему за ним сегменту.
    # TrailingMessageAgeMs примерно (без учета возможной немонотонности timestamp) отражает
    # период времени, за который в партиции имеются данные.
    # TrailingSegmentAgeMs показывает, когда последний сегмент будет удален, а именно — при достижении значения свойства by_age.
    # Значения обоих счетчиков — в миллисекундах.
    # Если в партиции нет ни одного сегмента, оба счетчика равны нулю.
    # Если в партиции только один сегмент, значение TrailingSegmentAgeMs равно нулю.
    #
    # По умолчанию не задан, т.е. самый старый сегмент удаляется при получении ack от
    # выхода для последнего сообщения этого сегмента.
    data_retention:  # необязательный
      # Сегмент не удаляется пока в нем есть более свежие сообщения.
      # Иными словами, в партиции будут храниться данные примерно за указанный период.
      # "Свежесть" определяется по полю timestamp первого сообщения предпоследнего сегмента.
      by_age: 10d  # необязательный, по умолчанию не задан

      # Сегмент не удаляется пока размер данных партиции, исключая собственный размер сегмента,
      # остается меньше указанного.
      # То есть стараемся поддерживать размер партиции не меньше указанного.
      # Если указать by_size: max, то данные будут удаляться только по достижению лимита на размер партиции.
      by_size: 500mb  # необязательный, по умолчанию не задан

    # Уровень логирования, который будет использован при удалении неподтвержденных данных.
    # Обычно мониторинг агента смотрит на значение счетчика `Errors` — общее число событий
    # внутри агента, залогированных с уровнем ERROR.
    # Если переполнение хранилища — потенциально возможный сценарий (например, пользователь периодически может писать
    # больше лимитов на рейт, установленных в пайплайне после `storage_ref`), этим параметром можно
    # отключить зажигание алертов в этом случае.
    # Возможные значения (https://a.yandex-team.ru/arc/trunk/arcadia/library/cpp/logger/priority.h):
    #   EMERG, ALERT, CRITICAL_INFO, ERROR, WARNING, NOTICE, INFO, DEBUG, RESOURCES
    unacknowledged_eviction_log_priority: ERROR  # необязательный, по умолчанию ERROR
```

### Выходы { #outputs }

#### debug { #debug_output }

Отладочный выход — выводит поступающие сообщения в файл или в консоль.

Пока в хранилище не поддержана возможность смотреть на данные локально, можно настроить выгрузку данных в файл через этот выход. Ротацию можно настроить через обычный logrotate, чтобы агент начал писать в новый файл можно воспользоваться ручкой reopen_file. Для этого потребуется примерно такая конфигурация:

```yaml
status:
  port: 16301

output:
  plugin: debug
  id: my_output_id
  config:
    file_name: ./data/output
    delimiter: "\n===\n"
    _test:
      register_test_handlers: true
```

Описание параметров:

```yaml
- channel:
    output:
        plugin: debug
        config:
            # Должно быть указано одно из свойств file_name или directory

            # Имя файла, в который будут записываться сообщения.
            # Для вывода в консоль укажите значение "/dev/stdout".
            file_name: out.txt  # необязательный, по умолчанию не задан

            # Имя директории. Если указано, данные каждой сессии
            # будут писаться в отдельный файл в этой директории с именем,
            # равным идентификатору сессии.
            directory: output_directory  # необязательный, по умолчанию не задан

            # Разделитель сообщений в файле, например "\n".
            delimiter: null  # обязательный
```

#### dev_null { #dev_null_output }

Отладочный «пустой» выход — выбрасывает поступающие сообщения.

Не содержит параметров.

#### yc_metrics { #yc_metrics_output }

Выход для записи метрик в {{monitoring-full-name}} API.

Описание параметров:

```yaml
- channel:
    output:
        plugin: yc_metrics
        config:
        # URL, на который будут отправляться данные метрик
        url: https://monitoring.api.cloud.yandex.net/monitoring/v2/data/write  # необязательный, по умолчанию https://monitoring.api.cloud.yandex.net/monitoring/v2/data/write

        folder_id: b1ge2vt0gml6ce48qcks  # обязательный, идентификатор каталога

        # Настройки IAM-аутентификации.
        iam:  # обязательный
            # Должен быть указан один из элементов cloud_meta или jwt.

            # Если указан, IAM-токен берется из сервиса метаданных.
            cloud_meta: {}  #необязательный, по умолчанию не задан

            # Если указан, JWT-токен обменивается на IAM-токен.
            jwt:  #необязательный, по умолчанию не задан
            # Имя файла с параметрами JWT в формате ydb (https://a.yandex-team.ru/arc/trunk/arcadia/kikimr/public/sdk/cpp/client/iam/iam.cpp?rev=7134670#L204)
            file: "jwt_params.json"  # обязательный

            endpoint: iam.api.cloud.yandex.net  # необязательный, по умолчанию iam.api.cloud.yandex.net

            refresh_period: 1h  # необязательный, по умолчанию 1h

            request_timeout: 10s  # необязательный, по умолчанию 10s

        # Число повторых попыток, если запрос завершился с ошибкой.
        # Если за указанное число запрос так и не был выполнен
        # успешно (то есть не был получен ответ со статусом 200),
        # сообщение отбрасывается, то есть по нему формируется ack в сторону агента.
        # Отброшенные таким образом сообщения учитываются в счетчике DroppedMessages этого плагина,
        # а так же отражаются в общих health-счетчиках MessagesLost и BytesLost.
        retry_count: inf  # необязательный, по умолчанию max_int, то есть сообщения отбрасываться не будут

        # Задержка между повторными попытками.
        retry_delay: 1s  # необязательный, по умолчанию 1 секунда

        # Таймаут запроса, включая все повторые попытки.
        timeout: inf  # необязательный, по умолчанию max_int секунд, то есть сообщения отбрасываться не будут

        # Таймаут на одну попытку.
        request_timeout: 1s  # необязательный, по умолчанию одна секунда
```

## Примеры { #examples }

Примеры конфигураций. Больше инструкций приведено в разделе [{#T}](quickstart/index.md).
