# Конфигурирование

Данный раздел описывает конфигурирование {{unified-agent-full-name}}.

## Концепции
общая концепция: топология, аутентификация

## Входы

### http_pull

### system_metrics

сослаться на внешние ресурсы, описать откуда берутся

### agent_metrics

описать метрики

## Фильтры

### parse_metrics

Фильтр парсит сообщения в одном из указанных в конфигурации форматов, и преобразует их в формат spack.
В метаданные сессии добавляется ключ `_metrics_format` со значением `spack`. В дальнейшем значение этого ключа будет использоваться для десериализации меток из тела сообщений.

{% note info %}

Данный фильтр следует использовать только вместе со входом `http_pull`. Не следует использовать фильтр `parse_metrics` вместе со входом `system_metrics` или `agent_metrics`.

{% endnote %}

Описание параметров:

```yaml
- filter:
    plugin: parse_metrics
    config:
        # Формат сообщений на входе.
        # Должно быть указано ровно одно из значений json, spack, prometheus или from_content_type.
        # Если указано конкретное значение формата (json, spack или prometheus), то все сообщения
        # должны иметь этот формат. Если указан from_content_type, то разные сообщения могут
        # иметь разный формат, определяемый метаданными сообщения.
        # Если формат входящего сообщения определить не удалось (например, если в метаданных
        # сообщения не найден ключ из элемента конфигурации from_content_type), или при
        # разборе сообщения возникла ошибка, то входящее сообщение отбрасывается, инкрементится
        # счетчик RejectedMessages этого плагина, а так же счетчики MessagesLost и BytesLost в health-счетчиках
        # агента. Так же в лог агента будет сделана соответствующая запись с уровнем ERROR.
        format:  # обязательный
            # Входящие сообщения имеют формат solomon_json.
            solomon_json: {}

            # Входящие сообщения имеют формат spack.
            spack: {}

            # Входящие сообщения имеют формат prometheus (https://github.com/prometheus/docs/blob/master/content/docs/instrumenting/exposition_formats.md).
            prometheus: {}

            # Формат входящих сообщений нужно определить на основе content-type по следующим правилам:
            #     application/json -> json
            #     application/x-solomon-spack -> spack
            #     text/plain -> prometheus
            from_content_type:
                # Имя ключа метаданных сообщения, из которого брать content-type.
                meta_key: content-type  # обязательный

        # Имя метки, значение которой следует считать именем метрики.
        # Используется в этом плагине, если требуется добавить к метрикам неймспейс.
        # Так же передаётся далее в метаданных сессии с ключем _metric_name_label, и используется,
        # например, при конвертации в формат json Yandex Monitoring.
        metric_name_label: sensor  # необязательный, по умолчанию sensor

        # Неймсмпейс, в который нужно поместить метрики.
        # Если указан, будет добавлен префиксом к имени всех метрик.
        namespace: null  # необязательный, по умолчанию не задан
```

### convert_metrics

Фильтр для преобразования метрик между разными форматами.
Формат сообщений на входе берется из метаданных сессии с ключем _metrics_format (если он существует),
либо из метаданных сообщения с тем же ключем (если он существует).
Эти метаданные можно добавить с помощью фильтра parse_metrics.
Если формат входящего сообщения определить не удалось (_metrics_format не указан ни на уровне сессии,
ни на уровне сообщения), то входящее сообщение отбрасывается и инкрементится
счетчик RejectedMessages этого плагина.

Описание параметров:

```yaml
- filter:
    plugin: convert_metrics
    config:
        # Выходной формат, в который нужно преобразовать входящий набор метрик.
        # Должен быть указан ровно один из вложенных элементов.
        format:  # обязательный
        # Преобразовать в нативный json формат solomon-а (https://docs.yandex-team.ru/solomon/data-collection/dataformat/json).
        solomon_json:
            # Нужно ли склеивать метрики с одним и тем же набором меток.
            # Возможные значения: default (не склеивать), merge_metrics (склеивать).
            merging_mode: default  # необязательный, значение по умолчанию default (не склеивать)

            # Нужно ли форматировать json в human readable (с переносами строк и отступами).
            # Задаёт размер отступов, если 0 — форматировать не нужно.
            indentation: 0  # необязательный, по умолчанию форматирование выключено

        # Преобразовать в json формат Yandex Monitoring (https://cloud.yandex.ru/docs/monitoring/api-ref/MetricsData/write)
        json:
            # Нужно ли склеивать метрики с одним и тем же набором меток.
            # Возможные значения: default (не склеивать), merge_metrics (склеивать).
            merging_mode: default  # необязательный, значение по умолчанию default (не склеивать)

            # Нужно ли форматировать json в human readable (с переносами строк и отступами).
            # Задаёт размер отступов, если 0 — форматировать не нужно.
            indentation: 0  # необязательный, по умолчанию форматирование выключено

        # Преобразовать в формат spack (https://wiki.yandex-team.ru/solomon/api/dataformat/spackv1).
        spack:
            # Нужно ли склеивать метрики с одним и тем же набором меток.
            # Возможные значения: default (не склеивать), merge_metrics (склеивать).
            merging_mode: default  # необязательный, значение по умолчанию default (не склеивать)

            # Единицы измерения времени. Возможные значения seconds, millis.
            time_precision: seconds  # необязательный, значение по умолчанию seconds.

            # Нужно ли сжатие данных внутри одного spack-сообщения.
            # Возможные значения: identity (сжатие не применяется), zlib, lz4, zstd.
            compression: identity  # необязательный, значение по умолчанию identity.

        # Набор меток, которые дополнительно нужно добавить к выходному набору метрик.
        labels:  # необязательный, по умолчанию не указан
            l1: v1
            l2: v2

        # Значение времени по умолчанию, которое нужно добавить к выходному набору метрик.
        # Поддерживаются два варианта синтаксиса значений этих параметров — абсолютный и относительный.
        # В абсолютном формате ожидается значение времени в формате Iso8601, например
        # 2014-03-25 03:59:56.654563, 2012-11-23 11:12:13, 2012-11-23, 1990-03-15T15:10:12.
        # В относительном формате требуется указать смещение от одного из предопределенных
        # значений now (текущее время), today (начало текущих суток), yesterday (начало предыдущих суток),
        # tomorrow (начало следующих суток). Смещение состоит из произвольного числа
        # временных дельт, разделенных операторами + или -. Все возможные варианты синтаксиса
        # отдельной дельты можно посмотреть здесь https://a.yandex-team.ru/arc/trunk/arcadia/util/datetime/parser_ut.cpp?rev=7449965#L548.
        # Например, --since yesterday оставит сообщения за
        # вчера и сегодня, а --since now-5m --until now-5m+10s — за интервал в 10 секунд, который начался
        # пять минут назад. По умолчанию дельты отсчитываются от now, то есть вместо now-2m можно писать просто -2m.
        common_time: null  # необязательный, по умолчанию не задан
```

### assign { #assign_filter }

Фильтр для присвоения метаданных сессии или сообщений.

Значение метаданных формируется при помощи шаблона. Синтаксис шаблона: `{key:format|default}`. Экранирование фигурных скобок осуществляется при помощи `\`: `"\{\}"`.

Значение `key`:

- `_timestamp` - временная метка сообщения;
- `_payload` - тело сообщения;
- `key` - метаданные с ключем key

В разделе `message`, если ключ метаданных не найден на уровне сообщения, попробуем найти его в метаданных сессии. Если не найден на уровне сессии — подставим значение по умолчанию ({_host|default_host}), либо пустую строку, если значение по умолчанию не указано.

Так же в качестве значения `key` можно указывать макросы:
- `$host_name` - локальное имя машины
- `$short_host_name` - локальное имя машины (краткое — до первой точки)
- `$env('name')` - переменная окружения с именем `name`
- `$file('name')` - содержимое файла с именем `name`

Поддерживается подстановка аргумента макроса из метаданных.
Например, в случае `$file(name)` имя файла будет взято из метаданных с ключем name.

Значение `format`:

- строка форматирования в формате [strftime](http://man7.org/linux/man-pages/man3/strftime.3.html);
- может быть указана только для `_timestamp`.

Значение `default`:

- определяет значение по умолчанию, если нет меты с данным ключом или пустой `_payload`
- не может быть указан для `_timestamp`, так как `_timestamp` есть всегда
- поддерживается для макросов `$env` и `$file`. Применяется, если значение переменной
  окружения - пустая строка, или если указанный файл не найден.
- по умолчанию - пустая строка

Описание параметров:

```yaml
- filter:
    plugin: assign
    config:
        # Должен быть указан хотя бы один из разделов message или session.

        # Значения, которые нужно присвоить в метаданные сообщения.
        # Внутри message должен быть список одноэлементных map-ов,
        # ключ — имя метаданных, значение - шаблон форматирования.
        # Макросы в фигурных скобках в шаблоне могут содержать ключи метаданных ({_host}),
        # и встроенные функции ({$file('test-file')}).
        # Если ключ метаданных не найден на уровне сообщения, попробуем найти его
        # в метаданных сессии. Если не найден на уровне сессии — подставим значение по умолчанию
        # ({_host|default_host}), либо пустую строку, если значение по умолчанию не указано.
        # Ниже приведено несколько примеров таких шаблонов.
        message:  # необязательный, по умолчанию не задан
            # Пример результата: 'Nov 27 21:03:24 test-host test-app:test_payload'.
            # Метка времени форматируется в соответствии с форматом strftime (http://man7.org/linux/man-pages/man3/strftime.3.html).
            # В этом примере значение _app 'test-app:', с двоеточием на конце - типичный
            # результат разбора syslog-сообщения.
            - _payload: "{_timestamp:%b %d %H:%M:%S} {_host} {_app}{_payload}"

            # Подставить вместо $file значение из файла 'test-file'.
            # Если содержимое файла test-file равно test-content, то на выходе
            # получим 'prefix_test-content_suffix'.
            - m1: "prefix_{$file('test-file')}_suffix"

            # Подставить значение из файла, имя которого взять из метаданных с ключом test-file-name.
            - m2: "prefix_{$file(test-file-name)}_suffix"

            # Подставить значение из переменной окружения 'test-env'
            - m3: "prefix_{$env('test-env')}_suffix"

            # Подставить значение из переменной окружения, имя которой взять из метаданных с ключом test-env-name.
            - m4: "prefix_{$env(test-env-name)}_suffix"

            # Подставить имя хоста, на котором запущен агент.
            - m5: "$host_name"

            # Аналогично $host_name, только без домена — префикс до первой точки.
            # Например, если $host_name равен 'lbk-dev-02.search.yandex.net', то в $short_host_name
            # будет значение 'lbk-dev-02'.
            - m6: "$short_host_name"

        # Значения, которые нужно присвоить в метаданные сессии.
        session:  # необязательный, по умолчанию не задан
            # Аналогично message.
            - m1: v1
            - m2: v2
```

### match { #match_filter }

Фильтрация сообщений по метаданным — фильтр пропускает только те сообщения, которые содержат все перечисленные метаданные.

Описание параметров:

```yaml
- filter:
    plugin: match

    config:
        # Метаданные сессии в формате ключ-значение.
        session:  # необязательный
            a: b

        # Метаданные сообщения в формате ключ-значение.
        message:  # необязательный
            c: d
            e: f

        # В приведённой выше конфигурации фильтр будет пропускать только те
        # сообщения, у которых метаданные сессии содержат ключ "a" со значением "b",
        # а метаданные сообщения содержат ключ "c" со значением "d" и ключ "e" со
        # значением "f" (обязательно оба).
        #
        # При этом метаданные могут дополнительно содержать любые другие ключи.
```

### transform_metrics

## Выходы

### http { #http_output }

Выход для записи сообщений по HTTP, например, в {{monitoring-full-name}} API. Поддерживается аутентифиакция при помощи oAuth и IAM.

Описание параметров:

```yaml
- channel:
    output:
        plugin: http
        config:
            # URL, на который будут отправляться сообщения
            url: "https://monitoring.api.cloud.yandex.net/monitoring/v2/data/write" # обязательный

            # Параметры строки запроса.
            query:  # необязательный, по умолчанию не задан
                h1: v1
                h2: v2

            # Заголовки, которые нужно добавить к запросу.
            headers:  # необязательный, по умолчанию не задан
                h1: v1
                h2: v2


            # Число повторых попыток, если запрос завершился с ошибкой.
            # Если за указанное число запрос так и не был выполнен успешно
            # (то есть не был получен ответ со статусом 200),
            # сообщение отбрасывается, то есть по нему формируется ack в сторону агента.
            # Отброшенные таким образом сообщения учитываются в счетчике DroppedMessages этого плагина,
            # а так же отражаются в общих health-счетчиках MessagesLost и BytesLost.
            retry_count: inf  # необязательный, по умолчанию max_int, то есть сообщения отбрасываться не будут

            # Задержка между повторными попытками.
            retry_delay: 1s  # необязательный, по умолчанию 1 секунда

            # Таймаут запроса, включая все повторые попытки.
            timeout: inf  # необязательный, по умолчанию max_int секунд, то есть сообщения отбрасываться не будут

            # Таймаут на одну попытку.
            request_timeout: 1s  # необязательный, по умолчанию одна секунда


            # Настройки oAuth-аутентификации.
            oauth:  # необязательный, по умолчанию не задан
                secret:
                # Должен быть указан либо file, либо env.

                # Имя файла с oAuth-токеном.
                file: ~/.oauth-token  # необязательный, по умолчанию не задан

                # Имя переменной окружения с oAuth-токеном.
                env: OAUTH_TOKEN  # необязательный, по умолчанию не задан

            # Настройки IAM-аутентификации (только в Яндекс.Облаке).
            iam:  # необязательный, по умолчанию не задан
                # Должен быть указан один из элементов cloud_meta или jwt.

                # Если указан, IAM-токен берется из сервиса метаданных.
                cloud_meta: {}  #необязательный, по умолчанию не задан

                # Если указан, JWT-токен обменивается на IAM-токен.
                jwt:  #необязательный, по умолчанию не задан
                    # Имя файла с параметрами JWT в формате ydb (https://a.yandex-team.ru/arc/trunk/arcadia/kikimr/public/sdk/cpp/client/iam/iam.cpp?rev=7134670#L204)
                    file: "jwt_params.json"  # обязательный

                    endpoint: iam.api.cloud.yandex.net  # необязательный, по умолчанию iam.api.cloud.yandex.net

                    refresh_period: 1h  # необязательный, по умолчанию 1h

                    request_timeout: 10s  # необязательный, по умолчанию 10s
```

### debug { #debug_output }

Отладочный выход — выводит поступающие сообщения в файл или в консоль.

??Пока в хранилище не поддержана возможность смотреть на данные локально, можно настроить выгрузку данных в файл через этот выход. Ротацию можно настроить через обычный logrotate, чтобы агент начал писать в новый файл можно воспользоваться ручкой reopen_file. Для этого потребуется примерно такая конфигурация:??

Описание параметров:

```yaml
- channel:
    output:
        plugin: debug
        config:
            # Должно быть указано одно из свойств file_name или directory

            # Имя файла, в который будут записываться сообщения.
            # Для вывода в консоль укажите значение "/dev/stdout".
            file_name: out.txt  # необязательный, по умолчанию не задан

            # Имя директории. Если указано, данные каждой сессии
            # будут писаться в отдельный файл в этой директории с именем,
            # равным идентификатору сессии.
            directory: output_directory  # необязательный, по умолчанию не задан

            # Разделитель сообщений в файле, например "\n".
            delimiter: null  # обязательный
```

### dev_null { #dev_null_output }

Отладочный «пустой» выход — выбрасывает поступающие сообщения.

Не содержит параметров.


## Хранилища { #storages }

## fs { #fs_storage }

TODO: описать хранилище


## Примеры { #examples }

Примеры конфигураций. Больше инструкций приведено в [быстром старте](./quickstart.md).
