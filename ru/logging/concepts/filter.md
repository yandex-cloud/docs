---
title: "Язык фильтрующих выражений в {{ cloud-logging-full-name }}"
description: "Записи в лог-группе можно фильтровать, используя язык фильтрующих выражений. Язык фильтрующих выражений позволяет искать записи по одному или нескольким значениям параметра, а также использовать в фильтрах операции сравнения и логические операторы." 
---

# Язык фильтрующих выражений

Записи в лог-группе можно фильтровать, используя язык фильтрующих выражений. Язык фильтрующих выражений позволяет:
* искать записи по [одному](#parameters) или [нескольким](#multiple-values) значениям параметра;
* использовать в фильтрах [операции сравнения](#comparison-operations) и [логические операторы](#multiple-conditions).

## Как задать фильтр {#how-to}

{% list tabs group=instructions %}

- Консоль управления {#console}

    1. В [консоли управления]({{ link-console-main }}) перейдите в каталог, в котором находится лог-группа.
    1. Выберите сервис **{{ ui-key.yacloud.iam.folder.dashboard.label_logging }}**.
    1. Перейдите на вкладку **{{ ui-key.yacloud.logging.label_groups }}**.
    1. Нажмите на строку с лог-группой, записи в которой хотите отфильтровать.
    1. Перейдите на вкладку **{{ ui-key.yacloud.common.logs }}**.
    1. Введите фильтр и нажмите **Enter**.

- CLI {#cli}

    {% include [cli-install](../../_includes/cli-install.md) %}

    {% include [default-catalogue](../../_includes/default-catalogue.md) %}

    Чтобы задать фильтр с помощью языка фильтрующих выражений, выполните команду:

    ```
    yc logging read --group-name=default --filter="<фильтр>"
    ```

    {% note info %}

    Можно одновременно фильтровать записи с помощью флага `--filter` и других флагов команды `yc logging read`. Тогда условия объединятся с помощью оператора `AND`. Например, можно задать фильтр, используя флаг `--resource-types` и параметр `level` флага `--filter`:

    
    ```
    yc logging read --group-name=default --resource-types=serverless.function --filter="level=INFO"
    ```

    Такой фильтр выведет записи с уровнем логирования `INFO`, которые отправлены за последний час функциями {{ sf-name }}.



    {% endnote %}

- API {#api}

    Задать фильтр можно с помощью вызова gRPC API [LogReadingService/Read](../api-ref/grpc/log_reading_service.md#Read).

{% endlist %}

#### Примеры фильтров {#examples}

>* Записи, в сообщениях которых есть `warning` или `error dialing endpoint`:
>   ```
>   message: warning "error dialing endpoint"
>   ```
>* Записи, созданные после 8 июня 2023 года:
>   ```
>   timestamp > "2023-06-08T00:00:00Z"
>   ```
>* Записи, уровень логирования которых выше или равен `INFO`:
>   ```
>   level >= INFO
>   ```

## Параметры фильтров {#parameters}

Параметр | Формат фильтра | Описание | Пример фильтра
--- | --- | --- | ---
`message` | ```параметр: "значение"``` | Поиск записей, в сообщениях которых есть заданные значения. `message` является параметром по умолчанию, поэтому в запросе его можно не указывать. | ```"Hello world!" Error Exception```
`resource_type` | ```параметр: "значение"```<br>```параметр <операция сравнения> "значение"``` | Поиск записей, отправленных ресурсами заданного типа, например функциями. | ```resource_type = "serverless.function"```
`resource_id` | ```параметр: "значение"```<br>```параметр <операция сравнения> "значение"``` | Поиск записей, отправленных ресурсом с заданным идентификатором. | ```resource_id: "d4e155orh3nu********"```
`json_payload` | ```параметр: "значение"``` | Поиск записей, в `json_payload` которых есть заданные значения. Осуществляется по тексту. | ```json_payload: "error"```
`json_payload.<элемент>` | ```параметр: "значение"```<br>```параметр <операция сравнения> "значение"``` | Поиск записей по элементам `json_payload`. Если в фильтре используется операция сравнения, элемент может быть строкой, числом или логическим значением, в противном случае — только строкой. Префикс `json_payload` можно не указывать, если корневой элемент дерева не совпадает ни с одним из параметров. Проверить существование элемента в `json_payload` можно с помощью оператора `EXISTS`. Например: ```json_payload.result EXISTS```. Такой фильтр выведет записи, в  `json_payload` которых есть элемент `result`. | ```json_payload.flag = FALSE```
`timestamp` | ```параметр <операция сравнения> "значение"``` | Поиск записей, созданных в заданный промежуток времени. | ```timestamp >= "2023-06-08T00:00:00Z"```
`ingested_at` | ```параметр <операция сравнения> "значение"``` | Поиск записей, доставленных в заданный промежуток времени в систему логирования {{ cloud-logging-name }}. | ```ingested_at = "2023-06-22T05:15:03Z"```
`saved_at` | ```параметр <операция сравнения> "значение"``` | Поиск записей, сохраненных в заданный промежуток времени в базу данных {{ cloud-logging-name }}. | ```saved_at >= 1622198048```
`level` | ```параметр <операция сравнения> "значение"``` | Поиск записей с заданными уровнями логирования. Доступные уровни логирования — `TRACE`, `DEBUG`, `INFO`, `WARN`, `ERROR`, `FATAL`.| ```level >= WARN```
`stream_name` | ```параметр <операция сравнения> "значение"``` | Поиск записей по потокам логирования, которые были определены пользователем.| ```stream_name = input```
`request_id` | ```параметр <операция сравнения> "значение"``` | Поиск записей по идентификатору запроса в `json_playload`.| ```request_id <= "145"```


### Требования к значению параметра {#requirements}

Можно не брать значение в кавычки, если оно:
* начинается с буквы латинского алфавита и содержит только буквы латинского алфавита, цифры и знаки подчеркивания;
* является целым числом без знака.

`TRUE`, `FALSE`, `true` и `false` используются для логических значений. Нужно заключить их в кавычки, чтобы найти в тексте.

Доступные типы значений для параметров `timestamp`, `ingested_at` и `saved_at`:
* строка в формате RFC3339:
    ```bash
    saved_at > "2023-05-28T15:20:31Z"
    ```    
* число секунд после 00:00 1970-01-01:
    ```
    saved_at >= 1622198048
    ```

### Поиск вхождений {#multiple-values}

Чтобы отфильтровать записи по нескольким значениям одного параметра, перечислите значения друг за другом:
```
параметр: "значение1" "значение2" "значение3"
```

Чтобы искать значения с учетом регистра, используйте оператор `:!`
```
параметр:! "знаЧеНие1" "значЕнИе2"
```

Поиск логических значений и чисел с плавающей и фиксированной точкой выполняется как поиск вхождения подстроки во множество строк.

## Операции сравнения {#comparison-operations}

Кроме проверки на точное совпадение, язык фильтрующих выражений поддерживает операции сравнения:

* **Равно**

    ```
    параметр = "значение"
    ```

* **Не равно**

    ```
    параметр <> "значение"
    ```

* **Больше**, **Меньше**, **Меньше или равно**, **Больше или равно**

    ```
    параметр > "значение"
    параметр < "значение"
    параметр >= "значение"
    параметр <= "значение"
    ```

Сравнение строк производится в лексикографическом порядке.

## Фильтры с несколькими условиями {#multiple-conditions}

Объединить несколько условий в одном фильтре можно с помощью логических операторов:

* `AND` — логический оператор **И**. Условия, объединенные таким оператором, должны выполняться одновременно.

    Пример:
    ```
    параметр1: "значение1" AND параметр2: "значение2"
    ```
    Такой запрос выведет записи, у которых `параметр1` имеет `значение1` и `параметр2` имеет `значение2`.

* `OR` — логический оператор **ИЛИ**. Должно выполняться хотя бы одно из условий, объединенных таким оператором.

    Пример:
    ```
    параметр1: "значение1" OR параметр2 > "значение2"
    ```
    Такой запрос выведет записи, у которых выполнено хотя бы одно из условий: `параметр1` имеет `значение1` или `параметр2` больше `значение2`.

* `NOT` — логический оператор **НЕ**. Должно выполняться условие, обратное заданному.

    Пример:
    ```
    NOT параметр1: "значение1"
    ```
    Такой запрос выведет записи, у которых `параметр1` имеет значение, отличное от`значение1`.

Создавать сложные фильтры можно, комбинируя несколько операторов в одном запросе:

```
параметр1: "значение1" AND параметр2: "значение2" OR параметр3: "значение3"
```

## Порядок вычислений {#calculation-order}

* Поиск вхождений, операции сравнения, оператор `EXISTS`
* Логический оператор `NOT`
* Логический оператор `AND`
* Логический оператор `OR`

Изменить порядок вычислений можно с помощью скобок:

```
параметр1: "значение1" AND (параметр2 = "значение2" OR параметр3 < "значение3")
``` 
