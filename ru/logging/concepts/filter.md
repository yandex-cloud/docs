# Язык фильтрующих выражений

Записи в лог-группе можно фильтровать, используя язык фильтрующих выражений. Язык фильтрующих выражений позволяет:
* искать записи по [одному](#parameters) или [нескольким](#multiple-values) значениям параметра;
* использовать в фильтрах [операции сравнения](#comparison-operations) и [логические операторы](#multiple-conditions).

## Как задать фильтр {#how-to}

{% list tabs %}

- Консоль управления

	1. В [консоли управления]({{ link-console-main }}) перейдите в каталог, в котором находится лог-группа.
	1. Откройте сервис **{{ cloud-logging-name }}**.
	1. Перейдите на вкладку **Группы**.
	1. Нажмите на строку с лог-группой, записи в которой хотите отфильтровать.
	1. Перейдите на вкладку **Логи**.
	1. Введите фильтр и нажмите **Enter**.

- CLI

	{% include [cli-install](../../_includes/cli-install.md) %}

    {% include [default-catalogue](../../_includes/default-catalogue.md) %}

	Чтобы задать фильтр с помощью языка фильтрующих выражений, выполните команду:

	```
	yc logging read --group-name=default --filter="<фильтр>"
	```

    {% note info %}

    Можно одновременно фильтровать записи с помощью флага `--filter` и других флагов команды `yc logging read`. Тогда условия объединятся с помощью оператора `AND`. Например, можно задать фильтр, используя флаг `--resource-types` и параметр `level` флага `--filter`:

    ```
    yc logging read --group-name=default --resource-types=serverless.function --filter="level=INFO"
    ```

    Такой фильтр выведет записи с уровнем логирования `INFO`, которые отправлены за последний час функциями {{ sf-name }}.

    {% endnote %}

- API

    Задать фильтр можно с помощью метода API [read](../api-ref/grpc/log_reading_service.md).

{% endlist %}

#### Примеры фильтров {#examples}

>* Записи, в сообщениях которых есть `warning` или `error dialing endpoint`:
>	```
>	message: warning "error dialing endpoint"
>	```
>* Записи, отправленные после 8 июня 2021 года:
>	```
>	timestamp > "2021-06-08T00:00:00Z"
>	```
>* Записи, уровень логирования которых выше или равен `INFO`:
>	```
>	level >= INFO
>	```

{% endlist %}

## Параметры фильтров {#parameters}

Параметр | Формат фильтра | Описание | Пример фильтра
--- | --- | --- | ---
`message` | ```параметр: "значение"``` | Поиск записей, в сообщениях которых есть заданные значения. `message` является параметром по умолчанию, поэтому в запросе его можно не указывать. | ```"Hello world!" Error Exception```
`resource_type` | ```параметр: "значение"```<br>```параметр <операция сравнения> "значение"``` | Поиск записей, отправленных заданным сервисом. | ```resource_type = "serverless.function"```
`resource_id` | ```параметр: "значение"```<br>```параметр <операция сравнения> "значение"``` | Поиск записей, отправленных заданным ресурсом, например  функцией. | ```resource_id: "d4e155orh3nu********"```
`json_payload` | ```параметр: "значение"``` | Поиск записей, в `json_payload` которых есть заданные значения. Осуществляется по тексту. | ```json_payload: "error"```
`json_payload.<элемент>` | ```параметр: "значение"```<br>```параметр <операция сравнения> "значение"``` | Поиск записей по элементам `json_payload`. Если в фильтре используется операция сравнения, элемент может быть строкой, числом или логическим значением, в противном случае — только строкой. Префикс `json_payload` можно не указывать, если корневой элемент дерева не совпадает ни с одним из параметров. Проверить существование элемента в `json_payload` можно с помощью оператора `EXISTS`. Например: ```json_payload.result EXISTS```. Такой фильтр выведет записи, в  `json_payload` которых есть элемент `result`. | ```json_payload.flag = FALSE```
`timestamp` | ```параметр <операция сравнения> "значение"``` | Поиск записей, отправленных в заданный промежуток времени. | ```timestamp >= "2021-06-08T00:00:00Z"```
`ingested_at` | ```параметр <операция сравнения> "значение"``` | Поиск записей, доставленных в заданный промежуток времени в систему логирования {{ cloud-logging-name }}. | ```ingested_at = "2021-06-22T05:15:03Z"```
`saved_at` | ```параметр <операция сравнения> "значение"``` | Поиск записей, сохраненных в заданный промежуток времени в базу данных {{ cloud-logging-name }}. | ```saved_at >= 1622198048```
`level` | ```параметр <операция сравнения> значение``` | Поиск записей с заданными уровнями логирования. Доступные уровни логирования — `TRACE`, `DEBUG`, `INFO`, `WARN`, `ERROR`, `FATAL`.| ```level >= WARN```

### Требования к значению параметра {#requirements}

Можно не брать значение в кавычки, если оно:
* начинается с буквы латинского алфавита и содержит только буквы латинского алфавита, цифры и знаки подчеркивания;
* является целым числом без знака.

`TRUE`, `FALSE`, `true` и `false` используются для логических значений. Нужно заключить их в кавычки, чтобы найти в тексте.

Доступные типы значений для параметров `timestamp`, `ingested_at` и `saved_at`:
* строка в формате RFC3339:
    ```bash
    saved_at > "2021-05-28T15:20:31Z"
    ```    
* число секунд после 00:00 1970-01-01:
    ```
    saved_at >= 1622198048
    ```

### Несколько значений параметра {#multiple-values}

Чтобы отфильтровать записи по нескольким значениям одного параметра, перечислите значения друг за другом:
```
параметр: "значение1" "значение2" "значение3"
```

## Операции сравнения {#comparison-operations}

Кроме проверки на точное совпадение, язык фильтрующих выражений поддерживает операции сравнения:

* **Равно**

    ```
    параметр = "значение"
    ```

* **Не равно**

	```
	параметр <> "значение"
	```

- **Больше**, **Меньше**, **Меньше или равно**, **Больше или равно**

    ```
    параметр > "значение"
    параметр < "значение"
    параметр >= "значение"
    параметр <= "значение"
   ```

Сравнение строк производится в лексикографическом порядке.

## Фильтры с несколькими условиями {#multiple-conditions}

Объединить несколько условий в одном фильтре можно с помощью логических операторов:

* `AND` — логический оператор **И**. Условия, объединенные таким оператором, должны выполняться одновременно.

    Пример:
    ```
    параметр1: "значение1" AND параметр2: "значение2"
    ```
    Такой запрос выведет записи, у которых `параметр1` имеет `значение1` и `параметр2` имеет `значение2`.

* `OR` — логический оператор **ИЛИ**. Должно выполняться хотя бы одно из условий, объединенных таким оператором.

    Пример:
    ```
    параметр1: "значение1" OR параметр2 > "значение2"
    ```
    Такой запрос выведет записи, у которых выполнено хотя бы одно из условий: `параметр1` имеет `значение1` или `параметр2` больше `значение2`.

* `NOT` — логический оператор **НЕ**. Должно выполняться условие, обратное заданному.

	Пример:
	```
	NOT параметр1: "значение1"
	```
	Такой запрос выведет записи, у которых `параметр1` имеет значение, отличное от`значение1`.

Создавать сложные фильтры можно, комбинируя несколько операторов в одном запросе:

```
параметр1: "значение1" AND параметр2: "значение2" OR параметр3: "значение3"
```

## Порядок вычислений {#calculation-order}

* Поиск вхождений, операции сравнения, оператор `EXISTS`
* Логический оператор `NOT`
* Логический оператор `AND`
* Логический оператор `OR`

Изменить порядок вычислений можно с помощью скобок:

```
параметр1: "значение1" AND (параметр2 = "значение2" OR параметр3 < "значение3")
``` 
