---
title: Голосовые агенты в {{ foundation-models-full-name }}
description: Голосовые агенты — это инструмент, позволяющий создавать на основе искусственного интеллекта приложения, которые взаимодействуют с пользователем как в текстовом, так и в голосовом формате.
---

# Голосовые агенты

_Голосовые агенты_ — это инструмент {{ foundation-models-full-name }}, позволяющий создавать на основе искусственного интеллекта приложения, которые взаимодействуют с пользователем как в текстовом, так и в голосовом формате.

Голосовые агенты поддерживают двусторонний обмен сообщениями: клиент отправляет события с аудио- или текстовыми инструкциями, а сервер возвращает ответы по мере готовности. Такой потоковый режим позволяет отображать частичные ответы сразу, не дожидаясь завершения обработки и обеспечивая естественное течение диалога.

Голосовые агенты могут применяться для реализации следующих сценариев:

* **Подсказки оператору**. Голосовой агент в режиме реального времени анализирует голосовое или текстовое общение оператора с клиентом и предлагает оператору готовый ответ или ссылку на инструкцию. Это позволяет оператору отвечать на вопросы быстрее и точнее.
* **Голосовой агент**. Современная замена голосовым ботам. Голосовой агент может принимать заказы, отвечать на вопросы в службу поддержки. При этом агент разговаривает без задержек, как живой оператор.
* **Автоматическая суммаризация звонка**. Голосовой агент в режиме реального времени анализирует аудиопоток и выделяет ключевые моменты (темы, договоренности, дальнейшие шаги). К концу беседы формирует краткое резюме и список задач, которые отправляет в [CRM](https://ru.wikipedia.org/wiki/Система_управления_взаимоотношениями_с_клиентами)-систему или в чат.

## {{ realtime-api }} {#realtime-api}

В {{ ai-studio-name }} голосовые агенты можно создавать с помощью _{{ realtime-api }}_ — событийно-ориентированного интерфейса для голосового взаимодействия сервера с клиентом в режиме реального времени через транспорт на базе [WebSocket](https://ru.wikipedia.org/wiki/WebSocket).

### Модель {#model}

Для обработки запросов пользователя {{ realtime-api }} использует специальную мультимодальную модель, которая подходит для интерактивных голосовых и смешанных (голос + текст) сценариев с минимальной задержкой:

**Модель и URI** | **Контекст** | **[Режимы работы](../index.md#working-mode)**
--- | --- | ---
**{{ realtime-model }}**</br>`gpt://<идентификатор_каталога>/{{ realtime-model }}` | 32 768 | Синхронный

Модель разработана специально для работы с русским языком и подойдет для создания голосовых ассистентов, чатов и приложений, где важен живой, естественный диалог.

{{ realtime-api }} работает с аудио в формате [Linear pulse-code modulation](https://ru.wikipedia.org/wiki/Импульсно-кодовая_модуляция).

### Голоса {#voices}

{{ realtime-api }} совместим со всеми [стандартными голосами](../../../speechkit/tts/voices.md) {{ speechkit-full-name }} и [голосами](../../../speechkit/tts/brand-voice/index.md) {{ brand-voice-lite-name }} и {{ brand-voice-premium-name }}.

Примеры голосов можно услышать на [странице сервиса {{ speechkit-name }}](/services/speechkit).

### Сессии {#sessions}

Контекст взаимодействия между клиентом и сервером сохраняется в _сессиях_. Сессия содержит историю диалога и параметры конфигурации — системный промпт модели, выбранный голос для синтеза речи, ожидаемые модальности (текст или речь).

Сессия создается один раз при установлении WebSocket-соединения и действует до закрытия этого соединения. Параметры конфигурации сессии можно изменять в процессе диалога. Например, вы можете обновлять системный промпт, изменять голос синтеза или набор модальностей.

Чтобы продолжить работу после завершения текущей сессии, нужно создать новую сессию.

### События {#events}

_События_ — это основной механизм обмена данными в {{ realtime-api }}. Каждое взаимодействие клиента с сервером описывается в виде события, содержащего обязательное поле `type` — _[тип события](#types)_, указывающий на его назначение.

Клиент отправляет события, чтобы передать данные, инструкции или команды (например, создать новый ответ, загрузить аудио или изменить параметры сессии). Сервер отвечает событиями, которые содержат промежуточные или финальные результаты, а также уведомления о состоянии.

Обмен событиями двусторонний и асинхронный: клиент может отправлять на сервер новые события, не дожидаясь, пока сервер вернет результат предыдущей задачи. Такой подход позволяет обрабатывать ответы в потоковом режиме и реагировать на них сразу, без необходимости ждать завершения всей обработки.

Каждое событие передается как отдельный [JSON](https://ru.wikipedia.org/wiki/JSON)-объект по открытому WebSocket-соединению. Клиент должен уметь принимать и обрабатывать события в режиме реального времени. Кроме того, необходимо учитывать, что ответ может приходить по частям: сначала в виде дельт (частичных данных), а затем — финальным сообщением о завершении.

### Инструменты голосовых агентов {#tools}

Через систему инструментов (`tools`) агент может обращаться к функциям, выполнять поиск в сети, работать с вашими файлами или обращаться к внешним системам и инструментам. Это делает взаимодействие с моделью более интерактивным и полезным в реальных сценариях — от чат-бота поддержки до аналитических ассистентов.

#### Вызов функций {#function-calling}

_Вызов функций_ (Function calling) — это встроенный механизм {{ realtime-api }}, который позволяет модели вызывать заранее описанные функции. Он используется, когда модель должна не только ответить текстом, но и выполнить некое действие — например, получить данные из CRM, вызвать API внешнего сервиса или рассчитать результат.

Функции описываются в виде JSON-схем при инициализации сессии:

```py
"tools": [
    # Функция погоды для демонстрации работы с вызовом функций
    {
        "type": "function",
        "name": "get_weather",
        "description": "Получить краткую сводку погоды по городу.",
        "parameters": {
            "type": "object",
            "properties": {"city": {"type": "string"}},
            "required": ["city"],
            "additionalProperties": False,
        },
    }
],
...
```

Когда модель понимает, что нужно выполнить вызов функции, она возвращает структурированный объект с именем функции и аргументами. Клиент исполняет этот вызов и возвращает ответ модели — создается интерактивный цикл «модель ↔ логика приложения».

```py
if item.get("type") == "function_call":
...
weather_json = fake_weather(city)
...
payload_item = {
    "type": "conversation.item.create",
    "item": {
        "type": "function_call_output",
        "call_id": call_id,
        "output": weather_json,
    },
}
```

#### Поиск в интернете {#web-search}

_Web search_ — инструмент [поиска в интернете](./tools/websearch.md), который позволяет модели получать информацию из открытых источников, чтобы использовать ее для генерации ответа.

Чтобы голосовой агент мог обращаться в интернет, необходимо добавить его в список доступных инструментов при инициализации сессии: 

```py
{
  "session": {
    ...
    "tools": [
        # Инструмент поиска в интернете.
        {
            "type": "function",
            "name": "web_search", # зарезервированное имя функции веб-поиска
            "description": "Поиск в интернете",
            "parameters": "{}", # временно не параметризуется
        }
    ],
    ...
  }
}
```

#### Поиск по файлам {#file-search}

[Инструмент _File Search_](./tools/filesearch.md) позволяет выполнять гибридный поиск по файлам пользователя при формировании ответа.

```py
{
  "session": {
    ...
    "tools": [
        # Инструмент поиска по файлам.
        {
            "type": "function",
            "name": "file_search",  # зарезервированное имя функции поиска по файлам
            "description": "<идентификатор_поискового_индекса>" #идентификатор индекса, созданного с помощью Vector Store API
            "parameters": "{}", # временно не используется
        },
    ],
    ...
  }
}
```

Такой поиск будет полезен при реализации:

* корпоративных баз знаний и инструкций;
* RAG (Retrieval-Augmented Generation) сценариев;
* поддержки клиентов, основанной на внутренних данных компании.

Результаты поиска добавляются в контекст ответа, и модель может формировать ответы со ссылками на конкретные документы или цитаты.

#### MCP {#mcp}

Для вызова сторонних API и сервисов агента можно использовать MCP (Model Context Protocol). MCP позволяет подключить внешний сервер с инструментами и вызывать их автоматически во время сессии. После подключения все инструменты, опубликованные MCP-сервером, становятся доступны агенту в {{ realtime-api }} и могут вызываться моделью автоматически во время сессии.

```py
{
  "session": {
    ...
    "tools": [
      {
        "type": "mcp", # указывает, что инструмент — MCP-сервер
        "server_label": "..", # логическое имя сервера для модели
        "server_url": "...", # адрес MCP-сервера со сторонними API
        "authorization": "{access_token}", # данные для авторизации на MCP-сервере
        "require_approval": "{never или always}" # политика подтверждения перед вызовом инструментов
      }
    ],
    ...
  }
}
```

#### Примеры сценариев использования инструментов {#use-cases}

* Агенты поддержки клиентов — отвечают на вопросы по документации, выполняют запросы во внутренние сервисы и действуют от имени пользователя.
* Ассистенты операторов — дают подсказки на основе актуальных внутренних документов, баз знаний и оперативных данных.
* Бизнес-боты и аналитические помощники — собирают информацию из внешних источников, API и открытых данных, формируют консолидированные отчеты и рекомендации.

#### См. также {#see-also}

* [{#T}](./index.md)
* [{#T}](./tools/websearch.md)
* [{#T}](./tools/filesearch.md)

## Примеры использования {#examples}

[{#T}](../../operations/agents/create-voice-agent.md)
