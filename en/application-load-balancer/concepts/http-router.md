# HTTP router

The HTTP router defines the routing rules for HTTP requests to [backend groups](backend-group.md), lets you modify the request and response headers, and allows you to generate small static responses directly in the load balancer. You can create an empty HTTP router and then add routes to it.

Routes inside an HTTP router are combined in [virtual hosts](#virtual-host). Routing is a two-step process.

1. The most suitable virtual host is selected based on the `Host` header (`:authority` in the case of HTTP/2).
1. The first route whose predicate matches the request is selected. The order of virtual hosts inside the router doesn't matter. However, the order of routes inside the virtual host matters: the most specific routes must be at the top of the list.

## Virtual hosts {#virtual-host}

Virtual hosts combine [routes](#routes) belonging to the same set of domains: the `Host` header values of an HTTP request. Both exact matches and wildcards are supported. When an incoming request is received, the balancer checks route predicates one-by-one and selects the first predicate matching the request.

How the headers of HTTP requests and responses are modified is also configured at the virtual host level.

## Routes {#routes}

Routes are sets of conditions (predicates) that are used by the load balancer to select a route for the request and actions on the request. Conditions may require an exact or partial match of the request URI or specific HTTP methods. As an action, you can select:

* Direct response generated by the load balancer.
* HTTP-redirect with a certain code and request URL modifications.
* Forwarding a request to a [backend group](backend-group.md) for processing. In this case, you can set up timeouts for request processing, WebSocket support, or modification of the URI before sending the request to the backends.

